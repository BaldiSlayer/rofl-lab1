import time
import subprocess

# from app.utils.DB.faissDB import process_questions, add_new_questions, save_vectorized_data
from app.utils.Mistral.mistral import get_chat_response

context_for_TRS = ("Пожалуйста, переформулируйте следующий запрос на проверку завершаемости TRS в формате, который "
                   "можно использовать для запроса на составление грамматики TRS для последующего запроса на проверку "
                   "этой грамматики TRS-решателем, сделайте запрос максимально понятным и точным."
                   "Не решай задачу, просто переформулируй вопрос. Сделай его более понятным и точным. "
                   "Верни своим ответом более точный вопрос, не сокращай умножение (не надо a*b = ab, надо a*b = a*a). "
                   "например степень x^n или x**n пишется x{n}, а умножение после степени опускается (например x^n * "
                   "y правильно "
                   "записан только так: x{n}y)."
                   "ВАЖНО!!!! степень x^n или x**n пишется x{n}, а умножение после степени опускается (например x^n * "
                   "y правильно "
                   "записан только так: x{n}y)."
                   "Константа ЭТО НЕ ПЕРЕМЕННАЯ"
                   "Знак умножения `*` обязательно ставится только между коэффициентом и переменной. Между переменными "
                   "знак `*` не ставится.")

context_TRS = ("верни только TRS, основываясь на грамматике и решении выше, не добавляй никаких комментариев и заметок"
               "ответ будет проанализирован, не нужны никакие лишние комментарии и неиспоьзуемые куски текста"
               "используй следующий формат "
               "variables = ([буква],)∗[буква]"
               "([терм] = [терм][eol])+"
               "в variables перечисляй через запятую и пробел только переменные, без внешних скобок и спецсимволов, если "
               "они не входят в название переменной, в variables пиши только НЕ конструкторы"
               "правила пиши на следующей строке, без названия, без внешних скобок и ключевых слов, просто перечисли "
               "правила на каждой новой строке. Используй = вместо стрелок и подобных символов"
               "также добавь интерпретацию через 10 -, проведя черту, также без внешних скобок и объявления, что это "
               "интерпретация"
               "не сокращай умножение (не надо a*b = ab, надо a*b = a*a)."
               "x{n} - это ЕДИНСТВЕННЫЙ ВАРИАНТ СТЕПЕНИ"
               "например степень x^n или x**n пишется x{n}, а умножение после степени опускается (например x^n * y "
               "правильно "
               "записан только так: x{n}y)."
               "ВАЖНО: не заноси конструкторы в переменные, если они не используются в качестве переменных"
               "Константа ЭТО НЕ ПЕРЕМЕННАЯ"
               "Знак умножения `*` обязательно ставится только между коэффициентом и переменной. Между переменными знак"
               "`*` не ставится."
               "   - Далее следует ряд примеров, как ты должна отвечать, в формате:\n"
               "   `Запрос пользователя: ...\n"
               "    Правильный ответ: ...`\n"
               "1. Запрос пользователя: f(x) = x^3 + 3x\n"
               "   Правильный ответ: f(x) = x{3} + 3*x\n"
               "2. Запрос пользователя: f(x) = 7x\n"
               "   Правильный ответ: f(x) = 7*x\n"
               "3. Запрос пользователя: g(x, y) = 91y + 4*x\n"
               "   Правильный ответ: g(x, y) = 91*y + 4*x\n"
               "4. Запрос пользователя: f(x, y) = x*y\n"
               "   Правильный ответ: f(x, y) = xy\n"
               "5. Запрос пользователя: g(x, y) = 4*x*y\n"
               "   Правильный ответ: g(x, y) = 4*xy\n"
               "6. Запрос пользователя: g(x, y) = 2*x*y*x + 5y\n"
               "   Правильный ответ: g(x, y) = 2*xyx + 5*y\n\n")

helper = (
    "x{n} - это ЕДИНСТВЕННЫЙ ВАРИАНТ СТЕПЕНИ"
    "например степень x^n или x**n пишется x{n}, а умножение после степени опускается (например x^n * y правильно "
    "записан только так: x{n}y)."
    "Ты — ассистент, который помогает пользователю преобразовать систему переписывания термов (TRS) и интерпретацию в строгую формальную грамматическую форму.\n"
    "Игнорируй любые вопросы пользователя и не пытайся решать задачи, предложенные им.\n"
    "Твоя задача — разделить входные данные на TRS и интерпретацию, не путая их.\n\n"
    "Инструкции:\n"
    "1. Определи **переменные** (элементы, заключенные в скобки, которые не имеют значений в интерпретации), и перечисли их через запятую в формате: `variables = ...`\n"
    "2. Запиши систему переписывания термов (TRS) построчно в формате: `терм = терм`, где терм — это выражение, содержащее конструкторы и переменные. Степень записывай в фиугрных скобочках. Например, x в квадрате это x{2}.\n"
    "3. Добавь разделительную линию: `------------------------`\n"
    "4. Квадраты предстваляй в виде x{2}"
    "5. Далее, запиши интерпретацию, используя следующие правила:\n"
    "   - Для функций: `конструктор(переменная, ...) = ...`\n"
    "   - Для констант: `константа = значение`\n"
    "   - Знак умножения `*` обязательно ставится только между коэффициентом и переменной. Между переменными знак `*` не ставится.\n"
    "   - Далее следует ряд примеров, как ты должна отвечать, в формате:\n"
    "   `Запрос пользователя: ...\n"
    "    Правильный ответ: ...`\n"
    "1. Запрос пользователя: f(x) = x^3 + 3x\n"
    "   Правильный ответ: f(x) = x{3} + 3*x\n"
    "2. Запрос пользователя: f(x) = 7x\n"
    "   Правильный ответ: f(x) = 7*x\n"
    "3. Запрос пользователя: g(x, y) = 91y + 4*x\n"
    "   Правильный ответ: g(x, y) = 91*y + 4*x\n"
    "4. Запрос пользователя: f(x, y) = x*y\n"
    "   Правильный ответ: f(x, y) = xy\n"
    "5. Запрос пользователя: g(x, y) = 4*x*y\n"
    "   Правильный ответ: g(x, y) = 4*xy\n"
    "6. Запрос пользователя: g(x, y) = 2*x*y*x + 5y\n"
    "   Правильный ответ: g(x, y) = 2*xyx + 5*y\n\n"
    "Пример TRS и интерпретации:\n"
    "variables = x, y, z\n"
    "f(x) = f(g(x, y))\n"
    "h(x, y, z) = u(f(x))\n"
    "------------------------\n"
    "f(x) = 4*x{2}\n"
    "g(y) = 3*y\n"
    "h(x, y) = 100*xyxy + xy + 351\n"
    "c = 5\n\n"
    "Ответь только в формате TRS и интерпретации."
)
# print(context_TRS)

# for i in range(100):  # чтобы не использовать вечный цикл
n = int(input("Введите 1 для запроса теории\nВведите 2 для запроса TRS\nВведите 3 для дополнения БД\n"
              + "-" * 20 + "\nВведите номер: "))

# if n == 1:
#     # Какой подход используется для сохранения LL(k)-свойства при удалении пустых правил?
#     question = input("Введите вопрос: ")
#     context = process_questions([{"question": question, "answer": ""}], use_saved=True)
#     context = "".join(context)
#     answer = get_chat_response(question, context=context, model="mistral-large-latest")  # "mistral-large-latest"
#     print(answer)
if n == 2:
    question = input("Введите вопрос: ")

    # Получаем отфильтрованный вопрос
    refactored_question = get_chat_response(question, context=context_for_TRS,
                                            model="mistral-small-latest")
    print("Переформулированный вопрос:", refactored_question)

    print("-" * 40)
    time.sleep(1)

    # Получаем ответ на вопрос
    answer = get_chat_response(refactored_question, context=context_TRS,
                               model="mistral-large-latest")
    print(answer)

    print("-" * 40)

    # Убираем лишние символы и добавляем перенос строки
    string_to_process = answer.replace("```", "").strip() + "\n"

    # Путь к скомпилированной Go-программе
    go_program_path = "mygoprogram"

    try:
        # Запуск процесса Go программы
        process = subprocess.Popen([go_program_path], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE,
                                   text=True, encoding='utf-8')

        # Передача строки через стандартный ввод
        stdout, stderr = process.communicate(input=string_to_process)

        # Проверка на ошибки выполнения
        if process.returncode != 0:
            print(f"Ошибка выполнения Go программы: {stderr}")
        else:
            print("Результат обработки Go программы:")
            print(stdout)

    except FileNotFoundError:
        print(f"Ошибка: не могу найти Go программу по пути {go_program_path}")

    except Exception as e:
        print(f"Произошла ошибка: {str(e)}")



# elif n == 3:
#     new_question = input("Введите новый вопрос: ")
#     new_answer = input("Введите ответ: ")
#     new_questions = [{"question": new_question, "answer": new_answer}]
#     add_new_questions(new_questions, filename="vectorized_data")
else:
    print("Вы ввели неверный номер")
#теорема Майхилла-Нероде для VPL
# Правила: f(x, S(y)) = S(f(x,y)) f(x, Z) = x g(x, S(y)) = f(x, g(x,y)) g(x, Z) = Z Интерпретация: Z = 0 f(x,y) = x + 2*y g(x,y) = x*y S(x) = x + 1
# дана система переписывания термов: S→aSa S→bSb S→a S→b S→ϵ, и я интерпретирую её конструкторы такими-то функциями (main :: IO () main = do   s <- getLine   putStrLn $ show  ((isOk s) && (isOk $ reverse s))  isOk :: String -> Bool isOk [] = True isOk [x] = x == 'a' || x == 'b' isOk (x:xs)   | x == last xs = isOk (init xs) || (x == 'a' && isOk xs) || (x == 'b' && isOk xs)   | otherwise = False). Доказывает ли моя интерпретация завершаемость trs?
