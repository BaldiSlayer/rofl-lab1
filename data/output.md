# База знаний 


## Лисов Алексей

**Вопрос:** Что представляет собой язык, распознаваемый недетерминированным конечным автоматом (НКА)?

**Ответ:** Язык, распознаваемый недетерминированным конечным автоматом (НКА) – это все такие слова,  по которым существует хотя бы один путь из стартовой вершины в терминальную.


**Вопрос:** Дан регулярный язык, опиши алгоритм нахождения кратчайшего слова, принадлежащего этому регулярному языку

**Ответ:** Регулярный язык может быть задан с помощью конечного автомата.  Так как автомат конечен, то мы можем его обойти (пройти через все состояния) за конечное время.  Так как нам нужно найти самое короткое слово, то эта задача сводится к тому, что нам необходимо  найти кратчайший путь от стартовой вершины до какой-либо терминальной. По определению это  можно сделать с помощью поиска в ширину (bfs, breadth-first search). Поиск в ширину - алгоритм, находящий  все кратчайшие пути от заданной вершины в невзвешенном графе. Запускаем поиск в ширину и выйдем из него,  когда пришли в терминальное состояние. Так как нам нужно явно найти кратчайшее слово, то после этого делаем  восстановление ответа. Это можно сделать используя дополнительную структуру данных (например массив prev), для того,  чтобы для каждого состояния v хранить состояние u, из которого мы в него пришли. Мы можем пройти от найденной  вершины по массиву prev, пока не придем в начальное состояние. Записав все переходы мы получим кратчайшее слово,  принадлежащее регулярному языку.


**Вопрос:** Опиши алгоритм подсчета количества слов определенной длины в заданном регулярном языке

**Ответ:** Обозначим регулярный язык за L и пусть длина слов, количество которых мы хотим найти - l. Так как язык L регулярен, то мы можем построить соответствующий ему конечный автомат A. Решим задачу с помощью динамического программирования. Пусть a_(q,i) – количество слов длины i, переводящих  автомат A из начального состояния q0 в состояние q.  Чтобы пересчитать эту величину, нужно просуммировать значения динамического программирования из предыдущего по длине слоя для всех состояний, из которых есть ребро в состояние q. Ответом является сумма элементов столбца, отвечающего за длину l, соответствующих терминальным вершинам.


**Вопрос:** Какими являются языки недетерминированных автоматов с магазинной памятью?

**Ответ:** Языки недетерминированных автоматов с магазинной памятью являются контекстно-свободными. То есть эти языки могут быть заданы с помощью контекстно свободных грамматик.


**Вопрос:** Какая структура данных может описать магазинную память у автомата с магазинной памятью?

**Ответ:** Магазинная память у автомата с магазинной памятью является стеком.

**Вопрос:** Опиши алгоритм нахождения эпсилон замыкания для каждой из вершин автомата?

**Ответ:** ε-замыкание состояния q – это множество состояний, достижимых из q только по ε-переходам.  Соотсветственно эпсилон замыкание для каждой из вершин автомата можно предподсчитать с помощью поиска в глубину  (dfs) для каждой вершины.


**Вопрос:** Дай определение произведения двух автоматов

**Ответ:** Прямым произведением двух ДКА A1=⟨Σ1,Q1,s1,T1,δ1⟩ и A2=⟨Σ2,Q2,s2,T2,δ2⟩ называется ДКА  A=⟨Σ,Q,s,T,δ⟩, где:  1) Σ = Σ1∪Σ2, то есть он работает над пересечением алфавитов двух данных автоматов  2) Q = Q1×Q2, множество пар состояниий включает в себя состояния обоих автоматов  3) s =⟨s1,s2), стартуем с символов в обоих автоматах  4) T=T1×T2, терминальные состояния включают в себя терминальные состояния обоих автоматов  5) δ(⟨q1,q2⟩,c)=⟨δ1(q1,c),δ2(q2,c)⟩, то есть переходим по символу в обоих автоматах"


**Вопрос:** Как из недетерминированного конечного автомата A сделать pushdown automat B?

**Ответ:** Для этого нужно заменить переход из состояния q в состояние p по символу x на такой же переход,  только добавить z_0/z_0, где z_0 это дно стека. Из этого следует, что регулярные языки являются подмножеством  МП-автоматных языков (языков автоматов с магазинной памятью).


**Вопрос:** Теорема Клини (англ. Kleene's theorem)

**Ответ:** Теорема Клини (англ. Kleene's theorem) гласит о том, что множество языков, принимаемых детерминированным конечным автоматом совпадает с  множеством языком, принимаемых академическим регулярным выражением.


**Вопрос:** Какой язык называется префиксным (беспрефиксным)

**Ответ:** Язык L называется префиксным, если для любого слова w не равного слову v из L не верно, что w – префикс v.  Также такие языки называют беспрефиксными.


**Вопрос:** Что можно сказать о языке L, который принимается детерминированным конечным автоматом  с магазинной памятью по пустому стеку


**Ответ:** Это значит, что язык L принимается детерминированным конечным автоматом с магазинной памятью по терминальному  состоянию, а также язык L – префиксный (то есть если для любого w не равного v из языка L не верно, что w – префикс v).


**Вопрос:** Является ли регулярным язык Дика (англ. Dyck's language) с единственным типом скобок? (язык Дика - множество правильных скобочных структур вместе с пустой структурой,  образующее язык над алфавитом {a,b}.)


**Ответ:** Язык Дика (англ. Dyck's language) не является регулярным. Докажем с помощью леммы о накачке. Предположим, что он регулярный, тогда по лемме о накачке существует  n, являющееся длиной накачки. Возьмём последовательность из n открывающих, а затем n закрывающих скобок.  Для неё существуют соответствующие x, y, z из леммы о накачке. Но так как |xy| <= n, то y  состоит только из открывающих скобок, причём по условию леммы y не пустая. А значит при i = 2 в строке xy^iz  получится больше открывающих скобок, чем закрывающих, то есть это будет не правильной скобочной последовательностью.  Получили противоречие. Следовательно язык Дика с единственным типом скобок не является регулярным.


**Вопрос:** Является ли контекстно-свободным языком разность контекстно-свободного и регулярного языка?


**Ответ:** Да, разность контекстно-свободного и регулярного языка является контекстно-свободным языком.



---

## Дмитрий Теньшов

**Вопрос:** Что такое переход машины Тьюринга?


**Ответ:** Переход машины Тьюринга — это функция, зависящая от состояния конечного управления и обозреваемого символа.  За один переход машина Тьюринга должна выполнить следующие действия: изменить состояние,  записать ленточный символ в обозреваемую клетку, сдвинуть головку влево или вправо.


**Вопрос:** Какие языки допускаются при помощи машины Тьюринга?


**Ответ:** Языки, допустимые с помощью машины Тьюринга, называются рекурсивно перечислимыми, или РП-языками.


**Вопрос:** Опишите прием «память в состоянии» машины Тьюринга.


**Ответ:** Память в состоянии — конечное управление можно использовать не только для представления позиции в «Программе» машины Тьюринга,  но и для хранения конечного объема данных.


**Вопрос:** Опишите прием «Подпрограммы» машины Тьюринга.


**Ответ:** Подпрограмма машины Тьюринга представляет собой множество состояний, выполняющее некоторый полезный процесс.  Это множество включает в себя стартовое состояние и еще одно состояние,  которое не имеет переходов и служит состоянием «возврата» для передачи управления какому-либо множеству состояний,  вызвавшему данную подпрограмму. «Вызов» подпрограммы возникает везде, где есть переход в ее начальное состояние.


**Вопрос:** Можно ли запомнить позицию ленточной головки в позиции управления у машины Тьюринга?


**Ответ:** Хотя позиции конечны в каждый момент времени, всё множество позиций может быть и бесконечным.  Если состояние должно представлять любую позицию головки, то в состоянии должен быть компонент данных,  имеющий любое целое в качестве значения. Из-за этого компонента множество состояний должно быть бесконечным,  даже если только конечное число состояний используется в любой конечный момент времени. Определение же машин Тьюринга требует,  чтобы множество состояний было конечным. Таким образом, запомнить позицию ленточной головки в конечном управлении нельзя.


**Вопрос:** Что такое счетчиковая машина?


**Ответ:** Счетчиковые машины — это класс машин, обладающий возможностью запоминать конечное число целых чисел (счетчиков)  и совершать различные переходы в зависимости от того, какие из счетчиков равны 0 (если таковые вообще есть).  Счетчиковая машина может только прибавить 1 к счетчику или вычесть 1 из него,  но отличить значения двух различных ненулевых счетчиков она не способна.


**Вопрос:** Какой язык допускается счетчиковой машиной?


**Ответ:** Каждый язык, допускаемый счетчиковой машиной, рекурсивно перечислим. Причина в том,  что счетчиковые машины являются частным случаем магазинных, а магазинные — частным случаем многоленточных машин Тьюринга,  которые по теореме допускают только рекурсивно перечислимые языки.


**Вопрос:** Допускается ли любой рекурсивно перечислимый язык двухсчетчиковой машиной?


**Ответ:** Для имитации машины Тьюринга и, следовательно, для допускания любого рекурсивно перечислимого языка, достаточно двух счетчиков.  Для обоснования этого утверждения вначале доказывается, что достаточно трех счетчиков,  а затем три счетчика имитируются с помощью двух.


**Вопрос:** Что такое универсальная машина Тьюринга?


**Ответ:** Универсальной машиной Тьюринга называют машину Тьюринга, которая может заменить собой любую машину Тьюринга.  Получив на вход программу и входные данные, она вычисляет ответ, который вычислила бы по входным данным машина Тьюринга,  чья программа была дана на вход.


**Вопрос:** Какое время необходимо многоленточной машине Тьюринга для имитации шагов компьютера?


**Ответ:** Рассмотрим компьютер, обладающий следующими свойствами: у него есть только инструкции,  увеличивающие максимальную длину слова не более чем на один; у него есть только инструкции,  которые многоленточная машина Тьюринга может выполнить на словах длиной k за O(k^2) или меньшее число шагов.  Шаг — это выполнение одной инструкции. Таким образом, выполнение n шагов работы компьютера можно проимитировать  на многоленточной машине Тьюринга с использованием не более O(n^3) шагов.


**Вопрос:** Как связаны мощности следующих машин Тьюринга: многодорожечная машина Тьюринга,  машина Тьюринга с односторонней лентой, многоленточная машина Тьюринга, недетерминированная машина Тьюринга?


**Ответ:** Многодорожечная машина Тьюринга, машина Тьюринга с односторонней лентой, многоленточная машина Тьюринга  и недетерминированная машина Тьюринга, несмотря на различия в их конструкции или правилах работы,  обладают одинаковой вычислительной мощностью, то есть способны вычислить одни и те же классы функций.  Различия между видами машин Тьюринга (например, между машинами с одним или несколькими лентами)  могут повлиять на эффективность вычислений (время или пространство), но не на саму вычислительную мощность.


**Вопрос:** Если проблема P1 неразрешима и ее можно свести к проблеме P2, то является ли проблема P2 неразрешимой?


**Ответ:** Если проблему P1 можно свести к проблеме P2 и если P1 неразрешима, то и P2 неразрешима.


**Вопрос:** Что такое рандомизированная машина Тьюринга?


**Ответ:** Рандомизированная машина Тьюринга — это вариант многоленточной машины Тьюринга. Первая лента,  как обычно для многоленточных машин, содержит вход. Вторая лента также начинается непустыми клетками.  В принципе, вся она содержит символы 0 и 1, выбранные с вероятностью 1/2. Вторая лента называется случайной лентой.  Третья и последующие, если используются, вначале пусты и при необходимости выступают как рабочие.



---

## Филимонов Михаил

**Вопрос:** Рекурсивные языки.

**Ответ:** Языки, допускаемые машинами Тьюринга, называются рекурсивно-перечислимыми (РП), а РП-языки, допускаемые МТ, которые всегда останавливаются, — рекурсивными. “Разрешимость” есть  синоним “рекурсивности”, однако языки чаще называются “рекурсивными”, а проблемы (которые  представляют собой языки, интерпретируемые как вопросы) — “разрешимыми”.  Если язык не является рекурсивным, то проблема, которую выражает этот язык, называется “неразрешимой”. Рекурсивный язык позволяет построить разрешающую функцию: т.е. МТ, возвращающую один из двух результатов (да-нет), и корректно завершающую работу.


**Вопрос:** Рекурсивно-перечислимые языки. Примеры языков, которые являются рекурсивно-перечислимыми, но не рекурсивными.

**Ответ:** Язык L является рекурсивно-перечислимым (РП-языком), если L = L(M) для некоторой машины Тьюринга M. Проблема останова машины Тьюринга является РП, но не рекурсивной. В действительности, определенная А. М. Тьюрингом  машина допускала, не попадая в допускающее состояние, а останавливаясь. Для МТ  M можно определить H(M) как множество входов w, на которых M останавливается  независимо от того, допускает ли M вход w. Тогда проблема останова состоит в опре  делении множества таких пар (M, w), у которых w принадлежит H(M). Это еще один  пример проблемы/языка, которая является РП, но не рекурсивной.


**Вопрос:** Что такое язык диагонализации L_d

**Ответ:** Язык диагонализации L_d — это множество всех цепочек w_i, не принадлежащих L(M_i). Понятие M_i, “i-й машины Тьюринга”. Это машина Тьюринга M, кодом которой является i-я двоичная цепочка w_i. В язык L_d  входит каждая цепочка в алфавите {0, 1}, которая, будучи проинтерпретированной как код МТ, не принадлежит языку этой МТ. Язык L_d является хорошим примером не РП-языка, т.е. его не допускает ни одна машина Тьюринга.


**Вопрос:** Является ли язык L_d рекурсивно-перечислимым

**Ответ:** Язык L_d не является рекурсивно-перечислимым, т.е. не существует машины Тьюринга, которая допускала бы L_d. Доказательство. Допустим, что L_d = L(M) для некоторой МТ M. Так как L_d — язык над алфавитом {0, 1}, M должна содержаться в построенной нами последовательности машин Тьюринга, поскольку эта последовательность содержит все МТ с входным алфавитом {0, 1}. Следовательно, в ней есть, по крайней мере, один код машины M, скажем, i, т.е. M = M_i. Понятие M_i, “i-й машины Тьюринга”. Это МТ M, кодом которой является i-я двоичная цепочка w_i. Выясним теперь, принадлежит ли w_i языку L_d. Если w_i принадлежит L_d, то M_i допускает w_i. Но тогда (по определению L_d) w_i не принадлежит L_d, так как L_d содержит лишь такие w_j, для которых M_j не допускает w_j. Точно так же, если w_i не принадлежит L_d, то M_i не допускает w_i. Но тогда (по определению L_d) w_i принадлежит L_d. Поскольку w_i не может одновременно и принадлежать, и не принадлежать L_d, приходим к противоречию с нашим предположением о том, что M существует. Таким образом, L_d не является рекурсивно-перечислимым языком.


**Вопрос:** Почему языки 'рекурсивные'?

**Ответ:** Рекурсивные функции были введены в 30-х годах XX века С. К. Клини.  Это название закрепилось за одним из наиболее распространённых вариантов  уточнения общего понятия арифметического алгоритма, то есть такого алгоритма,  допустимые исходные данные которого представляют собой системы натуральных чисел,  а возможные результаты применения — натуральные числа. Языки называются рекурсивными, если они являются рекурсивным подмножеством набора всех  возможных конечных последовательностей по алфавиту языка. Тезис Чёрча — Тьюринга: любая функция,  которая может быть вычислена физическим устройством, может быть вычислена машиной Тьюринга. То есть рекурсивные функции вычисляют те же классы алгоритмов, что и машины Тьюринга. Эквивалентно, формальный язык  является рекурсивным, если существует машина Тьюринга, которая при вводе конечной  последовательности символов всегда останавливается и принимает её, если она  принадлежит языку, и останавливается и отвергает её в противном случае.


**Вопрос:** Почему универсальный язык L_u является рекурсивно-перечислимым, но не рекурсивным.


**Ответ:** Язык L_u состоит из цепочек, интерпретируемых как код МТ, к которому дописан ее вход. Цепочка принадлежит L_u, если эта МТ до пускает данный вход. Язык L_u является рекурсивно-перечислимым. Допустим, что L_u рекурсивен. Тогда по теореме дополнение L_u (дополнение L_u)  также рекурсивный язык. Но если существует МТ M, допускающая L_u, то, используя описанный ниже метод,  можно построить МТ, допускающую L_d. Язык диагонализации L_d — это множество всех цепочек w_i, не принадлежащих L(M_i). Понятие M_i, “i-й машины Тьюринга”. Это МТ M, кодом которой является i-я двоичная цепочка w_i. В язык L_d  входит каждая цепочка в алфавите {0, 1}, которая, будучи проинтерпретированной как код МТ, не принадлежит языку этой МТ. Поскольку нам известно, что L_d не является РП, приходим к  противоречию с предположением, что язык L_u является рекурсивным. Предположим, что L(M) = L_u. Можно  преобразовать МТ M в МТ M', которая допускает L_d с помощью следующих действий: 1. M' преобразует  входную цепочку w в w111w. Легче это сделать, используя для копии w вторую ленту, и затем  преобразовать двухленточную МТ в одноленточную. 2. M' имитирует M на новом входе. Если w есть w_i  в нашем перечислении, то M' определяет, допускает ли M_i вход w_i. Поскольку M допускает L_u, то она  допускает тогда и только тогда, когда M_i не допускает w_i, т.е. когда w_i принадлежит L_d. Таким образом,  M' допускает w тогда и только тогда, когда w принадлежит L_d. Поскольку по теореме машины M' не существует,  приходим к выводу, что язык L_u не является рекурсивным.


**Вопрос:** Является ли язык, состоящий из кодов всех машин Тьюринга,  которые допускают хотя бы одну цепочку, L_ne рекурсивно-перечислимым/рекурсивным?


**Ответ:** L_ne – непустой язык состоит из кодов всех машин Тьюринга, которые допускают хотя бы одну цепочку.  Он рекурсивно-перечислим, но не рекурсивный. Чтобы доказать РП, достаточно предъявить МТ, допускающую L_ne.  Проще всего это сделать, описав недетерминированную МТ M. Работа M заключается в следующем: 1. На вход M подается  код МТ M_i. 2. Используя недетерминизм, M угадывает вход w, который, возможно, допускается M_i.  3. M проверяет, допускает ли M_i свой вход w. В этой части M может моделировать работу универсальной МТ U,  допускающей L_u (язык L_u состоит из цепочек, интерпретируемых как код МТ, к которому дописан ее вход. Цепочка принадлежит L_u, если эта МТ до пускает данный вход). 4. Если M_i допускает w, то и M допускает свой вход, т.е. M_i. Понятие M_i, “i-й машины  Тьюринга”. Это МТ M, кодом которой является i-я двоичная цепочка w_i. В этот язык входит каждая цепочка  в алфавите {0, 1}, которая, будучи проинтерпретированной как код МТ, не принадлежит языку этой МТ.  Таким образом, если M_i допускает хотя бы одну цепочку, то M угадает ее (среди прочих, конечно) и допустит M_i.  Если же L(M_i) = ∅, то ни одна из угаданных w не допускается M_i, и M не допустит M_i. Таким образом, L(M) = L_ne.


**Вопрос:** Является ли язык L_e, состоящий из кодов всех МТ, языки которых пусты, рекурсивно-перечислимым/рекурсивным?


**Ответ:** L_e – пустой язык состоит из кодов всех МТ, языки которых пусты. Он не рекурсивно-перечислим.


**Вопрос:** Теорема Райса


**Ответ:** Свойство называется тривиальным, если оно либо пустое (т.е. никакой язык вообще ему не удовлетворяет), либо содержит все РП-языки (рекурсивно-перечислимые). В противном случае свойство назы вается нетривиальным.  Теорема Райса: Всякое нетривиальное свойство языков, допускаемых МТ, является неразрешимым. Например, множество кодов  машин Тьюринга, допускающих пустой язык, согласно теореме Райса является неразрешимым. В действительности  этот язык не является РП, хотя его дополнение — множество кодов МТ, допускающих хотя бы одну цепочку, —  является РП, но не рекурсивным.


**Вопрос:** Существует ли такой вход для заданной машины Тьюринга,  при обработке которого машина выполняет более пяти переходов,  прежде чем достигнет состояния останова (либо завершится, либо зациклится)?


**Ответ:** Алгоритм решения становится очевидным, если заметить, что, когда МТ делает пять переходов,  она обозревает не более девяти клеток вокруг начальной позиции головки. Поэтому можно проимитировать  пять переходов МТ на любом из конечного числа входов, длина которых не более девяти. Если все эти  имитации не достигают останова, то делается вывод, что на любом входе данная МТ совершает более пяти переходов.


**Вопрос:** Что такое проблема соответствий Поста.


**Ответ:** Экземпляр проблемы соответствий Поста (ПСП) состоит из двух списков равной длины в некотором алфавите Σ.  Как правило, мы будем называть их списками A и B, и писать A = w_1, w_2, …, w_k и B = x_1, x_2, …, x_k при  некотором целом k. Для каждого i пара (w_i, x_i) называется парой соответствующих цепочек. Мы говорим, что  экземпляр ПСП имеет решение, если существует последовательность из одного или нескольких целых чисел  i_1, i_2, …, i_m, которая, если считать эти числа индексами цепочек и выбрать соответствующие цепочки из  списков A и B, дает одну и ту же цепочку, т.е. w_i_1w_i_2…w_i_m = x_i_1xi_2…x_i_m. В таком случае последовательность  i_1, i_2, …, i_m называется решающей последовательностью, или просто решением, данного экземпляра ПСП.


**Вопрос:** Что такое модифицированная проблема соответствий Поста.


**Ответ:** Модифицированной проблемой соответствий Поста, или МПСП.  В модифицированной ПСП на решение накладывается дополнительное требование,  чтобы первой парой в решении была пара первых элементов списков A и B.  Более формально, экземпляр МПСП состоит из двух списков A = w_1, w_2, …, w_k  и B = x_1, x_2, …, x_k, и решением является последовательность из 0 или  нескольких целых чисел i_1, i_2, …, i_m, при которой  w_1w_i_1w_i_2…w_i_m = x_1x_i_1x_i_2…x_i_m. Отметим, что цепочки обязательно начинаются парой (w_1, x_1),  хотя индекс 1 даже не указан в качестве начального элемента решения. Кроме того, в отличие от ПСП,  решение которой содержит хотя бы один элемент, решением МПСП может быть и пустая последовательность (когда w_1 = x_1).


**Вопрос:** Разрешима ли ПСП/проблема соответствий Поста


**Ответ:** Заданы два списка, содержащие одинаковое количество цепочек.  Спрашивается, можно ли, выбирая последовательности соответствующих  цепочек из этих двух списков, построить путем их конкатенации одну  и ту же цепочку. ПСП является важным примером неразрешимой проблемы.  Сводимость ПСП к ряду других проблем обеспечивает доказательство их неразрешимости


**Вопрос:** Разрешим ли вопрос о неоднозначности КС-грамматики (контекстно-свободной грамматики)


**Ответ:** Вопрос о неоднозначности КС-грамматики (контекстно-свободной грамматики) неразрешим.  Неразрешимые проблемы, связанные с контекстно-свободными языками.  Посредством сведения ПСП(проблема соответствий Поста) к вопросу об определении некоторых свойств КС-грамматики можно доказать неразрешимость многих вопросов  о КС-языках или их грамматиках. В силу неразрешимости ПСП это сведение доказывает неразрешимость про блемы неоднозначности КС-грамматики.  Так же, например, о включении одного КС-языка в  другой или о пустоте пересечения двух КС-языков."



---

## Захарин Сергей

**Вопрос:** Что называется нейтральным элементом операции в регулярных выражениях?


**Ответ:** Нейтральный (единичный) элемент в контексте операций в регулярных выражениях — это элемент, для которого верно: если данная операция применяется к единичному элементу и некоторому выражению, то результат равен этому выражению. Для регулярных выражений нейтральные элементы зависят от конкретного типа операции: 1. Конкатенация: Нейтральным элементом для конкатенации является пустая строка (обозначается ε). При конкатенации любой строки с ε результат остается неизменным. 2. Объединение (дизъюнкция): Для операции объединения нейтральным элементом является пустое множество (обозначается ∅). Объединение любого выражения с ∅ не изменяет его.


**Вопрос:** Что называется нулевым элементом (аннулятором) операции в регулярных выражениях?


**Ответ:** Нулевой элемент (или аннулятор) в контексте операций в регулярных выражениях — это элемент, который при применении операции с другим выражением всегда возвращает сам нулевой элемент. В алгебре нулевой элемент обнуляет результат операции, независимо от второго аргумента. В контексте регулярных выражений это понятие также применимо, и оно зависит от типа операции: 1. Конкатенация: Для конкатенации нулевым элементом является пустое множество (обозначаемое ∅). При конкатенации любого выражения с ∅ результатом всегда будет ∅. 2. Объединение (дизъюнкция): Для операции объединения (дизъюнкции) нулевого элемента как такового не существует. Объединение с ∅ даёт исходное выражение, а не ∅, то есть ∅ здесь является нейтральным, а не нулевым элементом.


**Вопрос:** В каком случае два регулярных выражения с переменными являются эквивалентными?


**Ответ:** Два выражения с переменными являются эквивалентными, если при подстановке любых языков вместо переменных оба выражения представляют один и тот же язык.


**Вопрос:** Какие операторы регулярных выражений ассоциативны? Коммутативны? Дистрибутивны? Идемпотентны?


**Ответ:** Объединение и конкатенация ассоциативны. Коммутативно только объединение. Конкатенация дистрибутивна относительно объединения. Объединение идемпотентно.


**Вопрос:** Закон идемпотентности операции объединения для регулярных выражений


**Ответ:** Закон идемпотентности операции объединения утверждает, что объединение двух одинаковых выражений можно заменить одним таким выражением.


**Вопрос:** Что такое обращение строки в формальных языках?


**Ответ:** Строку также часто называют словом. Обращением строки (a_1)(a_2)...(a_n) называется строка, записанная в обратном порядке, т.е. (a_n)(a_n-1)...(a_1). Обращение w обозначается w^R. Таким образом, например, (0010)^R есть 0100, а ε^R = ε.


**Вопрос:** Что такое обращение языка L?


**Ответ:** Обращение языка L, обозначаемое L^R, состоит из всех строк, являющихся реверсами (обращениями) строк из исходного языка L. То есть, если L — это язык, состоящий из строк w_1, w_2, ..., w_n, то обращение этого языка L^R включает строки, полученные путём инвертирования каждой из строк языка L. Например, если L = {001, 10, 111}, то L^R = {100, 01, 111}.


**Вопрос:** Что такое гомоморфизм строк в регулярных языках?


**Ответ:** Строку также часто называют словом. Гомоморфизм строк — это такая функция на множестве строк, являющаяся расширением функции отображения символов алфавита в строки относительно операции конкатенации.


**Вопрос:** Как рекурсивно определяется регулярное выражение?


**Ответ:** Регулярное выражение над алфавитом Σ = {c_1, c_2, …, c_k} — способ порождения языка над Σ. Определяется рекурсивно следующим образом: Для любого i слово c_i является регулярным выражением, задающим язык из одного слова ci. ε является регулярным выражением, задающим язык из одной пустой строки, а ∅ — пустой язык. Если a_1 и a_2 являются регулярными выражениями, задающими языки L_1 и L_2 соответственно, то (a_1)|(a_2) — регулярное выражение, задающее L_1 ⋃ L_2. Если a_1 и a_2 являются регулярными выражениями, задающими языки L_1 и L_2 соответственно, то (a_1)(a_2) — регулярное выражение, задающее L_1L_2. Если a_1 является регулярным выражением, задающим язык L_1, то (a_1)* — регулярное выражение, задающее (L_1)*.


**Вопрос:** Что такое замыкание Клини и где оно используется в регулярных выражениях?


**Ответ:** Итерация (“звездочка”, или замыкание Клини) языка L обозначается L* и представляет собой множество всех тех цепочек, которые можно образовать путем конкатенации любого количества цепочек из L. При этом допускаются повторения, т.е. одна и та же цепочка из L может быть выбрана для конкатенации более одного раза. Например, если L = {0, 1}, то L* — это все цепочки, состоящие из нулей и единиц. Если L = {0, 11}, то в L* входят цепочки из нулей и единиц, содержащие четное количество единиц, например, цепочки 011, 11110 или ε, и не входят цепочки 01011 или 101. Более формально язык L* можно представить как бесконечное объединение L^i, где L^0 = ε, L^1 = L и Li для i>1 равен LL...L(конкатенация i копий L).


**Вопрос:** Лемма о разрастании для контекстно-свободных языков


**Ответ:** Также называется леммой о накачке для контекстно-свободных языков. Пусть L — контекстно-свободный язык над алфавитом Σ, тогда существует такое натуральное n, что для любого слова ω, принадлежащего L, длины не меньше n найдутся слова u, v, x, y, z, принадлежащие Σ*, для которых верно: uvxyz = ω, vy ≠ ε, |vxy| <= n и ∀k >= 0 u(v^k)x(y^k)z ∈ L. Иначе говоря, любую достаточно длинную цепочку в КС-языке можно разбить на пять частей так, что повторение второй и четвёртой частей произвольное количество раз (возможно, 0) не приведут к выходу за пределы языка.


**Вопрос:** Относительно каких операций замкнуты регулярные языки?


**Ответ:** Регулярные языки замкнуты относительно следующих операций: 1. Объединение 2. Пересечение 3. Дополнение 4. Разность 5. Обращение 6. Итерация (звездочка) 7. Конкатенация 8. Гомоморфизм (подстановка цепочек вместо символов языка) 9. Обратный гомоморфизм.


**Вопрос:** Законы регулярных выражений, связанные с единичным элементом и нулевым элементом


**Ответ:** Для регулярных выражений существует три закона, связанных с этими понятиями. • ∅ + L = L + ∅ = L. Этот закон утверждает, что ∅ является единицей объединения. • εL = Lε = L. Этот закон гласит, что ε является единицей конкатенации. • ∅L = L∅ = ∅. Этот закон утверждает, что ∅ является нулевым элементом конкатенации.



---

## Пишикина Мария

**Вопрос:** Какие существуют приемы интерпретации ленты и конечного управления машины Тьюринга?


**Ответ:** Существует три приема интерпретации ленты и конечного управления машины Тьюринга: память в состоянии, многодорожечные ленты, подпрограммы.


**Вопрос:** Опишите прием «Многодорожечные ленты» в машине Тьюринга.


**Ответ:** При использовании приема «Многодорожечные ленты» рассматривается лента машины Тьюринга, образованная несколькими дорожками.  Каждая дорожка может хранить один символ (в одной клетке), и алфавит машины Тьюринга состоит из кортежей, с одним компонентом для каждой «дорожки».


**Вопрос:** Существуют ли не рекурсивно перечислимые языки, допускаемые многоленточными машинами Тьюринга?


**Ответ:** Каждый язык, допускаемый многоленточной машиной Тьюринга, рекурсивно перечислим.


**Вопрос:** Какое время необходимо одноленточной машине Тьюринга для имитации переходов многоленточной машины Тьюринга?


**Ответ:** Время, необходимое одноленточной машине Тьюринга для имитации n переходов многоленточной машины Тьюринга, есть O(n^2).


**Вопрос:** Что такое «мультистековая (многомагазинная) машина»?


**Ответ:** Мультистековая (многомагазинная) машина представляет собой детерминированный МП-автомат (или машина с магазинной памятью) с несколькими магазинами. Он получает свои входные данные, как и МП-автомат, из некоторого их источника,  а не с ленты или из магазина, как машина Тьюринга. Мультистековая машина имеет конечное управление, то есть конечное множество состояний, и конечный магазинный алфавит, используемый для всех магазинов.  Переход мультистековой машины основывается на состоянии, входном символе и верхних символах всех магазинов.


**Вопрос:** Как называется язык, который допускается односчетчиковой машиной?


**Ответ:** «Односчетчиковые машины» — это класс машин, которые могут запоминать значение одного целого числа («счетчика») и совершать различные переходы в зависимости от того, равен ли счетчик 0.  Односчетчиковая машина может только прибавить 1 к счетчику или вычесть 1 из него, но не способна различать различные ненулевые значения счетчика. Каждый язык, допускаемый односчетчиковой машиной, является КС-языком. Контекстно-свободный (КС) язык — это язык, задаваемый контекстно-свободной грамматикой.  Контекстно-свободной грамматикой называется грамматика, у которой в левых частях всех правил стоят только одиночные нетерминалы.


**Вопрос:** Можно ли имитировать машину Тьюринга на компьютере?

**Ответ:** Имитация машины Тьюринга на компьютере в принципе возможна, если допустить, что для имитации значащей части ленты существует потенциально бесконечный запас сменных запоминающих устройств вроде диска.  Поскольку физические ресурсы, необходимые для создания дисков, конечны, данный довод сомнителен. Однако, поскольку пределы памяти Вселенной неизвестны или, без сомнения, обширны,  предположение о бесконечности ресурсов (как для ленты машины Тьюринга) является практически реалистичным и в целом допустимо.


**Вопрос:** Какое время необходимо одноленточной машине Тьюринга для имитации переходов компьютера?


**Ответ:** Машина Тьюринга может имитировать n шагов компьютера за O(n^6) своих шагов.


**Вопрос:** Почему язык, допускающийся в недетерминированных машинах Тьюринга, также допускается и обычной детерминированной машиной Тьюринга?


**Ответ:** Несмотря на кажущуюся большую мощность недетерминированных машин в связи с тем, что они выполняют несколько возможных вычислений сразу  (требуя только, чтобы хоть одно из них заканчивалось в допускающем состоянии), любой язык, допускающийся недетерминированной машиной Тьюринга,  также допускается и обычной детерминированной машиной Тьюринга, поскольку она может моделировать любой недетерминированный переход, делая многократные копии состояния, если встречается неоднозначность.


**Вопрос:** Как машина Тьюринга имитирует реальный компьютер?


**Ответ:** Машина Тьюринга может имитировать память и управление реального компьютера путем использования одной ленты для записи всех элементов памяти и их содержимого — регистров, основной памяти, дисков и других запоминающих устройств.  Таким образом, можно быть уверенным, что все, не выполнимое машиной Тьюринга, не может быть сделано и компьютером.


**Вопрос:** Какая проблема может возникнуть при допуске языка в рандомизированную машину Тьюринга?


**Ответ:** Имея дело с рандомизированными машинами Тьюринга, нужно быть более аккуратным с тем, что значит допускание входа такой машиной; становится возможным, что машина Тьюринга не определяет функции математически корректно (т.е. независимо от рандомизированных данных).  Проблема в том, что при анализе действий рандомизированной машины Тьюринга со входом приходится рассматривать все возможные случайные последовательности на второй ленте. Вполне возможно, что машина Тьюринга  допускает при одних случайных последовательностях, но отвергает при других; в действительности, если рандомизированная машина Тьюринга должна делать что-то более эффективно, чем детерминированная машина Тьюринга,  то существенно, чтобы различные последовательности на рандомизированной ленте приводили к различному поведению.


**Вопрос:** Перечисли возможные операции над машинами Тьюринга.


**Ответ:** 1) Композиция (суперпозиция) машин Тьюринга - пусть две машины Тьюринга X и Y вычисляют функции f(P) и g(P) соответственно, тогда можно построить машину Тьюринга T = Y(X), вычисляющую суперпозицию функций g(f(P)).  2) Разветвление машин Тьюринга - пусть две машины Тьюринга X и Y вычисляют функции f(P) и g(P) соответственно, причём множеством значений функции f(P) является множество {0, 1}, тогда можно построить машину Тьюринга T = X->Y,  которая перерабатывает слово P в g(P), если f(P)=1 и оставляет его без изменений если f(P)=0.  3) Цикл машин Тьюринга - пусть две машины Тьюринга X и Y вычисляют функции f(P) и g(P) соответственно, причём множеством значений функции f(P) является множество {0, 1}, тогда можно построить машину Тьюринга T = X∘Y, которая  выполняет следующую последовательность действий: 
  1 - вычисляет f(P) и если f(P)=1, то вычисляет новое значение P=g(P), а если f(P)=0, то переходит к заключительному состоянию с выходным словом P; 
  2 - повторяет действие 1 до тех пор пока для очередного значения P не будет выполнено f(P)=0.


**Вопрос:** Что такое самоприменимая машина Тьюринга?


**Ответ:** Машина Тьюринга называется самоприменимой, если она останавливается, когда в качестве входного слова для неё используется описание самой машины.



---

## Якубов Павел


**Вопрос:** Что такое существенно неоднозначный контекстно-свободный язык?


**Ответ:** Контекстно-свободный язык L называется существенно неоднозначным, если все его грамматики неоднозначны. Если хотя бы одна грамматика языка L однозначна, то L является однозначным языком.


**Вопрос:** Что такое полезный символ в грамматике Γ = ⟨N, Σ, P, S⟩?


**Ответ:** Символ X называется полезным в грамматике Γ = ⟨N, Σ, P, S⟩, если существует некоторое порождение вида S ⇒* αXβ ⇒* w, где w ∈ T*. Отметим, что X может быть как переменной, так и терминалом, а выводимая цепочка αXβ — первой или последней в порождении. Если символ X не является полезным, то называется бесполезным. Очевидно, что исключение бесполезных символов из грамматики не изменяет порождаемого языка, поэтому все бесполезные символы можно обнаружить и удалить.


**Вопрос:** Пусть Γ = ⟨N, Σ, P, S⟩ — КС-грамматика. Опиши алгоритм нахождения всех ε-порождающих символов G.


**Ответ:** Все ε-порождающие символы G можно найти с помощью следующего алгоритма. 1. Найти все ε-правила. Составить множество, состоящее из нетерминалов, входящих в левые части таких правил. 2. Перебираем правила грамматики Γ. Если найдено правило A→C_1C_2...C_k, для которого верно, что каждый C_i принадлежит множеству, то добавить A в множество. 3. Если на шаге 2 множество изменилось, то повторить шаг 2. Докажем корректность алгоритма. Для доказательства корректности алгоритма достаточно показать, что, если множество ε-порождающих нетерминалов на очередной итерации алгоритма не изменялось, то алгоритм нашел все ε-порождающие нетерминалы. Пусть после завершения алгоритма существуют нетерминалы такие, что они являются ε-порождающими, но не были найдены алгоритмом. Выберем из этих нетерминалов нетерминал B, из которого выводится ε за наименьшее число шагов. Тогда в грамматике есть правило B→C_1C_2...C_k, где каждый нетерминал C_i — ε-порождающий. Каждый C_i входит в множество ε-порождающих нетерминалов, так как иначе вместо B необходимо было взять C_i. Следовательно, на одной из итераций алгоритма B уже добавился в множество ε-порождающих нетерминалов. Противоречие. Следовательно, алгоритм находит все ε-порождающие нетерминалы.


**Вопрос:** Список наиболее значительных неразрешимых вопросов о контекстно-свободных грамматиках и языках


**Ответ:** 1. Неоднозначна ли данная КС-грамматика G? 2. Является ли данный КС-язык существенно неоднозначным? 3. Пусто ли пересечение двух КС-языков? 4. Равны ли два данных КС-языка? 5. Равен ли Σ* данный КС-язык, где Σ — алфавит этого языка? Отметим, что вопрос 1 о неоднозначности отличается от остальных тем, что это вопрос о грамматике, а не о языке. Все остальные вопросы предполагают, что язык представлен грамматикой или МП-автоматом, но это все равно вопросы о языке (или языках). Например, в противоположность вопросу 1 вопрос 2 требует по данной грамматике G (или МП-автомату) определить, существует ли некоторая эквивалентная ей однозначная грамматика G′. Если G сама по себе однозначна, то ответом, безусловно, будет “да”, но если G неоднозначна, то для языка грамматики G может существовать другая грамматика G′, которая однозначна.


**Вопрос:** Замкнуты ли контекстно-свободные языки относительно операции 'пересечение с регулярным языком'?


**Ответ:** Если L — КС-язык, а R — регулярный язык, то L ∩ R является КС-языком. Доказательство: Построим МП-автомат для пересечения регулярного языка и КС-языка. Пусть регулярный язык задан своим ДКА, а КС-язык — своим МП-автоматом c допуском по допускающему состоянию. Построим прямое произведение этих автоматов так же, как строилось прямое произведение для двух ДКА. Более формально, пусть R — регулярный язык, заданный своим ДКА ⟨Σ, Q_1, s_1, T_1, δ_1⟩, и L — КС-язык, заданный своим МП-автоматом: ⟨Σ, Γ, Q_2, s_2, T_2, z_0, δ_2⟩. Тогда прямым произведением назовем следующий автомат: Q={⟨q_1, q_2⟩ | q_1 ∈ Q_1, q_2 ∈ Q_2}. Иначе говоря, состояние в новом автомате — пара из состояния первого автомата и состояния второго автомата. s=⟨s_1, s_2⟩ Стековый алфавит Γ остается неизменным. T={⟨t_1, t_2⟩ ∣ t_1 ∈ T_1, t_2 ∈ T_2}. Допускающие состояния нового автомата — пары состояний, где оба состояния были допускающими в своем автомате. δ(⟨q_1, q_2⟩, c, d)=⟨δ_1(q_1, c), δ_2(q_2, c, d)⟩. При этом на стек кладется то, что положил бы изначальный МП-автомат при совершении перехода из состояния q_2, видя на ленте символ c и символ d на вершине стека. Этот автомат использует в качестве состояний пары из двух состояний каждого автомата, а за операции со стеком отвечает только МП-автомат. Слово допускается этим автоматом ⟺ слово допускается и ДКА и МП-автоматом, то есть язык данного автомата совпадает с L ∩ R.


**Вопрос:** Что такое неукорачивающаяся грамматика в теории формальных языков?


**Ответ:** Неукорачивающая грамматика (англ. noncontracting grammar) — это формальная грамматика, всякое правило из P которой имеет вид α→β, где α, β ∈ {Σ ∪ N}+ и |α|⩽|β| (возможно правило S→ε, но тогда S не встречается в правых частях правил).


**Вопрос:** Что такое грамматика в ослабленной нормальной форме Грейбах?


**Ответ:** Грамматикой в ослабленной нормальной форме Грейбах (англ. Greibach weak normal form) называется контекстно-свободная грамматика, в которой могут содержаться только правила одного из следующих типов: A→aγ, S→ε, где a — терминал, A — нетерминал (возможно, стартовый), S — стартовый нетерминал (причём он не должен встречаться в правых частях правил), ε — пустая строка, γ — строка из произвольного числа терминалов и нетерминалов.


**Вопрос:** Докажи, что любую контекстно-свободную грамматику можно привести к ослабленной нормальной форме Грейбах.


**Ответ:** Рассмотрим контекстно-свободную грамматику Γ. Для приведения её к нормальной ослабленной форме Грейбах нужно выполнить три шага. На каждом шаге мы строим новую грамматику, допускающую тот же язык, что и Γ. 1. Избавимся от ε-правил. Для этого воспользуемся алгоритмом удаления ε-правил. 2. Воспользуемся алгоритмом устранения левой рекурсии. Получим грамматику, все правила которой будут иметь следующий вид: A_i→aγ, A_i→A_jγ, где A_i, A_j — нетерминалы, a — терминал, γ — произвольная последовательность из терминалов и нетерминалов, i<j. 3. Воспользуемся следующей функцией для придания грамматике нужного вида: function greibah(правила A_1...A_n из контекстно-свободной грамматики Γ) {     for i = n .. 1 {         for j = i + 1 .. n {             Для каждого правила вывода из A_j вида A_j→δ_1|...|δ_k заменить каждое правило A_i→A_jγ на A_i→δ_1γ|...|δ_kγ.         }     } } После каждой итерации главного цикла все правила для A_k (где k⩾i) будут иметь вид A_k→aγ. Значит, после применения процедуры все правила грамматики будут иметь вид A→aγ. Таким образом, мы получили грамматику в ослабленной нормальной форме Грейбах, которая допускает тот же язык, что и исходная.


**Вопрос:** Что такое самоприменимая контекстно-свободная грамматика?


**Ответ:** Контекстно-свободная грамматика G = ⟨N, Σ, P, S⟩ называется самоприменимой (англ. self-embeded), если ∃A ∈ N : A ⇒* αAβ, α≠ε ∧ β≠ε.


**Вопрос:** Что такое взаимно рекурсивные нетерминалы?


**Ответ:** Нетерминалы A, B ∈ N в грамматике G = ⟨N, Σ, P, S⟩ называются взаимно рекурсивными (англ. mutual recursive), если ∃ α_1, β_1, α_2, β_2 ∈ (Σ ∪ N)* : A ⇒* α_1Bβ_1 ∧ B ⇒* α_2Aβ_2 .


**Вопрос:** Докажи, что любую контекстно-свободную грамматику можно привести к нормальной форме Хомского.


**Ответ:** Рассмотрим контекстно-свободную грамматику Γ. Для приведения ее к нормальной форме Хомского необходимо выполнить пять шагов. На каждом шаге мы строим новую Γ_i, которая допускает тот же язык, что и Γ. 1. Уберём длинные правила. Воспользуемся алгоритмом удаления длинных правил из грамматики. Получим грамматику Γ_1, эквивалентную исходной, содержащую правила длины 0, 1 и 2. 2. Удаление ε-правил. Воспользуемся алгоритмом удаления ε-правил из грамматики. Получим грамматику Γ_2, эквивалентную исходной, но в которой нет ε-правил. 3. Удаление цепных правил. Воспользуемся алгоритмом удаления цепных правил из грамматики. Алгоритм работает таким образом, что новые ε-правила не образуются. Получим грамматику Γ_3, эквивалентную Γ. 4. Удалим бесполезные символы. Воспользуемся алгоритмом удаления бесполезных символов из грамматики. Так как Γ_3 эквивалентна Γ, то бесполезные символы не могли перестать быть бесполезными. Более того, мы только удаляем правила, новые ε-правила и цепные правила не могли появиться. 5. Уберём ситуации, когда в правиле встречаются несколько терминалов. Для всех правил вида A → u_1u_2 (где u_i — терминал или нетерминал) заменим все терминалы u_i на новые нетерминалы U_i и добавим правила U_i→u_i. Теперь правила содержат либо одиночный терминал, либо строку из двух нетерминалов. Таким образом, мы получили грамматику в нормальной форме Хомского, которая допускает тот же язык, что и Γ. Стоит заметить, что порядок выполнения операций важен. Первое правило должно быть выполнено перед вторым, иначе время нормализации ухудшится до O(2^|Γ|). Третье правило идет после второго, потому что после удаления ε-правил, могут образоваться новые цепные правила. Также четвертое правило должно быть выполнено позже третьего и второго, так как они могут порождать бесполезные символы. При таком порядке действий размеры грамматики возрастают полиномиально. После удалении длинных правил из каждого правила длины k⩾3 могло появиться k−1 новых правил, причем их длина не превышает двух. На этом шаге размер грамматики возрастает не более, чем вдвое. При удалении ε-правил из грамматики, содержащей правила длины 0, 1 и 2, размеры грамматики могли вырасти не больше, чем в 3 раза. Всего цепных правил в грамматике не больше, чем n^2, где n — число нетерминалов. При удалении цепных правил мы берем каждую из цепных пар и производим добавление нецепных правил, выводимых из второго нетерминала в паре. Если максимальная суммарная длина всех правил, выводимых из какого-либо нетерминала, равна k, то размер грамматики возрастет не больше, чем на k*n^2. Наконец, на последнем шаге может произойти добавление не более, чем |Σ| (Σ — алфавит грамматики) новых правил, причем все они будут длины 1.


**Вопрос:** Сформулируй лемму Огдена в теории формальных языков.


**Ответ:** Для каждой контекстно-свободной грамматики Γ = ⟨Σ, N, S ∈ N, P ⊂ N × (Σ ∪ N)*⟩ существует такое n, что для любого слова ω ∈ L(Γ) длины не менее n и для любых выделенных в ω не менее n позиций, ω может быть представлено в виде ω = uvxyz, причем: 1. x содержит выделенную позицию; 2. либо u и v, либо y и z обе содержат выделенные позиции; 3. vxy содержат не более n выделенных позиций; 4. существует A ∈ N, такой что S ⇒+ uAz ⇒+ uvAyz ⇒+ uvxyz. (т.е. ∀ k⩾0 u(v^k)x(y^k)z ∈ L)
