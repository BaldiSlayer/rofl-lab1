- question: Что представляет собой язык, распознаваемый недетерминированным конечным автоматом (НКА)?
  answer: > 
    Язык, распознаваемый недетерминированным конечным автоматом (НКА) – это все такие слова, 
    по которым существует хотя бы один путь из стартовой вершины в терминальную.
  author: Лисов Алексей

- question: Дан регулярный язык, опиши алгоритм нахождения кратчайшего слова, принадлежащего этому регулярному языку
  answer: > 
    Регулярный язык может быть задан с помощью конечного автомата. 
    Так как автомат конечен, то мы можем его обойти (пройти через все состояния) за конечное время. 
    Так как нам нужно найти самое короткое слово, то эта задача сводится к тому, что нам необходимо 
    найти кратчайший путь от стартовой вершины до какой-либо терминальной. По определению это 
    можно сделать с помощью поиска в ширину (bfs, breadth-first search). Поиск в ширину - алгоритм, находящий 
    все кратчайшие пути от заданной вершины в невзвешенном графе. Запускаем поиск в ширину и выйдем из него, 
    когда пришли в терминальное состояние. Так как нам нужно явно найти кратчайшее слово, то после этого делаем 
    восстановление ответа. Это можно сделать используя дополнительную структуру данных (например массив prev), для того, 
    чтобы для каждого состояния v хранить состояние u, из которого мы в него пришли. Мы можем пройти от найденной 
    вершины по массиву prev, пока не придем в начальное состояние. Записав все переходы мы получим кратчайшее слово, 
    принадлежащее регулярному языку.
  author: Лисов Алексей

- question: Опиши алгоритм подсчета количества слов определенной длины в заданном регулярном языке
  answer: > 
    Обозначим регулярный язык за L и пусть длина слов, количество которых мы хотим найти - l.
    Так как язык L регулярен, то мы можем построить соответствующий ему конечный автомат A.
    Решим задачу с помощью динамического программирования. Пусть a_(q,i) – количество слов длины i, переводящих 
    автомат A из начального состояния q0 в состояние q. 
    Чтобы пересчитать эту величину, нужно просуммировать значения динамического программирования
    из предыдущего по длине слоя для всех состояний, из которых есть ребро в состояние q. Ответом является
    сумма элементов столбца, отвечающего за длину l, соответствующих терминальным вершинам.
  author: Лисов Алексей

- question: Какими являются языки недетерминированных автоматов с магазинной памятью?
  answer: > 
    Языки недетерминированных автоматов с магазинной памятью являются контекстно-свободными.
    То есть эти языки могут быть заданы с помощью контекстно свободных грамматик.
  author: Лисов Алексей

- question: Какая структура данных может описать магазинную память у автомата с магазинной памятью?
  answer: Магазинная память у автомата с магазинной памятью является стеком.
  author: Лисов Алексей

- question: Опиши алгоритм нахождения эпсилон замыкания для каждой из вершин автомата?
  answer: >
    ε-замыкание состояния q – это множество состояний, достижимых из q только по ε-переходам. 
    Соотсветственно эпсилон замыкание для каждой из вершин автомата можно предподсчитать с помощью поиска в глубину 
    (dfs) для каждой вершины.
  author: Лисов Алексей

- question: Дай определение произведения двух автоматов
  answer: >
    Прямым произведением двух ДКА A1=⟨Σ1,Q1,s1,T1,δ1⟩ и A2=⟨Σ2,Q2,s2,T2,δ2⟩ называется ДКА 
    A=⟨Σ,Q,s,T,δ⟩, где: 
    1) Σ = Σ1∪Σ2, то есть он работает над пересечением алфавитов двух данных автоматов 
    2) Q = Q1×Q2, множество пар состояниий включает в себя состояния обоих автоматов 
    3) s =⟨s1,s2), стартуем с символов в обоих автоматах 
    4) T=T1×T2, терминальные состояния включают в себя терминальные состояния обоих автоматов 
    5) δ(⟨q1,q2⟩,c)=⟨δ1(q1,c),δ2(q2,c)⟩, то есть переходим по символу в обоих автоматах"
  author: Лисов Алексей

- question: Как из недетерминированного конечного автомата A сделать pushdown automat B?
  answer: >
    Для этого нужно заменить переход из состояния q в состояние p по символу x на такой же переход, 
    только добавить z_0/z_0, где z_0 это дно стека. Из этого следует, что регулярные языки являются подмножеством 
    МП-автоматных языков (языков автоматов с магазинной памятью).
  author: Лисов Алексей

- question: Теорема Клини (англ. Kleene's theorem)
  answer: >
    Теорема Клини (англ. Kleene's theorem) гласит о том, что множество языков, принимаемых детерминированным конечным автоматом совпадает с 
    множеством языком, принимаемых академическим регулярным выражением.
  author: Лисов Алексей

- question: Какой язык называется префиксным (беспрефиксным)
  answer: > 
    Язык L называется префиксным, если для любого слова w не равного слову v из L не верно, что w – префикс v. 
    Также такие языки называют беспрефиксными.
  author: Лисов Алексей

- question: >
    Что можно сказать о языке L, который принимается детерминированным конечным автоматом 
    с магазинной памятью по пустому стеку
  answer: > 
    Это значит, что язык L принимается детерминированным конечным автоматом с магазинной памятью по терминальному 
    состоянию, а также язык L – префиксный (то есть если для любого w не равного v из языка L не верно,
    что w – префикс v).
  author: Лисов Алексей

- question: >
    Является ли регулярным язык Дика (англ. Dyck's language) с единственным типом скобок?
    (язык Дика - множество правильных скобочных структур вместе с пустой структурой, 
    образующее язык над алфавитом {a,b}.)
  answer: > 
    Язык Дика (англ. Dyck's language) не является регулярным.
    Докажем с помощью леммы о накачке. Предположим, что он регулярный, тогда по лемме о накачке существует 
    n, являющееся длиной накачки. Возьмём последовательность из n открывающих, а затем n закрывающих скобок. 
    Для неё существуют соответствующие x, y, z из леммы о накачке. Но так как |xy| <= n, то y 
    состоит только из открывающих скобок, причём по условию леммы y не пустая. А значит при i = 2 в строке xy^iz 
    получится больше открывающих скобок, чем закрывающих, то есть это будет не правильной скобочной последовательностью. 
    Получили противоречие. Следовательно язык Дика с единственным типом скобок не является регулярным.
  author: Лисов Алексей

- question: >
    Является ли контекстно-свободным языком разность контекстно-свободного и регулярного языка?
  answer: > 
    Да, разность контекстно-свободного и регулярного языка является контекстно-свободным языком.
  author: Лисов Алексей

- question: >
    Что такое переход машины Тьюринга?
  answer: > 
    Переход машины Тьюринга — это функция, зависящая от состояния конечного управления и обозреваемого символа. 
    За один переход машина Тьюринга должна выполнить следующие действия: изменить состояние, 
    записать ленточный символ в обозреваемую клетку, сдвинуть головку влево или вправо.
  author: Дмитрий Теньшов

- question: >
    Какие языки допускаются при помощи машины Тьюринга?
  answer: > 
    Языки, допустимые с помощью машины Тьюринга, называются рекурсивно перечислимыми, или РП-языками.
  author: Дмитрий Теньшов

- question: >
    Опишите прием «память в состоянии» машины Тьюринга.
  answer: > 
    Память в состоянии — конечное управление можно использовать не только для представления позиции в «Программе» машины Тьюринга, 
    но и для хранения конечного объема данных.
  author: Дмитрий Теньшов

- question: >
    Опишите прием «Подпрограммы» машины Тьюринга.
  answer: > 
    Подпрограмма машины Тьюринга представляет собой множество состояний, выполняющее некоторый полезный процесс. 
    Это множество включает в себя стартовое состояние и еще одно состояние, 
    которое не имеет переходов и служит состоянием «возврата» для передачи управления какому-либо множеству состояний, 
    вызвавшему данную подпрограмму. «Вызов» подпрограммы возникает везде, где есть переход в ее начальное состояние.
  author: Дмитрий Теньшов

- question: >
    Можно ли запомнить позицию ленточной головки в позиции управления у машины Тьюринга?
  answer: > 
    Хотя позиции конечны в каждый момент времени, всё множество позиций может быть и бесконечным. 
    Если состояние должно представлять любую позицию головки, то в состоянии должен быть компонент данных, 
    имеющий любое целое в качестве значения. Из-за этого компонента множество состояний должно быть бесконечным, 
    даже если только конечное число состояний используется в любой конечный момент времени. Определение же машин Тьюринга требует, 
    чтобы множество состояний было конечным. Таким образом, запомнить позицию ленточной головки в конечном управлении нельзя.
  author: Дмитрий Теньшов

- question: >
    Что такое счетчиковая машина?
  answer: > 
    Счетчиковые машины — это класс машин, обладающий возможностью запоминать конечное число целых чисел (счетчиков) 
    и совершать различные переходы в зависимости от того, какие из счетчиков равны 0 (если таковые вообще есть). 
    Счетчиковая машина может только прибавить 1 к счетчику или вычесть 1 из него, 
    но отличить значения двух различных ненулевых счетчиков она не способна.
  author: Дмитрий Теньшов

- question: >
    Какой язык допускается счетчиковой машиной?
  answer: > 
    Каждый язык, допускаемый счетчиковой машиной, рекурсивно перечислим. Причина в том, 
    что счетчиковые машины являются частным случаем магазинных, а магазинные — частным случаем многоленточных машин Тьюринга, 
    которые по теореме допускают только рекурсивно перечислимые языки.
  author: Дмитрий Теньшов

- question: >
    Допускается ли любой рекурсивно перечислимый язык двухсчетчиковой машиной?
  answer: > 
    Для имитации машины Тьюринга и, следовательно, для допускания любого рекурсивно перечислимого языка, достаточно двух счетчиков. 
    Для обоснования этого утверждения вначале доказывается, что достаточно трех счетчиков, 
    а затем три счетчика имитируются с помощью двух.
  author: Дмитрий Теньшов

- question: >
    Что такое универсальная машина Тьюринга?
  answer: > 
    Универсальной машиной Тьюринга называют машину Тьюринга, которая может заменить собой любую машину Тьюринга. 
    Получив на вход программу и входные данные, она вычисляет ответ, который вычислила бы по входным данным машина Тьюринга, 
    чья программа была дана на вход.
  author: Дмитрий Теньшов

- question: >
    Какое время необходимо многоленточной машине Тьюринга для имитации шагов компьютера?
  answer: > 
    Рассмотрим компьютер, обладающий следующими свойствами: у него есть только инструкции, 
    увеличивающие максимальную длину слова не более чем на один; у него есть только инструкции, 
    которые многоленточная машина Тьюринга может выполнить на словах длиной k за O(k^2) или меньшее число шагов. 
    Шаг — это выполнение одной инструкции. Таким образом, выполнение n шагов работы компьютера можно проимитировать 
    на многоленточной машине Тьюринга с использованием не более O(n^3) шагов.
  author: Дмитрий Теньшов

- question: >
    Как связаны мощности следующих машин Тьюринга: многодорожечная машина Тьюринга, 
    машина Тьюринга с односторонней лентой, многоленточная машина Тьюринга, недетерминированная машина Тьюринга?
  answer: > 
    Многодорожечная машина Тьюринга, машина Тьюринга с односторонней лентой, многоленточная машина Тьюринга 
    и недетерминированная машина Тьюринга, несмотря на различия в их конструкции или правилах работы, 
    обладают одинаковой вычислительной мощностью, то есть способны вычислить одни и те же классы функций. 
    Различия между видами машин Тьюринга (например, между машинами с одним или несколькими лентами) 
    могут повлиять на эффективность вычислений (время или пространство), но не на саму вычислительную мощность.
  author: Дмитрий Теньшов

- question: >
    Если проблема P1 неразрешима и ее можно свести к проблеме P2, то является ли проблема P2 неразрешимой?
  answer: > 
    Если проблему P1 можно свести к проблеме P2 и если P1 неразрешима, то и P2 неразрешима.
  author: Дмитрий Теньшов

- question: >
    Что такое рандомизированная машина Тьюринга?
  answer: > 
    Рандомизированная машина Тьюринга — это вариант многоленточной машины Тьюринга. Первая лента, 
    как обычно для многоленточных машин, содержит вход. Вторая лента также начинается непустыми клетками. 
    В принципе, вся она содержит символы 0 и 1, выбранные с вероятностью 1/2. Вторая лента называется случайной лентой. 
    Третья и последующие, если используются, вначале пусты и при необходимости выступают как рабочие.
  author: Дмитрий Теньшов


- question: "Рекурсивные языки."
  answer: >
    Языки, допускаемые машинами Тьюринга, называются рекурсивно-перечислимыми (РП),
    а РП-языки, допускаемые МТ, которые всегда останавливаются, — рекурсивными. “Разрешимость” есть 
    синоним “рекурсивности”, однако языки чаще называются “рекурсивными”, а проблемы (которые 
    представляют собой языки, интерпретируемые как вопросы) — “разрешимыми”. 
    Если язык не является рекурсивным, то проблема, которую выражает этот язык, называется “неразрешимой”.
    Рекурсивный язык позволяет построить разрешающую функцию: т.е. МТ, возвращающую один из двух результатов (да-нет), и корректно завершающую работу.
  author: "Филимонов Михаил"


- question: "Рекурсивно-перечислимые языки. Примеры языков, которые являются рекурсивно-перечислимыми, но не рекурсивными."
  answer: >
    Язык L является рекурсивно-перечислимым (РП-языком), если L = L(M) для некоторой машины Тьюринга M.
    Проблема останова машины Тьюринга является РП, но не рекурсивной. В действительности, определенная А. М. Тьюрингом 
    машина допускала, не попадая в допускающее состояние, а останавливаясь. Для МТ 
    M можно определить H(M) как множество входов w, на которых M останавливается 
    независимо от того, допускает ли M вход w. Тогда проблема останова состоит в опре 
    делении множества таких пар (M, w), у которых w принадлежит H(M). Это еще один 
    пример проблемы/языка, которая является РП, но не рекурсивной.
  author: "Филимонов Михаил"


- question: "Что такое язык диагонализации L_d"
  answer: >
    Язык диагонализации L_d — это множество всех цепочек w_i, не принадлежащих L(M_i).
    Понятие M_i, “i-й машины Тьюринга”. Это машина Тьюринга M, кодом которой является i-я двоичная цепочка w_i.
    В язык L_d  входит каждая цепочка в алфавите {0, 1}, которая, будучи проинтерпретированной как код МТ, не принадлежит языку этой МТ.
    Язык L_d является хорошим примером не РП-языка, т.е. его не допускает ни одна машина Тьюринга.
  author: "Филимонов Михаил"


- question: "Является ли язык L_d рекурсивно-перечислимым"
  answer: >
    Язык L_d не является рекурсивно-перечислимым, т.е. не существует машины Тьюринга, которая допускала бы L_d.
    Доказательство. Допустим, что L_d = L(M) для некоторой МТ M.
    Так как L_d — язык над алфавитом {0, 1}, M должна содержаться в построенной нами последовательности машин Тьюринга,
    поскольку эта последовательность содержит все МТ с входным алфавитом {0, 1}.
    Следовательно, в ней есть, по крайней мере, один код машины M, скажем, i, т.е. M = M_i.
    Понятие M_i, “i-й машины Тьюринга”. Это МТ M, кодом которой является i-я двоичная цепочка w_i.
    Выясним теперь, принадлежит ли w_i языку L_d.
    Если w_i принадлежит L_d, то M_i допускает w_i. Но тогда (по определению L_d) w_i не принадлежит L_d,
    так как L_d содержит лишь такие w_j, для которых M_j не допускает w_j.
    Точно так же, если w_i не принадлежит L_d, то M_i не допускает w_i.
    Но тогда (по определению L_d) w_i принадлежит L_d.
    Поскольку w_i не может одновременно и принадлежать, и не принадлежать L_d, приходим к противоречию с нашим предположением о том, что M существует.
    Таким образом, L_d не является рекурсивно-перечислимым языком.
  author: "Филимонов Михаил"


- question: "Почему языки 'рекурсивные'?"
  answer: >
    Рекурсивные функции были введены в 30-х годах XX века С. К. Клини. 
    Это название закрепилось за одним из наиболее распространённых вариантов 
    уточнения общего понятия арифметического алгоритма, то есть такого алгоритма, 
    допустимые исходные данные которого представляют собой системы натуральных чисел, 
    а возможные результаты применения — натуральные числа.
    Языки называются рекурсивными, если они являются рекурсивным подмножеством набора всех 
    возможных конечных последовательностей по алфавиту языка. Тезис Чёрча — Тьюринга: любая функция, 
    которая может быть вычислена физическим устройством, может быть вычислена машиной Тьюринга. То есть
    рекурсивные функции вычисляют те же классы алгоритмов, что и машины Тьюринга. Эквивалентно, формальный язык 
    является рекурсивным, если существует машина Тьюринга, которая при вводе конечной 
    последовательности символов всегда останавливается и принимает её, если она 
    принадлежит языку, и останавливается и отвергает её в противном случае.
  author: "Филимонов Михаил"



- question: >
    Почему универсальный язык L_u является рекурсивно-перечислимым, но не рекурсивным.
  answer: >
    Язык L_u состоит из цепочек, интерпретируемых как код
    МТ, к которому дописан ее вход. Цепочка принадлежит L_u, если эта МТ до
    пускает данный вход.
    Язык L_u является рекурсивно-перечислимым. Допустим, что L_u рекурсивен. Тогда по теореме дополнение L_u (дополнение L_u) 
    также рекурсивный язык. Но если существует МТ M, допускающая L_u, то, используя описанный ниже метод, 
    можно построить МТ, допускающую L_d. Язык диагонализации L_d — это множество всех цепочек w_i, не принадлежащих L(M_i).
    Понятие M_i, “i-й машины Тьюринга”. Это МТ M, кодом которой является i-я двоичная цепочка w_i.
    В язык L_d  входит каждая цепочка в алфавите {0, 1}, которая, будучи проинтерпретированной как код МТ, не принадлежит языку этой МТ.
    Поскольку нам известно, что L_d не является РП, приходим к 
    противоречию с предположением, что язык L_u является рекурсивным. Предположим, что L(M) = L_u. Можно 
    преобразовать МТ M в МТ M', которая допускает L_d с помощью следующих действий: 1. M' преобразует 
    входную цепочку w в w111w. Легче это сделать, используя для копии w вторую ленту, и затем 
    преобразовать двухленточную МТ в одноленточную. 2. M' имитирует M на новом входе. Если w есть w_i 
    в нашем перечислении, то M' определяет, допускает ли M_i вход w_i. Поскольку M допускает L_u, то она 
    допускает тогда и только тогда, когда M_i не допускает w_i, т.е. когда w_i принадлежит L_d. Таким образом, 
    M' допускает w тогда и только тогда, когда w принадлежит L_d. Поскольку по теореме машины M' не существует, 
    приходим к выводу, что язык L_u не является рекурсивным.
  author: "Филимонов Михаил"


- question: >
    Является ли язык, состоящий из кодов всех машин Тьюринга, 
    которые допускают хотя бы одну цепочку, L_ne рекурсивно-перечислимым/рекурсивным?
  answer: >
    L_ne – непустой язык состоит из кодов всех машин Тьюринга, которые допускают хотя бы одну цепочку. 
    Он рекурсивно-перечислим, но не рекурсивный. Чтобы доказать РП, достаточно предъявить МТ, допускающую L_ne. 
    Проще всего это сделать, описав недетерминированную МТ M. Работа M заключается в следующем: 1. На вход M подается 
    код МТ M_i. 2. Используя недетерминизм, M угадывает вход w, который, возможно, допускается M_i. 
    3. M проверяет, допускает ли M_i свой вход w. В этой части M может моделировать работу универсальной МТ U, 
    допускающей L_u (язык L_u состоит из цепочек, интерпретируемых как код
    МТ, к которому дописан ее вход. Цепочка принадлежит L_u, если эта МТ до
    пускает данный вход). 4. Если M_i допускает w, то и M допускает свой вход, т.е. M_i. Понятие M_i, “i-й машины 
    Тьюринга”. Это МТ M, кодом которой является i-я двоичная цепочка w_i. В этот язык входит каждая цепочка 
    в алфавите {0, 1}, которая, будучи проинтерпретированной как код МТ, не принадлежит языку этой МТ. 
    Таким образом, если M_i допускает хотя бы одну цепочку, то M угадает ее (среди прочих, конечно) и допустит M_i. 
    Если же L(M_i) = ∅, то ни одна из угаданных w не допускается M_i, и M не допустит M_i. Таким образом, L(M) = L_ne.
  author: "Филимонов Михаил"


- question: >
    Является ли язык L_e, состоящий из кодов всех МТ, языки которых пусты, рекурсивно-перечислимым/рекурсивным?
  answer: >
    L_e – пустой язык состоит из кодов всех МТ, языки которых пусты. Он не рекурсивно-перечислим.
  author: "Филимонов Михаил"


- question: >
    Теорема Райса
  answer: >
    Свойство называется тривиальным, если оно либо пустое (т.е. никакой язык вообще
    ему не удовлетворяет), либо содержит все РП-языки (рекурсивно-перечислимые). В противном случае свойство назы
    вается нетривиальным. 
    Теорема Райса: Всякое нетривиальное свойство языков, допускаемых МТ, является неразрешимым. Например, множество кодов 
    машин Тьюринга, допускающих пустой язык, согласно теореме Райса является неразрешимым. В действительности 
    этот язык не является РП, хотя его дополнение — множество кодов МТ, допускающих хотя бы одну цепочку, — 
    является РП, но не рекурсивным.
  author: "Филимонов Михаил"


- question: >
    Существует ли такой вход для заданной машины Тьюринга, 
    при обработке которого машина выполняет более пяти переходов, 
    прежде чем достигнет состояния останова (либо завершится, либо зациклится)?
  answer: >
    Алгоритм решения становится очевидным, если заметить, что, когда МТ делает пять переходов, 
    она обозревает не более девяти клеток вокруг начальной позиции головки. Поэтому можно проимитировать 
    пять переходов МТ на любом из конечного числа входов, длина которых не более девяти. Если все эти 
    имитации не достигают останова, то делается вывод, что на любом входе данная МТ совершает более пяти переходов.
  author: "Филимонов Михаил"


- question: >
    Что такое проблема соответствий Поста.
  answer: >
    Экземпляр проблемы соответствий Поста (ПСП) состоит из двух списков равной длины в некотором алфавите Σ. 
    Как правило, мы будем называть их списками A и B, и писать A = w_1, w_2, …, w_k и B = x_1, x_2, …, x_k при 
    некотором целом k. Для каждого i пара (w_i, x_i) называется парой соответствующих цепочек. Мы говорим, что 
    экземпляр ПСП имеет решение, если существует последовательность из одного или нескольких целых чисел 
    i_1, i_2, …, i_m, которая, если считать эти числа индексами цепочек и выбрать соответствующие цепочки из 
    списков A и B, дает одну и ту же цепочку, т.е. w_i_1w_i_2…w_i_m = x_i_1xi_2…x_i_m. В таком случае последовательность 
    i_1, i_2, …, i_m называется решающей последовательностью, или просто решением, данного экземпляра ПСП.
  author: "Филимонов Михаил"

- question: >
    Что такое модифицированная проблема соответствий Поста.
  answer: >
    Модифицированной проблемой соответствий Поста, или МПСП. 
    В модифицированной ПСП на решение накладывается дополнительное требование, 
    чтобы первой парой в решении была пара первых элементов списков A и B. 
    Более формально, экземпляр МПСП состоит из двух списков A = w_1, w_2, …, w_k 
    и B = x_1, x_2, …, x_k, и решением является последовательность из 0 или 
    нескольких целых чисел i_1, i_2, …, i_m, при которой 
    w_1w_i_1w_i_2…w_i_m = x_1x_i_1x_i_2…x_i_m. Отметим, что цепочки обязательно начинаются парой (w_1, x_1), 
    хотя индекс 1 даже не указан в качестве начального элемента решения. Кроме того, в отличие от ПСП, 
    решение которой содержит хотя бы один элемент, решением МПСП может быть и пустая последовательность (когда w_1 = x_1).
  author: "Филимонов Михаил"


- question: >
    Разрешима ли ПСП/проблема соответствий Поста
  answer: >
    Заданы два списка, содержащие одинаковое количество цепочек. 
    Спрашивается, можно ли, выбирая последовательности соответствующих 
    цепочек из этих двух списков, построить путем их конкатенации одну 
    и ту же цепочку. ПСП является важным примером неразрешимой проблемы. 
    Сводимость ПСП к ряду других проблем обеспечивает доказательство их неразрешимости
  author: "Филимонов Михаил"


- question: >
    Разрешим ли вопрос о неоднозначности КС-грамматики (контекстно-свободной грамматики)
  answer: >
    Вопрос о неоднозначности КС-грамматики (контекстно-свободной грамматики) неразрешим. 
    Неразрешимые проблемы, связанные с контекстно-свободными языками. 
    Посредством сведения ПСП(проблема соответствий Поста) к вопросу об определении некоторых свойств КС-грамматики можно доказать неразрешимость многих вопросов 
    о КС-языках или их грамматиках. В силу неразрешимости ПСП это сведение доказывает неразрешимость про
    блемы неоднозначности КС-грамматики.  Так же, например, о включении одного КС-языка в 
    другой или о пустоте пересечения двух КС-языков."
  author: "Филимонов Михаил"


- question: >
    Что называется нейтральным элементом операции в регулярных выражениях?
  answer: >
    Нейтральный (единичный) элемент в контексте операций в регулярных выражениях — это элемент,
    для которого верно: если данная операция применяется к единичному элементу и некоторому выражению,
    то результат равен этому выражению. Для регулярных выражений нейтральные элементы зависят от конкретного типа операции:
    1. Конкатенация: Нейтральным элементом для конкатенации является пустая строка (обозначается ε).
    При конкатенации любой строки с ε результат остается неизменным.
    2. Объединение (дизъюнкция): Для операции объединения нейтральным элементом является пустое множество (обозначается ∅).
    Объединение любого выражения с ∅ не изменяет его.
  author: "Захарин Сергей"


- question: >
    Что называется нулевым элементом (аннулятором) операции в регулярных выражениях?
  answer: >
    Нулевой элемент (или аннулятор) в контексте операций в регулярных выражениях — это элемент,
    который при применении операции с другим выражением всегда возвращает сам нулевой элемент. В алгебре нулевой элемент обнуляет результат операции,
    независимо от второго аргумента. В контексте регулярных выражений это понятие также применимо, и оно зависит от типа операции:
    1. Конкатенация: Для конкатенации нулевым элементом является пустое множество (обозначаемое ∅). При конкатенации любого выражения с ∅ результатом всегда будет ∅.
    2. Объединение (дизъюнкция): Для операции объединения (дизъюнкции) нулевого элемента как такового не существует.
    Объединение с ∅ даёт исходное выражение, а не ∅, то есть ∅ здесь является нейтральным, а не нулевым элементом.
  author: "Захарин Сергей"


- question: >
    В каком случае два регулярных выражения с переменными являются эквивалентными?
  answer: >
    Два выражения с переменными являются эквивалентными, если при подстановке любых языков вместо переменных оба выражения представляют один и тот же язык.
  author: "Захарин Сергей"


- question: >
    Какие операторы регулярных выражений ассоциативны? Коммутативны? Дистрибутивны? Идемпотентны?
  answer: >
    Объединение и конкатенация ассоциативны. Коммутативно только объединение. Конкатенация дистрибутивна относительно объединения.
    Объединение идемпотентно.
  author: "Захарин Сергей"


- question: >
    Закон идемпотентности операции объединения для регулярных выражений
  answer: >
    Закон идемпотентности операции объединения утверждает, что объединение двух одинаковых выражений можно заменить одним таким выражением.
  author: "Захарин Сергей"


- question: >
    Что такое обращение строки в формальных языках?
  answer: >
    Строку также часто называют словом. Обращением строки (a_1)(a_2)...(a_n) называется строка, записанная в обратном порядке, т.е. (a_n)(a_n-1)...(a_1).
    Обращение w обозначается w^R. Таким образом, например, (0010)^R есть 0100, а ε^R = ε.
  author: "Захарин Сергей"


- question: >
    Что такое обращение языка L?
  answer: >
    Обращение языка L, обозначаемое L^R, состоит из всех строк, являющихся реверсами (обращениями) строк из исходного языка L.
    То есть, если L — это язык, состоящий из строк w_1, w_2, ..., w_n, то обращение этого языка L^R включает строки, полученные путём инвертирования каждой из строк языка L.
    Например, если L = {001, 10, 111}, то L^R = {100, 01, 111}.
  author: "Захарин Сергей"


- question: >
    Что такое гомоморфизм строк в регулярных языках?
  answer: >
    Строку также часто называют словом. Гомоморфизм строк — это такая функция на множестве строк, являющаяся расширением функции отображения символов алфавита в строки относительно операции конкатенации.
  author: "Захарин Сергей"


- question: >
    Как рекурсивно определяется регулярное выражение?
  answer: >
    Регулярное выражение над алфавитом Σ = {c_1, c_2, …, c_k} — способ порождения языка над Σ. Определяется рекурсивно следующим образом:
    Для любого i слово c_i является регулярным выражением, задающим язык из одного слова ci. ε является регулярным выражением, задающим язык из одной пустой
    строки, а ∅ — пустой язык. Если a_1 и a_2 являются регулярными выражениями, задающими языки L_1 и L_2 соответственно, то (a_1)|(a_2) — регулярное выражение,
    задающее L_1 ⋃ L_2. Если a_1 и a_2 являются регулярными выражениями, задающими языки L_1 и L_2 соответственно, то (a_1)(a_2) — регулярное выражение,
    задающее L_1L_2. Если a_1 является регулярным выражением, задающим язык L_1, то (a_1)* — регулярное выражение, задающее (L_1)*.
  author: "Захарин Сергей"


- question: >
    Что такое замыкание Клини и где оно используется в регулярных выражениях?
  answer: >
    Итерация (“звездочка”, или замыкание Клини) языка L обозначается L* и представляет собой множество всех тех цепочек, которые можно образовать путем
    конкатенации любого количества цепочек из L. При этом допускаются повторения, т.е. одна и та же цепочка из L может быть выбрана для конкатенации более одного
    раза. Например, если L = {0, 1}, то L* — это все цепочки, состоящие из нулей и единиц. Если L = {0, 11}, то в L* входят цепочки из нулей и единиц,
    содержащие четное количество единиц, например, цепочки 011, 11110 или ε, и не входят цепочки 01011 или 101. Более формально язык L* можно представить
    как бесконечное объединение L^i, где L^0 = ε, L^1 = L и Li для i>1 равен LL...L(конкатенация i копий L).
  author: "Захарин Сергей"


- question: >
    Лемма о разрастании для контекстно-свободных языков
  answer: >
    Также называется леммой о накачке для контекстно-свободных языков. Пусть L — контекстно-свободный язык над алфавитом Σ, тогда существует такое натуральное n, что для любого слова ω, принадлежащего L, длины не меньше n
    найдутся слова u, v, x, y, z, принадлежащие Σ*, для которых верно: uvxyz = ω, vy ≠ ε, |vxy| <= n и ∀k >= 0 u(v^k)x(y^k)z ∈ L. Иначе говоря, любую
    достаточно длинную цепочку в КС-языке можно разбить на пять частей так, что повторение второй и четвёртой частей произвольное количество раз (возможно, 0)
    не приведут к выходу за пределы языка.
  author: "Захарин Сергей"


- question: >
    Относительно каких операций замкнуты регулярные языки?
  answer: >
    Регулярные языки замкнуты относительно следующих операций:
    1. Объединение
    2. Пересечение
    3. Дополнение
    4. Разность
    5. Обращение
    6. Итерация (звездочка)
    7. Конкатенация
    8. Гомоморфизм (подстановка цепочек вместо символов языка)
    9. Обратный гомоморфизм.
  author: "Захарин Сергей"


- question: >
    Законы регулярных выражений, связанные с единичным элементом и нулевым элементом
  answer: >
    Для регулярных выражений существует три закона, связанных с этими понятиями.
    • ∅ + L = L + ∅ = L. Этот закон утверждает, что ∅ является единицей объединения.
    • εL = Lε = L. Этот закон гласит, что ε является единицей конкатенации.
    • ∅L = L∅ = ∅. Этот закон утверждает, что ∅ является нулевым элементом конкатенации.
  author: "Захарин Сергей"

- question: >
    Какие существуют приемы интерпретации ленты и конечного управления машины Тьюринга?
  answer: >
    Существует три приема интерпретации ленты и конечного управления машины Тьюринга: память в состоянии, многодорожечные ленты, подпрограммы.
  author: Пишикина Мария

- question: >
    Опишите прием «Многодорожечные ленты» в машине Тьюринга.
  answer: >
    При использовании приема «Многодорожечные ленты» рассматривается лента машины Тьюринга, образованная несколькими дорожками. 
    Каждая дорожка может хранить один символ (в одной клетке), и алфавит машины Тьюринга состоит из кортежей, с одним компонентом для каждой «дорожки».
  author: Пишикина Мария

- question: >
    Существуют ли не рекурсивно перечислимые языки, допускаемые многоленточными машинами Тьюринга?
  answer: >
    Каждый язык, допускаемый многоленточной машиной Тьюринга, рекурсивно перечислим.
  author: Пишикина Мария

- question: >
    Какое время необходимо одноленточной машине Тьюринга для имитации переходов многоленточной машины Тьюринга?
  answer: >
    Время, необходимое одноленточной машине Тьюринга для имитации n переходов многоленточной машины Тьюринга, есть O(n^2).
  author: Пишикина Мария

- question: >
    Что такое «мультистековая (многомагазинная) машина»?
  answer: >
    Мультистековая (многомагазинная) машина представляет собой детерминированный МП-автомат (или машина с магазинной памятью) с несколькими магазинами. Он получает свои входные данные, как и МП-автомат, из некоторого их источника, 
    а не с ленты или из магазина, как машина Тьюринга. Мультистековая машина имеет конечное управление, то есть конечное множество состояний, и конечный магазинный алфавит, используемый для всех магазинов. 
    Переход мультистековой машины основывается на состоянии, входном символе и верхних символах всех магазинов.
  author: Пишикина Мария

- question: >
    Как называется язык, который допускается односчетчиковой машиной?
  answer: >
    «Односчетчиковые машины» — это класс машин, которые могут запоминать значение одного целого числа («счетчика») и совершать различные переходы в зависимости от того, равен ли счетчик 0. 
    Односчетчиковая машина может только прибавить 1 к счетчику или вычесть 1 из него, но не способна различать различные ненулевые значения счетчика.
    Каждый язык, допускаемый односчетчиковой машиной, является КС-языком. Контекстно-свободный (КС) язык — это язык, задаваемый контекстно-свободной грамматикой. 
    Контекстно-свободной грамматикой называется грамматика, у которой в левых частях всех правил стоят только одиночные нетерминалы.
  author: Пишикина Мария

- question:
    Можно ли имитировать машину Тьюринга на компьютере?
  answer: >
    Имитация машины Тьюринга на компьютере в принципе возможна, если допустить, что для имитации значащей части ленты существует потенциально бесконечный запас сменных запоминающих устройств вроде диска. 
    Поскольку физические ресурсы, необходимые для создания дисков, конечны, данный довод сомнителен. Однако, поскольку пределы памяти Вселенной неизвестны или, без сомнения, обширны, 
    предположение о бесконечности ресурсов (как для ленты машины Тьюринга) является практически реалистичным и в целом допустимо.
  author: Пишикина Мария

- question: >
    Какое время необходимо одноленточной машине Тьюринга для имитации переходов компьютера?
  answer: >
    Машина Тьюринга может имитировать n шагов компьютера за O(n^6) своих шагов.
  author: Пишикина Мария

- question: >
    Почему язык, допускающийся в недетерминированных машинах Тьюринга, также допускается и обычной детерминированной машиной Тьюринга?
  answer: >
    Несмотря на кажущуюся большую мощность недетерминированных машин в связи с тем, что они выполняют несколько возможных вычислений сразу 
    (требуя только, чтобы хоть одно из них заканчивалось в допускающем состоянии), любой язык, допускающийся недетерминированной машиной Тьюринга, 
    также допускается и обычной детерминированной машиной Тьюринга, поскольку она может моделировать любой недетерминированный переход, делая многократные копии состояния, если встречается неоднозначность.
  author: Пишикина Мария

- question: >
    Как машина Тьюринга имитирует реальный компьютер?
  answer: >
    Машина Тьюринга может имитировать память и управление реального компьютера путем использования одной ленты для записи всех элементов памяти и их содержимого — регистров, основной памяти, дисков и других запоминающих устройств. 
    Таким образом, можно быть уверенным, что все, не выполнимое машиной Тьюринга, не может быть сделано и компьютером.
  author: Пишикина Мария

- question: >
    Какая проблема может возникнуть при допуске языка в рандомизированную машину Тьюринга?
  answer: >
    Имея дело с рандомизированными машинами Тьюринга, нужно быть более аккуратным с тем, что значит допускание входа такой машиной; становится возможным, что машина Тьюринга не определяет функции математически корректно (т.е. независимо от рандомизированных данных). 
    Проблема в том, что при анализе действий рандомизированной машины Тьюринга со входом приходится рассматривать все возможные случайные последовательности на второй ленте. Вполне возможно, что машина Тьюринга 
    допускает при одних случайных последовательностях, но отвергает при других; в действительности, если рандомизированная машина Тьюринга должна делать что-то более эффективно, чем детерминированная машина Тьюринга, 
    то существенно, чтобы различные последовательности на рандомизированной ленте приводили к различному поведению.
  author: Пишикина Мария

- question: >
    Перечисли возможные операции над машинами Тьюринга.
  answer: >
    1) Композиция (суперпозиция) машин Тьюринга - пусть две машины Тьюринга X и Y вычисляют функции f(P) и g(P) соответственно, тогда можно построить машину Тьюринга T = Y(X), вычисляющую суперпозицию функций g(f(P)). 
    2) Разветвление машин Тьюринга - пусть две машины Тьюринга X и Y вычисляют функции f(P) и g(P) соответственно, причём множеством значений функции f(P) является множество {0, 1}, тогда можно построить машину Тьюринга T = X->Y, 
    которая перерабатывает слово P в g(P), если f(P)=1 и оставляет его без изменений если f(P)=0. 
    3) Цикл машин Тьюринга - пусть две машины Тьюринга X и Y вычисляют функции f(P) и g(P) соответственно, причём множеством значений функции f(P) является множество {0, 1}, тогда можно построить машину Тьюринга T = X∘Y, которая 
    выполняет следующую последовательность действий: 
      1 - вычисляет f(P) и если f(P)=1, то вычисляет новое значение P=g(P), а если f(P)=0, то переходит к заключительному состоянию с выходным словом P; 
      2 - повторяет действие 1 до тех пор пока для очередного значения P не будет выполнено f(P)=0.
  author: Пишикина Мария

- question: >
    Что такое самоприменимая машина Тьюринга?
  answer: >
    Машина Тьюринга называется самоприменимой, если она останавливается, когда в качестве входного слова для неё используется описание самой машины.
  author: Пишикина Мария

- question: >
    Как реализуется алгоритм для проверки принадлежности слова w к языку L в детерминированном конечном автомате (сокр. ДКА)?
  answer: > 
    Для проверки принадлежности слова w к языку L, распознаваемому детерминированным конечным автоматом (сокр. ДКА), используется рекурсивный алгоритм, который определяет, можно ли дойти до заключительного состояния автомата, прочитывая символы из w. 

    На вход подаются:
    - детерминированный конечный автомат A, заданный как кортеж (Q, Σ, δ, q₀, F), где Q — множество состояний, Σ — алфавит, δ — функция переходов, q₀ — начальное состояние, F — множество заключительных состояний;
    - начальное состояние q из множества Q;
    - слово w, которое представляется как последовательность символов из алфавита Σ.

    Алгоритм возвращает true, если слово w принадлежит языку, распознаваемому автоматом из состояния q, и false в противном случае. 

    Пошаговое описание алгоритма:
    1. Если слово w пустое (обозначается ε), алгоритм проверяет, принадлежит ли текущее состояние q множеству заключительных состояний F. Если принадлежит, возвращается true; в противном случае возвращается false.
    2. Если слово w непустое, алгоритм разбивает его на первый символ (head(w)) и оставшуюся часть (tail(w)). Затем он вызывает функцию δ, чтобы перейти в следующее состояние на основе текущего состояния q и первого символа head(w). После этого алгоритм рекурсивно вызывает себя для оставшейся части слова tail(w) и нового состояния, полученного после перехода.

    Сложность алгоритма зависит от длины слова w: O(|w|), где |w| — это длина слова.
  author: Шиятов Наиль

- question: >
    Как реализуется операция дополнения языка в детерминированном конечном автомате (сокр. ДКА)?
  answer: > 
    Реализация операции дополнения для детерминированного конечного автомата (сокр. ДКА) предполагает преобразование автомата таким образом, чтобы он принимал все слова, которые не были приняты исходным автоматом. Поскольку ДКА имеет единственный путь для каждого слова, которое принимается только в случае достижения финального состояния, можно поменять местами финальные и нефинальные состояния и добавить состояние-ловушку, если это необходимо, для корректного дополнения.
    Алгоритм предусматривает линейную сложность и включает состояние-ловушку, чтобы гарантировать, что автомат правильно обрабатывает все возможные слова языка. Если автомат не полон (то есть не определены переходы для некоторых символов), добавляется состояние-ловушка, в которое ведут все отсутствующие переходы из каждого состояния.
    Входные данные:
    - Детерминированный конечный автомат A, представленный как (Q, Σ, δ, q₀, F), где Q — множество состояний, Σ — алфавит, δ — функция переходов, q₀ — начальное состояние, а F — множество финальных состояний.

    На выходе:
    - Новый ДКА B, представленный как (Q′, Σ, δ′, q′₀, F′), такой что язык L(B) является дополнением языка L(A).

    Шаги алгоритма:
    1. Установить Q′ = Q, δ′ = δ, q′₀ = q₀ и F′ = ∅.
    2. Если у автомата отсутствуют переходы для некоторых символов в состояниях, добавить новое состояние trap (ловушка) в Q′. Обновить δ′, направив все отсутствующие переходы из каждого состояния в trap.
    3. Для каждого состояния q из Q:
       - Если q не принадлежит F (то есть не является финальным состоянием), добавить q в F′.
    4. Включить trap в F′, чтобы гарантировать, что любое слово, которое не принимается в исходном автомате, будет принято в дополненном автомате.
  author: Шиятов Наиль

- question: >
    Почему операция дополнения для детерминированного конечного автомата (сокр. ДКА) сохраняет минимальность автомата?
  answer: > 
    Операция дополнения для детерминированного конечного автомата (сокр. ДКА) сохраняет минимальность, поскольку каждое состояние дополненного автомата B распознает дополнение языка, который распознавало то же состояние в исходном автомате A. Если состояния исходного автомата A распознают попарно разные языки, то и состояния автомата B также будут распознавать различные языки. В соответствии с критерием минимальности, ДКА является минимальным, если его состояния распознают различные языки, то есть если каждое состояние соответствует уникальному подмножеству языка.
    Однако, если исходный минимальный ДКА был сокращённым (trim), то после дополнения может появиться состояние-ловушка. Для сохранения числа состояний может потребоваться удалить это состояние-ловушку.
  author: Шиятов Наиль

- question: >
    Какова цель и структура универсального алгоритма для выполнения бинарных булевых операций над языками, распознаваемыми детерминированным конечным автоматом (сокр. ДКА)?
  answer: > 
    Цель универсального алгоритма заключается в том, чтобы, принимая два детерминированных конечных автомата (сокр. ДКА), распознающих языки L₁ и L₂, и бинарную булевую операцию (например, объединение, пересечение или разность), возвращать ДКА, распознающий результат применения этой операции к языкам L₁ и L₂.
    Для корректной работы алгоритма с операциями объединения или разности необходимо, чтобы в исходных ДКА явно присутствовали все ловушки (или «непринимающие» состояния). Если ловушка отсутствует, алгоритм может не учесть все возможные переходы, и результат может быть некорректным.
    Алгоритм работает следующим образом:
    
    Вход:
    - ДКА A₁ = (Q₁, Σ, δ₁, q₀₁, F₁)
    - ДКА A₂ = (Q₂, Σ, δ₂, q₀₂, F₂)

    Выход:
    - Новый ДКА A = (Q, Σ, δ, q₀, F), где L(A) — результат бинарной операции L(A₁) ♢ L(A₂)

    Структура алгоритма:
    1. Инициализация:
       - Q, δ, F ← ∅.
       - Начальное состояние q₀ ← [q₀₁, q₀₂].
       - W ← {q₀} — очередь, содержащая начальное состояние.
    2. Пока очередь W не пуста:
       - Извлечь [q₁, q₂] из W.
       - Добавить [q₁, q₂] в Q.
       - Если (q₁ ∈ F₁) ♢ (q₂ ∈ F₂), то добавить [q₁, q₂] в F.
       - Для каждого символа a из алфавита Σ:
         - Вычислить δ₁(q₁, a) и δ₂(q₂, a).
         - Если пара состояний [δ₁(q₁, a), δ₂(q₂, a)] не находится в Q, добавить ее в W.
         - Добавить переход ([q₁, q₂], a, [δ₁(q₁, a), δ₂(q₂, a)]) в δ.

    Логика работы с различными операциями:
    - Для операции объединения (L₁ ∪ L₂) нужно, чтобы каждое состояние переходило в ловушку, если оно не может принять строку, которая не принадлежит ни одному из языков. Поэтому наличие всех ловушек в исходных ДКА обязательно.
    - Для операции пересечения (L₁ ∩ L₂) алгоритм работает аналогично, но состояния будут попадать в финальные только если оба исходных состояния — финальные.
    - Для операции разности (L₁ - L₂) алгоритм требует, чтобы все состояния, которые могут перейти в финальные состояния, но не могут переходить в финальные состояния второго автомата, были учтены и правильно обработаны.

    Этот алгоритм подходит для выполнения любых бинарных операций над языками, распознаваемыми ДКА, с учетом правильной обработки состояния-ловушки для операции объединения и пересечения.
  author: Шиятов Наиль

- question: >
    Каково количество состояний у результирующего детерминированного конечного автомата (сокр. ДКА) при выполнении бинарной булевой операции над двумя ДКА, и в каких случаях минимальность не сохраняется?
  answer: > 
    Количество состояний у результирующего детерминированного конечного автомата (ДКА), полученного в результате выполнения бинарной булевой операции (например, объединения, пересечения или разности) над двумя ДКА, будет O(|Q₁| ⋅ |Q₂|), где |Q₁| и |Q₂| — количество состояний в исходных автоматах A₁ и A₂. Это количество состояний достигается независимо от выполняемой булевой операции, поскольку для каждой пары состояний из A₁ и A₂ создается новое состояние в результирующем автомате.
    Для демонстрации достижимости этого предела рассмотрим алфавит Σ = {a} и язык Multₙ, который включает все слова длиной, кратной n. Минимальный ДКА для этого языка представляет собой цикл из n состояний, где начальное состояние также является единственным заключительным. Если взять два взаимно простых числа n₁ и n₂, то пересечение языков Multₙ₁ и Multₙ₂ будет равно языку Mult(n₁ ⋅ n₂), и минимальный ДКА для этого языка будет иметь не менее n₁ ⋅ n₂ состояний.
    Однако минимальность не сохраняется в общем случае. Например, минимальный ДКА для языка L ∩ L будет иметь только одно состояние, в то время как результат выполнения операции над автоматами (то есть объединения, пересечения или разности) будет иметь количество состояний, равное количеству состояний минимального ДКА для L. Это связано с тем, что операция бинарной булевой операции может привести к увеличению количества состояний, даже если исходные автоматы были минимальными.
    Важно также отметить, что для операции объединения двух ДКА, распознающих взаимно простые языки, результирующий автомат будет иметь количество состояний, равное произведению состояний этих двух автоматов. Это происходит, потому что все возможные комбинации состояний обоих автоматов должны быть учтены, и минимальность при этом не сохраняется из-за природы самой операции объединения.
  author: Шиятов Наиль

- question: >
    Как определяется, что детерминированный конечный автомат (сокр. ДКА) принимает пустой язык, и какова сложность алгоритма проверки?
  answer: > 
    Детерминированный конечный автомат (сокр. ДКА) принимает пустой язык тогда и только тогда, когда у него нет достижимых финальных состояний. Функция Empty(A) определяет, что автомат принимает пустой язык, если множество финальных состояний F пусто и если все финальные состояния недостижимы из начального состояния.

    В случае, когда автомат представлен как кортеж множеств (Q, Σ, δ, q₀, F), проверка на пустой язык сводится к выполнению двух шагов:
    1. Проверка, что множество финальных состояний F пусто.
    2. Проверка, что все финальные состояния недостижимы из начального состояния с помощью обхода графа состояний.
    
    Если финальные состояния F пусты, автомат сразу принимается как принимающий пустой язык. В случае, если F не пусто, алгоритм проверяет, достижимы ли эти состояния из начального состояния.
    Время выполнения зависит от реализации. Если мы храним булевое значение, указывающее, есть ли в ДКА конечное состояние, то сложность функции Empty() составляет O(1). Если для проверки, что F = ∅, требуется линейный обход множества состояний Q, то сложность будет O(|Q|), где |Q| — количество состояний. 
    При этом, поскольку из каждого состояния может исходить лишь константное число переходов, на оценку сложности не влияет размер множества переходов, если размер алфавита считается константным. В случае с недетерминированным конечным автоматом (сокр. НКА) количество переходов могло бы повлиять на сложность, но в ДКА это не так.
  author: Шиятов Наиль

- question: >
    Как определяется, что детерминированный конечный автомат (сокр. ДКА) принимает универсальный язык Σ∗, и какова сложность алгоритма проверки?
  answer: > 
    Детерминированный конечный автомат (сокр. ДКА) принимает универсальный язык Σ* тогда и только тогда, когда все его состояния являются финальными. Автомат принимает универсальный язык, если множество финальных состояний F совпадает с множеством всех состояний Q автомата. Это условие гарантирует, что автомат будет принимать все слова из Σ*, так как любое слово приведет к одному из финальных состояний.
    Если автомат находится в нормальной форме (каждое состояние достижимо из начального), то проверка сводится к проверке равенства множества F и множества Q, что имеет сложность O(1), а также к проверке, что автомат полон (т.е. есть переходы по всем буквам из всех состояний).
    В противном случае, если автомат не находится в нормальной форме, необходимо сначала проверить достижимость состояний, что может потребовать O(|Q|) времени для поиска всех достижимых состояний, где |Q| — это количество состояний автомата. Затем, если все состояния достижимы, проверяется равенство множеств F и Q, что дает сложность O(|Q|).
  author: Шиятов Наиль

- question: >
    Как можно проверить, что язык, распознаваемый одним детерминированным конечным автоматом (сокр. ДКА), является подмножеством языка, распознаваемого другим ДКА?
  answer: > 
    Для проверки того, что язык L(A₁), распознаваемый детерминированным конечным автоматом A₁, является подмножеством языка L(A₂), распознаваемого детерминированным конечным автоматом A₂, используется алгоритм, который строит все возможные комбинации состояний из обоих автоматов (т.е. пары состояний [q₁, q₂], где q₁ — состояние из A₁, а q₂ — состояние из A₂). Затем для каждой такой пары проверяется, что если состояние q₁ является финальным в A₁ (q₁ ∈ F₁), то состояние q₂ должно быть финальным в A₂ (q₂ ∈ F₂). Если находится хотя бы одна пара, где q₁ является финальным состоянием в A₁, а q₂ не является финальным в A₂, то алгоритм возвращает false, что означает, что L(A₁) не является подмножеством L(A₂). В противном случае, если таких пар не найдено, алгоритм возвращает true, подтверждая, что L(A₁) является подмножеством L(A₂).
  author: Шиятов Наиль

- question: >
    Как проверяется равенство языков двух детерминированных конечных автоматов (сокр. ДКА)?
  answer: > 
    Равенство языков двух детерминированных конечных автоматов (сокр. ДКА) L(A₁) = L(A₂) проверяется с помощью симметрической разности L(A₁) Δ L(A₂). Если симметрическая разность пуста, то языки равны. Алгоритм проверки равенства двух языков модифицирует алгоритм проверки включения языков, проверяя, что для состояний [q₁, q₂] выполняется одно из следующих условий: если q₁ ∈ F₁ и q₂ ∉ F₂, или если q₁ ∉ F₁ и q₂ ∈ F₂, то возвращается false, что означает, что языки не равны. В противном случае возвращается true.
    Назовём такой алгоритм стандартным алгоритмом проверки равенства языков двух ДКА.
  author: Шиятов Наиль

- question: >
    Какой альтернативный подход существует для проверки равенства двух детерминированных конечных автоматов (сокр. ДКА), помимо алгоритма стандартного алгоритма проверки равенства языков двух ДКА?
  answer: > 
    Альтернативный подход заключается в минимизации двух детерминированных конечных автоматов (сокр. ДКА) A₁ и A₂, а затем проверке, являются ли они изоморфными. Проверка изоморфизма может быть пропущена, если применить алгоритм бисимуляции (англ. CSR, coarsest stable refinement) к объединению двух недетерминированных конечных автоматов (сокр. НКА) A₁ ∪ A₂ и разделить состояния на блоки. Языки равны, если начальные состояния обоих автоматов находятся в одном блоке после завершения алгоритма.
  author: Шиятов Наиль

- question: >
    Какая сложность проверки равенства языков двух детерминированных конечных автоматов (сокр. ДКА) с использованием алгоритма Хопкрофта для вычисления бисимуляции (англ. CSR, coarsest stable refinement)?
  answer: > 
    Если используется алгоритм Хопкрофта для вычисления бисимуляции (англ. CSR, coarsest stable refinement), то проверка равенства языков может быть выполнена за время O(n log n), где n — это сумма состояний автоматов A₁ и A₂.
  author: Шиятов Наиль

- question: >
    Какие преимущества имеет стандартный алгоритм проверки равенства двух детерминированных конечных автоматов (сокр. ДКА) по сравнению с методом минимизации автоматов для проверки равенства языков?
  answer: > 
    Первое преимущество заключается в том, что стандартный алгоритм проверки равенства языков двух детерминированных конечных автоматов (сокр. ДКА) A₁ и A₂ работает "на лету" (on-the-fly). Это позволяет проверять равенство языков L(A₁) и L(A₂) ещё на этапе их построения и прерывать выполнение при обнаружении различий. Второе преимущество — возможность модифицировать алгоритм так, чтобы он возвращал контрпример (witness) — слово, принадлежащее симметрической разности L(A₁) и L(A₂), если языки не равны.
  author: Шиятов Наиль

- question: >
    Какие 4 компонента образуют контекстно-свободную грамматику?
  answer: >
    Контекстно-свободную грамматику (CFG) образуют 
    1. Алфавит (Σ) (англ. terminals): Набор терминальных символов, из которых формируются строки языка. Эти символы не подлежат дальнейшей замене. Терминалы обозначаются строчными буквами из начала латинского алфавита (например: a,b,c).
    2. Нетерминальные символы (синтаксические категории) (N) (англ. nonterminals): Символы, которые могут быть заменены другими символами или последовательностями символов. Каждый нетерминальный символ представляет язык, т.е. множество цепочек. Нетерминалы обозначаются заглавными буквами латинского алфавита (например: A,B,C).
    3. Начальный символ (S) (англ. start symbol): Один из нетерминальных символов, который используется в качестве точки начала для генерации строк языка. Другие переменные представляют дополнительные классы цепочек, которые помогают определить язык, заданный стартовым символом. Обычно обозначается буквой S, но может быть любым другим нетерминальным
    символом. 
    4. Правила продукции (P) (англ. production rules или productions): Набор правил, определяющих, как нетерминальные символы могут быть заменены на терминальные или другие нетерминальные символы. Каждое правило имеет вид A → α, где A — нетерминальный символ, а α — конечная цепочка, состоящая из терминалов и переменных, возможно, пустая. Она называется телом продукции и представляет способ образования цепочек языка, обозначаемого переменной в голове. По этому способу мы оставляем терминалы неизменными и вместо каждой переменной в теле подставляем любую цепочку, про которую известно, что она принадлежит языку этой переменной.
  author: Проклашкина Софья
  
- question: >
    Является ли множество цепочек сбалансированных скобок регулярным языком?
  answer: >
    Нет, множество цепочек сбалансированных скобок не является регулярным языком. Чтобы строка со скобками была сбалансированной, количество открывающих и закрывающих скобок должно совпадать, и в любом префиксе строки количество закрывающих скобок не должно превышать количество открывающих. Конечные автоматы не могут отслеживать количество открывающих и закрывающих скобок на произвольной глубине вложенности. Это связано с тем, что они имеют фиксированное количество состояний и не могут «помнить» количество открытых скобок, если оно превышает это количество состояний. 
    Доказательство с помощью леммы о накачке: Если бы L(G), где G - грамматика, порождающая все цепочки сбалансированных скобок, был регулярным, то для него по лемме о накачке для регулярных языков существовала бы константа n. Рассмотрим сбалансированную цепочку w = '('^n')'^n, т.е. n левых скобок, за которыми следуют n правых. Если разбить W = xyz в соответствии с леммой, то у состоит только из левых скобок, и цепочка хz содержит больше правых скобок, чем левых. Эта цепочка несбалансированна, т.е. получено противоречие с предположением, что язык сбалансированных скобок регулярен. Таким образом, множество цепочек сбалансированных скобок является контекстно-свободным языком (который может быть описан с помощью контекстно-свободных грамматик), но не является регулярным языком.
  author: Проклашкина Софья
  
- question: >
    Как получить контекстно-свободную грамматику без бесполезных символов?
  answer: >
    Пусть G = (V, T, P, S) - КС (контекстно-свободная) грамматика, где V - множество переменных, T - терминалов, P - продукций, S - стартовый символ и G порождает хотя бы одну цепочку.
    Пусть G_1 = (V_1, T_1, P_1, S_1) - грамматика, полученная с помощью следующих двух шагов: 
    1. Удаляются непорождающие символы и все продукции, содержащие один или несколько таких символов. Пусть G_2 = (V_2, T_2, Р_2, S_2) - полученная в результате грамматика. Заметим, что S должен быть порождающим, так как по предположению L(G) содержит хотя бы одну цепочку, поэтому S не удаляется. 
    2. Затем удаляются все символы, недостижимые в G1. Тогда G1, не имеет бесполезных символов, и L(G1) = L(G), L - язык, задаваемый грамматикой G
  author: Проклашкина Софья
  
- question: >
    Что такое цепная пара в контекстно-свободных языках?
  answer: >
    Цепная пара (unit pair) - это пара (A, B), для которой A → B получается с использованием лишь цепных продукций. Цепная продукция (unit rule) - правило вида A → B, где A и B — нетерминалы.
  author: Проклашкина Софья
  
- question: >
    Какой смысл нормальной формы Хомского?
  answer: >
    Польза нормальной формы Хомского (CNF) в следующих аспектах: 
    - Неукорачивающие применения правил. (Грамматика называется неукорачивающей, если для всех её продукций α → β (где α и β — строки нетерминальных и терминальных символов) выполняется неравенство |α| ≤ |β|, то есть β имеет не менее как столько же символов, сколько α.)
    - Нет пустых переходов - правила либо финальные, либо удлиняющие; 
    - Контролируемый рост длины сентенциальной формы от количества шагов разбора. Сентенциальная форма (англ. Sentential form) — последовательность терминалов и нетерминалов, выводимых из начального символа. При каждом шаге разбора:
    	• Если применяется правило  A → BC , то длина строки не меняется.
    	• Если применяется правило  A → a , то длина строки увеличивается на 1.
   	  Таким образом, если у нас есть  n  шагов разбора, то максимальная длина результирующей строки может составлять  n  (если все шаги — это замены на терминалы). Поскольку каждое правило контролирует, как именно происходит увеличение длины строки, можно сказать, что количество шагов разбора прямо пропорционально длине итоговой строки. Это позволяет предсказать, как будет расти длина строки в зависимости от числа примененных правил.
    - Перевод грамматики в нормальную форму Хомского (CNF) позволяет легче анализировать свойства её языка и проводить разбор слов. (Использование CNF позволяет применять алгоритмы синтаксического анализа, такие как алгоритм CYK (Cocke-Younger-Kasami), которые работают эффективно и имеют полиномиальную временную сложность. При работе с грамматиками в НФХ становится проще доказывать различные свойства, такие как выводимость строк или принадлежность строк языку, благодаря унифицированной структуре правил)
  author: Проклашкина Софья
  
- question: >
    Что такое крона дерева разбора грамматики?
  answer: >
    Крона дерева разбора (англ. leaves of the parse tree) - множество терминальных символов, упорядоченное в соответствии с номерами их достижения при обходе дерева в глубину из корня. Крона дерева разбора представляет из себя слово языка, которое выводит это дерево.
  author: Проклашкина Софья
  
- question: >
    Что такое однозначная грамматика?
  answer: >
    Грамматика называется однозначной (англ. unambiguous grammar), если у каждого слова имеется не более одного дерева разбора в этой грамматике, то есть существует только один способ разбора. 
    Существуют языки, которые можно задать одновременно как однозначными, так и неоднозначными грамматиками. Однако, есть контекстно-свободные языки, для которых не существует однозначных контекстно-свободных грамматик. Такие языки и грамматики их порождающие называют существенно неоднозначными (англ. inherently ambiguous language).
  author: Проклашкина Софья
  
- question: >
    Что такое нормальная форма Куроды?
  answer: >
    Грамматика представлена в нормальной форме Куроды (англ. Kuroda normal
    form), если каждое правило имеет одну из четырех форм: 
    1. AB → CD; 
    2. A → BC; 
    3. A → B; 
    4. A → a или A → ε. 
    Здесь A, B, C, D — нетерминалы, a a — терминал.
  author: Проклашкина Софья
  
- question: >
    Что такое нормальная форма Пенттонена?
  answer: >
    Грамматика представлена в нормальной форме Пенттонена (англ. Penttonen normal form), если каждое правило имеет одну из трех форм: 
    1. AB → AC; 
    2. A → BC; 
    3. A → a или A → ε; 
    Здесь A, B, C, D — нетерминалы, a a — терминал. 
    Также грамматику Пенттонена называют односторонней нормальной формой (англ. one-sided normal form). Она является частным случаем нормальной формы Куроды: когда A = C в первом правиле определения. Для каждой контестно-зависимой грамматики существует слабо эквивалентная ей грамматика в форме Пенттонена. Слабая эквивалентность двух грамматик означает, что они генерируют один и тот же набор строк, т.е. язык, который они задают, один и тот же.
  author: Проклашкина Софья
  
- question: >
    Когда контекстно-свободная грамматика не содержит бесполезных нетерминалов?
  answer: >
    Грамматика G не содержит бесполезных нетерминалов тогда и только тогда, когда грамматика G не содержит ни недостижимых нетерминалов (нетерминал A называется достижимым (англ. reachable) в контекстно-свободной грамматике G, если существует порождение S → αAβ), ни
    непорождающих (Нетерминал A называется порождающим (англ. generating), если из него может быть выведена конечная терминальная цепочка).
  author: Проклашкина Софья
  
- question: >
    В чем практическая польза нормальной формы Грейбах?
  answer: >
    Грамматика представлена в нормальной форме Грейбах (GNF) (англ. Greibach normal form), если каждое ее правило имеет вид A_i → a_j α, где A_i ∈ N, α ∈ N*, a_j ∈ Σ.
    Использование нормальной формы Грейбах позволяет доказать, что для каждого контекстно-свободного языка (не содержащего ε) существует автомат с магазинной памятью без переходов по ε, а также позволяет использовать для разбора метод рекурсивного спуска, сложность которого является линейной (так как каждое использование продукции вводит ровно один терминал в выводимую цепочку, цепочка длины n порождается в точности за n шагов)
  author: Проклашкина Софья
  
- question: >
    Опиши иерархию грамматик Хомского
  answer: >
    Класс 0: К нулевому классу относятся все формальные грамматики. Элементы этого класса называются неограниченными грамматиками (англ. unrestricted grammars), поскольку на них не накладывается никаких ограничений. Они задают все языки, которые могут быть распознаны машиной Тьюринга. Эти языки также известны как рекурсивно перечислимые (англ. recursively enumerable) - язык, для которого существует программа g такая, что g(i)=x_i, L = {x_1, x_2, .. , x_n, ..}
    Класс 1: Первый класс представлен неукорачивающими (неукорачивающая грамматика (англ. noncontracting grammar) — это формальная грамматика, всякое правило из P которой имеет вид α → β, где α, β ∈ {Σ∪N}+ и |α|⩽|β| (возможно правило S → ε, но тогда S не встречается в правых частях правил)) и контекстно-зависимыми грамматиками (контекстно-зависимая грамматика (англ. context-sensitive grammar) — это формальная грамматика, всякое правило из P которой имеет вид αAβ → αγβ, где α, β ∈ {Σ∪N}*, A ∈ N и γ ∈ {Σ∪N}+ (возможно правило S→ε, но тогда S не встречается в правых частях правил)).
    Языки, заданные этими грамматиками, распознаются с помощью линейно ограниченного автомата (англ. linear bounded automaton) (недетерминированная машина Тьюринга, чья лента ограничена константой, зависящей от длины входа.) Известно, что неукорачивающие грамматики эквивалентны контекстно-зависимым. 
    Класс 2: Второй класс составляют контекстно-свободные грамматики, которые задают контекстно-свободные языки. Эти языки распознаются с помощью автоматов с магазинной памятью. 
    Класс 3: К третьему типу относятся автоматные или регулярные грамматики (англ. regular grammars) — самые простые из формальных грамматик, которые задают регулярные языки. Они являются контекстно-свободными, но с ограниченными возможностями.
  author: Проклашкина Софья
