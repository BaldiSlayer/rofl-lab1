- question: Что представляет собой язык, распознаваемый недетерминированным конечным автоматом (НКА)?
  answer: > 
    Язык, распознаваемый недетерминированным конечным автоматом (НКА) – это все такие слова, 
    по которым существует хотя бы один путь из стартовой вершины в терминальную.
  author: Лисов Алексей

- question: Дан регулярный язык, опиши алгоритм нахождения кратчайшего слова, принадлежащего этому регулярному языку
  answer: > 
    Регулярный язык может быть задан с помощью конечного автомата. 
    Так как автомат конечен, то мы можем его обойти (пройти через все состояния) за конечное время. 
    Так как нам нужно найти самое короткое слово, то эта задача сводится к тому, что нам необходимо 
    найти кратчайший путь от стартовой вершины до какой-либо терминальной. По определению это 
    можно сделать с помощью поиска в ширину (bfs, breadth-first search). Поиск в ширину - алгоритм, находящий 
    все кратчайшие пути от заданной вершины в невзвешенном графе. Запускаем поиск в ширину и выйдем из него, 
    когда пришли в терминальное состояние. Так как нам нужно явно найти кратчайшее слово, то после этого делаем 
    восстановление ответа. Это можно сделать используя дополнительную структуру данных (например массив prev), для того, 
    чтобы для каждого состояния v хранить состояние u, из которого мы в него пришли. Мы можем пройти от найденной 
    вершины по массиву prev, пока не придем в начальное состояние. Записав все переходы мы получим кратчайшее слово, 
    принадлежащее регулярному языку.
  author: Лисов Алексей

- question: Опиши алгоритм подсчета количества слов определенной длины в заданном регулярном языке
  answer: > 
    Обозначим регулярный язык за L и пусть длина слов, количество которых мы хотим найти - l.
    Так как язык L регулярен, то мы можем построить соответствующий ему конечный автомат A.
    Решим задачу с помощью динамического программирования. Пусть a_(q,i) – количество слов длины i, переводящих 
    автомат A из начального состояния q0 в состояние q. 
    Чтобы пересчитать эту величину, нужно просуммировать значения динамического программирования
    из предыдущего по длине слоя для всех состояний, из которых есть ребро в состояние q. Ответом является
    сумма элементов столбца, отвечающего за длину l, соответствующих терминальным вершинам.
  author: Лисов Алексей

- question: Какими являются языки недетерминированных автоматов с магазинной памятью?
  answer: > 
    Языки недетерминированных автоматов с магазинной памятью являются контекстно-свободными.
    То есть эти языки могут быть заданы с помощью контекстно свободных грамматик.
  author: Лисов Алексей

- question: Какая структура данных может описать магазинную память у автомата с магазинной памятью?
  answer: Магазинная память у автомата с магазинной памятью является стеком.
  author: Лисов Алексей

- question: Опиши алгоритм нахождения эпсилон замыкания для каждой из вершин автомата?
  answer: >
    ε-замыкание состояния q – это множество состояний, достижимых из q только по ε-переходам. 
    Соотсветственно эпсилон замыкание для каждой из вершин автомата можно предподсчитать с помощью поиска в глубину 
    (dfs) для каждой вершины.
  author: Лисов Алексей

- question: Дай определение произведения двух автоматов
  answer: >
    Прямым произведением двух ДКА A1=⟨Σ1,Q1,s1,T1,δ1⟩ и A2=⟨Σ2,Q2,s2,T2,δ2⟩ называется ДКА 
    A=⟨Σ,Q,s,T,δ⟩, где: 
    1) Σ = Σ1∪Σ2, то есть он работает над пересечением алфавитов двух данных автоматов 
    2) Q = Q1×Q2, множество пар состояниий включает в себя состояния обоих автоматов 
    3) s =⟨s1,s2), стартуем с символов в обоих автоматах 
    4) T=T1×T2, терминальные состояния включают в себя терминальные состояния обоих автоматов 
    5) δ(⟨q1,q2⟩,c)=⟨δ1(q1,c),δ2(q2,c)⟩, то есть переходим по символу в обоих автоматах"
  author: Лисов Алексей

- question: Как из недетерминированного конечного автомата A сделать pushdown automat B?
  answer: >
    Для этого нужно заменить переход из состояния q в состояние p по символу x на такой же переход, 
    только добавить z_0/z_0, где z_0 это дно стека. Из этого следует, что регулярные языки являются подмножеством 
    МП-автоматных языков (языков автоматов с магазинной памятью).
  author: Лисов Алексей

- question: Теорема Клини
  answer: >
    Теорема Клини гласит о том, что множество языков, принимаемых детерминированным конечным автоматом совпадает с 
    множеством языком, принимаемых академическим регулярным выражением.
  author: Лисов Алексей

- question: Какой язык называется префиксным (беспрефиксным)
  answer: > 
    Язык L называется префиксным, если для любого w не равного v из L не верно, что w – префикс v. Также такие языки
    называют беспрефиксными.
  author: Лисов Алексей

- question: >
    Что можно сказать о языке L, который принимается детерминированным конечным автоматом 
    с магазинной памятью по пустому стеку
  answer: > 
    Это значит, что язык L принимается детерминированным конечным автоматом с магазинной памятью по терминальному 
    состоянию, а также язык L – префиксный
  author: Лисов Алексей

- question: >
    Является ли регулярным язык Дика?
    (множество правильных скобочных структур вместе с пустой структурой, образующее язык над алфавитом {a,b}.)
  answer: > 
    Язык Дика не является регулярным.
    Докажем с помощью леммы о накачке. Предположим, что он регулярный, тогда по лемме о накачке существует 
    n с вышеописанными свойствами. Возьмём последовательность из n открывающих, а затем n закрывающих скобок. 
    Для неё существуют соответствующие x,y,z из леммы о накачке. Но так как |xy| <= n, то y 
    состоит только из открывающих скобок,  причём по условию леммы y не пустая. А значит при i = 2 в строке xy^iz 
    получится больше открывающих скобок, чем закрывающих, то есть это будет не правильной скобочной последовательностью. 
    Получили противоречие. Следовательно язык Дика не является регулярным.
  author: Лисов Алексей

- question: >
    Как реализуется алгоритм для проверки принадлежности слова w к языку L в ДКА?
  answer: > 
    Обозначив head(aw) = a и tail(aw) = w для a ∈ Σ и w ∈ Σ*, алгоритм выглядит следующим образом: MemDFA[A](w, q) Вход: ДКА A = (Q, Σ, δ, q0, F), состояние q ∈ Q, слово w ∈ Σ* Выход: Возвращает true, если w ∈ L(q), иначе false 1. Если w = ε, то возвращает q ∈ F 2. Иначе возвращает Member[A](δ(q, head(w)), tail(w)) Сложность алгоритма: O(|w|)
  author: Шиятов Наиль

- question: >
    Как реализуется операция дополнения языка в ДКА?
  answer: > 
    Реализация операции дополнения для ДКА проста. Поскольку ДКА имеет единственный прогон для каждого слова, который принимается, если автомат достигает заключительного состояния, можно просто поменять местами заключительные и незаключительные состояния. Таким образом, если слово не принималось в исходном автомате, оно будет принято в дополненном автомате, и наоборот. Этот алгоритм имеет линейную сложность:
    Вход: ДКА A = (Q, Σ, δ, q₀, F)  
    Выход: ДКА B = (Q′, Σ, δ′, q′₀, F′) с L(B) = L(A)̅
    1. Q′ ← Q; δ′ ← δ; q′₀ ← q₀; F′ ← ∅
    2. Для всех q ∈ Q:
      - Если q ∉ F, добавить q в F′
  author: Шиятов Наиль

- question: >
    Почему операция дополнения для ДКА сохраняет минимальность автомата?
  answer: > 
    Операция дополнения для ДКА сохраняет минимальность, потому что каждое состояние дополненного автомата Comp(A) распознаёт дополнение языка, которое распознавало то же состояние в исходном автомате A. Если состояния исходного автомата A распознают попарно разные языки, то и состояния автомата Comp(A) также будут распознавать разные языки. Согласно следствию, ДКА минимален, если его состояния распознают различные языки.
  author: Шиятов Наиль

- question: >
    Какова цель и структура универсального алгоритма для выполнения бинарных булевых операций над языками, распознаваемыми ДКА?
  answer: > 
    Цель универсального алгоритма заключается в том, чтобы, принимая два ДКА, распознающих языки L₁ и L₂, и бинарную булевую операцию, возвращать ДКА, распознающий результат применения этой операции к языкам L₁ и L₂. Алгоритм обозначается как BinOp[♢](A₁, A₂).
    Вход: ДКА A₁ = (Q₁, Σ, δ₁, q₀₁, F₁), A₂ = (Q₂, Σ, δ₂, q₀₂, F₂)  
    Выход: ДКА A = (Q, Σ, δ, Q₀, F) с L(A) = L(A₁) ♢ L(A₂)
    1. Q, δ, F ← ∅
    2. q₀ ← [q₀₁, q₀₂]
    3. W ← {q₀}
    4. пока W ≠ ∅ делай
       - выбрать [q₁, q₂] из W
       - добавить [q₁, q₂] в Q
       - если (q₁ ∈ F₁) ♢ (q₂ ∈ F₂), то добавить [q₁, q₂] в F
       - для каждого a ∈ Σ делай
          - q₀₁ ← δ₁(q₁, a); q₀₂ ← δ₂(q₂, a)
          - если [q₀₁, q₀₂] ∉ Q, то добавить [q₀₁, q₀₂] в W
          - добавить ([q₁, q₂], a, [q₀₁, q₀₂]) в δ
  author: Шиятов Наиль

- question: >
    Каково количество состояний у результирующего ДКА при выполнении бинарной булевой операции над двумя ДКА, и в каких случаях минимальность не сохраняется?
  answer: > 
    Выходной детерминированный конечный автомат (ДКА) от алгоритма BinOp будет иметь O(|Q₁| ⋅ |Q₂|) состояний, независимо от выполняемой булевой операции. Для демонстрации достижимости этого предела можно рассмотреть алфавит Σ = {a} и язык Multₙ, который включает слова длиной, кратной n. Минимальный ДКА для языка Multₙ представляет собой цикл из n состояний, где начальное состояние также является единственным заключительным. Для любых двух взаимно простых чисел n₁ и n₂ выполняется равенство Multₙ₁ ∩ Multₙ₂ = Mult(n₁ ⋅ n₂), что означает, что ДКА для Mult(n₁ ⋅ n₂) будет иметь не менее n₁ ⋅ n₂ состояний. Однако в общем случае минимальность не сохраняется: произведение двух минимальных ДКА может не быть минимальным. Например, минимальный ДКА для регулярного языка L ∩ L имеет одно состояние, в то время как результат построения произведения будет иметь то же количество состояний, что и минимальный ДКА для L.
  author: Шиятов Наиль

- question: >
    Как определяется, что ДКА принимает пустой язык, и какова сложность алгоритма проверки?
  answer: > 
    ДКА принимает пустой язык тогда и только тогда, когда у него нет заключительных состояний. Алгоритм Empty(A) возвращает true, если множество заключительных состояний F пусто, и false в противном случае. Если в реализации используется булевая переменная для хранения информации о наличии заключительных состояний, то сложность алгоритма составляет O(1). Если требуется выполнить линейный поиск по множеству состояний, чтобы проверить F = ∅, то сложность будет O(|Q|), где |Q| — это количество состояний автомата.
  author: Шиятов Наиль

- question: >
    Как определяется, что ДКА принимает универсальный язык Σ∗, и какова сложность алгоритма проверки?
  answer: > 
    ДКА принимает универсальный язык Σ* тогда и только тогда, когда все его состояния являются заключительными. Алгоритм UnivDFA(A) возвращает true, если множество заключительных состояний F совпадает с множеством всех состояний Q. Если автомат находится в нормальной форме, сложность алгоритма составляет O(1). В противном случае сложность будет O(|Q|), где |Q| — это количество состояний автомата.
  author: Шиятов Наиль

- question: >
    Как алгоритм проверяет, что язык, распознаваемый одним ДКА, является подмножеством языка, распознаваемого другим ДКА?
  answer: > 
    Алгоритм проверяет, что язык L(A₁), распознаваемый ДКА A₁, является подмножеством языка L(A₂), распознаваемого ДКА A₂, с помощью построения параллельного автомата [A₁, A₂]. Для каждого состояния [q₁, q₂] автомата проверяется, что если состояние q₁ заключительное в A₁ (q₁ ∈ F₁), то q₂ также должно быть заключительным в A₂ (q₂ ∈ F₂). Если найдено состояние, где q₁ ∈ F₁, а q₂ ∉ F₂, алгоритм возвращает false, что означает, что L(A₁) ⊈ L(A₂). В противном случае, если таких состояний не найдено, алгоритм возвращает true, подтверждая, что L(A₁) ⊆ L(A₂). Сложность алгоритма зависит от количества состояний и алфавита.
  author: Шиятов Наиль

- question: >
    Как проверяется равенство языков двух ДКА?
  answer: > 
    Равенство языков двух ДКА L(A₁) = L(A₂) проверяется с помощью симметрической разности L(A₁) Δ L(A₂). Если симметрическая разность пуста, то языки равны. Алгоритм EqDFA модифицирует алгоритм InclDFA, проверяя, что для состояний [q₁, q₂] выполняется одно из следующих условий: если q₁ ∈ F₁ и q₂ ∉ F₂, или если q₁ ∉ F₁ и q₂ ∈ F₂, то возвращается false, что означает, что языки не равны. В противном случае возвращается true.
  author: Шиятов Наиль

- question: >
    Какой альтернативный подход существует для проверки равенства двух ДКА, помимо алгоритма EqDFA?
  answer: > 
    Альтернативный подход заключается в минимизации двух ДКА A₁ и A₂, а затем проверке, являются ли они изоморфными. Проверка изоморфизма может быть пропущена, если применить алгоритм CSR к объединению двух НКА A₁ ∪ A₂ и разделить состояния на блоки. Языки равны, если начальные состояния обоих автоматов находятся в одном блоке после завершения алгоритма.
  author: Шиятов Наиль

- question: >
    Какая сложность проверки равенства языков двух ДКА с использованием алгоритма Хопкрофта для вычисления CSR?
  answer: > 
    Если используется алгоритм Хопкрофта для вычисления CSR, то проверка равенства языков может быть выполнена за время O(n log n), где n — это сумма состояний автоматов A₁ и A₂.
  author: Шиятов Наиль

- question: >
    Какие два важных преимущества имеет алгоритм EqDFA по сравнению с минимизацией автоматов?
  answer: > 
    Первое преимущество заключается в том, что алгоритм EqDFA работает "на лету" (on-the-fly), позволяя тестировать равенство языков, пока строятся автоматы A₁ и A₂, и останавливать работу при нахождении различий. Второе преимущество — это возможность модифицировать EqDFA так, чтобы он возвращал свидетельство (witness), то есть слово, которое находится в симметрической разности L(A₁) и L(A₂), если языки не равны.
  author: Шиятов Наиль