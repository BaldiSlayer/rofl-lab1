- question: Что представляет собой язык, распознаваемый недетерминированным конечным автоматом (НКА)?
  answer: > 
    Язык, распознаваемый недетерминированным конечным автоматом (НКА) – это все такие слова, 
    по которым существует хотя бы один путь из стартовой вершины в терминальную.
  author: Лисов Алексей

- question: Дан регулярный язык, опиши алгоритм нахождения кратчайшего слова, принадлежащего этому регулярному языку
  answer: > 
    Регулярный язык может быть задан с помощью конечного автомата. 
    Так как автомат конечен, то мы можем его обойти (пройти через все состояния) за конечное время. 
    Так как нам нужно найти самое короткое слово, то эта задача сводится к тому, что нам необходимо 
    найти кратчайший путь от стартовой вершины до какой-либо терминальной. По определению это 
    можно сделать с помощью поиска в ширину (bfs, breadth-first search). Поиск в ширину - алгоритм, находящий 
    все кратчайшие пути от заданной вершины в невзвешенном графе. Запускаем поиск в ширину и выйдем из него, 
    когда пришли в терминальное состояние. Так как нам нужно явно найти кратчайшее слово, то после этого делаем 
    восстановление ответа. Это можно сделать используя дополнительную структуру данных (например массив prev), для того, 
    чтобы для каждого состояния v хранить состояние u, из которого мы в него пришли. Мы можем пройти от найденной 
    вершины по массиву prev, пока не придем в начальное состояние. Записав все переходы мы получим кратчайшее слово, 
    принадлежащее регулярному языку.
  author: Лисов Алексей

- question: Опиши алгоритм подсчета количества слов определенной длины в заданном регулярном языке
  answer: > 
    Обозначим регулярный язык за L и пусть длина слов, количество которых мы хотим найти - l.
    Так как язык L регулярен, то мы можем построить соответствующий ему конечный автомат A.
    Решим задачу с помощью динамического программирования. Пусть a_(q,i) – количество слов длины i, переводящих 
    автомат A из начального состояния q0 в состояние q. 
    Чтобы пересчитать эту величину, нужно просуммировать значения динамического программирования
    из предыдущего по длине слоя для всех состояний, из которых есть ребро в состояние q. Ответом является
    сумма элементов столбца, отвечающего за длину l, соответствующих терминальным вершинам.
  author: Лисов Алексей

- question: Какими являются языки недетерминированных автоматов с магазинной памятью?
  answer: > 
    Языки недетерминированных автоматов с магазинной памятью являются контекстно-свободными.
    То есть эти языки могут быть заданы с помощью контекстно свободных грамматик.
  author: Лисов Алексей

- question: Какая структура данных может описать магазинную память у автомата с магазинной памятью?
  answer: Магазинная память у автомата с магазинной памятью является стеком.
  author: Лисов Алексей

- question: Опиши алгоритм нахождения эпсилон замыкания для каждой из вершин автомата?
  answer: >
    ε-замыкание состояния q – это множество состояний, достижимых из q только по ε-переходам. 
    Соотсветственно эпсилон замыкание для каждой из вершин автомата можно предподсчитать с помощью поиска в глубину 
    (dfs) для каждой вершины.
  author: Лисов Алексей

- question: Дай определение произведения двух автоматов
  answer: >
    Прямым произведением двух ДКА A1=⟨Σ1,Q1,s1,T1,δ1⟩ и A2=⟨Σ2,Q2,s2,T2,δ2⟩ называется ДКА 
    A=⟨Σ,Q,s,T,δ⟩, где: 
    1) Σ = Σ1∪Σ2, то есть он работает над пересечением алфавитов двух данных автоматов 
    2) Q = Q1×Q2, множество пар состояниий включает в себя состояния обоих автоматов 
    3) s =⟨s1,s2), стартуем с символов в обоих автоматах 
    4) T=T1×T2, терминальные состояния включают в себя терминальные состояния обоих автоматов 
    5) δ(⟨q1,q2⟩,c)=⟨δ1(q1,c),δ2(q2,c)⟩, то есть переходим по символу в обоих автоматах"
  author: Лисов Алексей

- question: Как из недетерминированного конечного автомата A сделать pushdown automat B?
  answer: >
    Для этого нужно заменить переход из состояния q в состояние p по символу x на такой же переход, 
    только добавить z_0/z_0, где z_0 это дно стека. Из этого следует, что регулярные языки являются подмножеством 
    МП-автоматных языков (языков автоматов с магазинной памятью).
  author: Лисов Алексей

- question: Теорема Клини
  answer: >
    Теорема Клини гласит о том, что множество языков, принимаемых детерминированным конечным автоматом совпадает с 
    множеством языком, принимаемых академическим регулярным выражением.
  author: Лисов Алексей

- question: Какой язык называется префиксным (беспрефиксным)
  answer: > 
    Язык L называется префиксным, если для любого w не равного v из L не верно, что w – префикс v. Также такие языки
    называют беспрефиксными.
  author: Лисов Алексей

- question: >
    Что можно сказать о языке L, который принимается детерминированным конечным автоматом 
    с магазинной памятью по пустому стеку
  answer: > 
    Это значит, что язык L принимается детерминированным конечным автоматом с магазинной памятью по терминальному 
    состоянию, а также язык L – префиксный
  author: Лисов Алексей

- question: >
    Является ли регулярным язык Дика с единственным типом скобок?
    (язык Дика - множество правильных скобочных структур вместе с пустой структурой, 
    образующее язык над алфавитом {a,b}.)
  answer: > 
    Язык Дика не является регулярным.
    Докажем с помощью леммы о накачке. Предположим, что он регулярный, тогда по лемме о накачке существует 
    n, являющееся длиной накачки. Возьмём последовательность из n открывающих, а затем n закрывающих скобок. 
    Для неё существуют соответствующие x, y, z из леммы о накачке. Но так как |xy| <= n, то y 
    состоит только из открывающих скобок, причём по условию леммы y не пустая. А значит при i = 2 в строке xy^iz 
    получится больше открывающих скобок, чем закрывающих, то есть это будет не правильной скобочной последовательностью. 
    Получили противоречие. Следовательно язык Дика с единственным типом скобок не является регулярным.
  author: Лисов Алексей

- question: >
    Является ли контекстно-свободным языком разность контекстно-свободного и регулярного языка?
  answer: > 
    Да, разность контекстно-свободного и регулярного языка является контекстно-свободным языком.
  author: Лисов Алексей


- question: >
    В хорошо написанном регулярном выражении должны быть сбалансированы какие факторы?
  answer: >
    В хорошо написанном регулярном выражении должны быть сбалансированы несколько факторов:
     • Регулярное выражение должно находить именно те фрагменты текста, которые соответствуют заданным условиям. В зависимости от задачи, подход может различаться: например, fullmatch проверяет полное совпадение всей строки с выражением, в то время как search подходит для нахождения фрагментов внутри строки. Такое разграничение позволяет выбирать правильный метод для каждой задачи, будь то полное соответствие или частичное.
     • Регулярное выражение должно оставаться понятным и легким для поддержки. Сложные, трудно читаемые выражения могут затруднить их использование и усложнить внесение изменений, повышая риск ошибок.
     • При использовании механизма недетерминированного конечного автомата (НКА) выражение должно быть эффективно и приводить к быстрому результату. Однако стоит учитывать, что конструкции с итерацией Клини (* и +) особенно в начале выражения могут усилить недетерминизм, что повышает вероятность долгого перебора вариантов и ухудшает производительность. Хорошо составленное регулярное выражение должно минимизировать такие конструкции, если это возможно, чтобы избежать избыточной сложности и не затягивать обработку.
  author: Еделькин Герман

- question: >
    Какие возможности механизм НКА может поддерживать, недоступные для ДКА? (в конетексте регулярных выражений и языков)
  answer: >
    Механизм недетерминированного конечного автомата (НКА) обладает рядом возможностей, недоступных для детерминированного конечного автомата (ДКА), что делает его более гибким и мощным инструментом для работы с регулярными выражениями: 
    1. Возможность использовать захваченную строку по имени группы вне регулярного выражения: НКА поддерживает возможность захвата текста, заключённого в круглые скобки в регулярном выражении, и использования этих захваченных фрагментов в дальнейшем, что позволяет гибко работать с результатами сопоставлений.
    2. Позиционные и сложные проверки с нулевой длиной совпадения: НКА может выполнять позиционные проверки (например, проверки начала или конца строки) и другие сложные проверки, не требующие дополнительных символов для совпадения. 
    3. Минимальные квантификаторы и упорядоченный выбор: В отличие от ДКА, который обеспечивает поиск минимального совпадения в целом, НКА поддерживает локальные минимальные квантификаторы и упорядоченный выбор, что позволяет регулировать последовательность проверок и минимизировать длину совпадений на более локальном уровне. 
    4. Захватывающие квантификаторы и атомарная группировка: НКА поддерживает захватывающие квантификаторы и атомарную группировку, что позволяет эффективно контролировать совпадения и избегать ненужных проверок. 
    5. Обработка многоопределённости: НКА поддерживает обработку языков, в которых на одном и том же месте могут быть несколько вариантов ввода, что позволяет учитывать альтернативные пути при распознавании строки (например, через операторы выбора, такие как | в регулярных выражениях). Это даёт НКА гибкость, так как он может одновременно рассматривать несколько возможных путей для распознавания. В отличие от этого, ДКА ограничен обработкой языков, где каждый ввод имеет строго определённый путь разбора, и требует создания отдельных состояний для каждой альтернативы, что делает его менее компактным и сложным в плане реализации для таких выражений.
  author: Еделькин Герман

- question: >
    Три закона для коммутативности и ассоциативности регулярных языков
  answer: >
    1. L + M = M + L — коммутативный закон для объединения утверждает, что два языка можно объединять в любом порядке. 
    2. (L + M) + N = L + (M + N) — это ассоциативный закон объединения, который говорит, что для объединения трёх языков можно сначала объединить как два первых, так и два последних из них. Вместе с коммутативным законом этот закон позволяет объединять любое количество языков в произвольном порядке, разбивая их на любые группы, и результат будет одним и тем же. Очевидно, что некоторая цепочка принадлежит объединению L_1 ∪ L_2 ∪ … ∪ L_k тогда и только тогда, когда она принадлежит одному или нескольким языкам L_i. 
    3. (LM)N = L(MN) — ассоциативный закон конкатенации гласит, что для конкатенации трёх языков можно сначала соединить как два первых, так и два последних из них.
  author: Еделькин Герман

- question: >
    Три закона для коммутативности и ассоциативности регулярных выражений
  answer: >
    1. L∣M=M∣L — коммутативный закон для объединения утверждает, что операнды в регулярных выражениях объединения можно менять местами, и это не изменяет язык, который они распознают.
    2. ((L∣M)∣N)=(L∣(M∣N)) — это ассоциативный закон объединения, который говорит, что для объединения трёх регулярных выражений можно сначала объединить как два первых, так и два последних из них, и результат будет тот же. Вместе с коммутативным законом этот закон позволяет менять порядок и группировку операндов в объединении произвольного числа регулярных выражений без изменения распознаваемого ими языка.
    3. (LM)N = L(MN) — ассоциативный закон конкатенации гласит, что для конкатенации трёх регулярных выражений можно сначала соединить два первых, а затем третий, либо наоборот, и результат останется одинаковым.
    Примечание: в данном ответе для операции объединения используется символ |, который является стандартным в регулярных выражениях. В то же время в математической теории автоматов и в рамках полукольца эту операцию может быть записана, как +.
  author: Еделькин Герман

- question: >
  Дистрибутивные законы для регулярных выражений
answer: >
  Для регулярных выражений существует закон дистрибутивности, но, поскольку операция конкатенации некоммутативна, то он формулируется в виде следующих двух законов: 
  • L(M∣N)=(LM∣LN). Этот закон называется левосторонним дистрибутивным законом конкатенации относительно объединения. 
  • (M∣N)L=(ML∣NL). Этот закон называется правосторонним дистрибутивным законом конкатенации относительно объединения.
  Примечание: в данном ответе для операции объединения используется символ |, который является стандартным в регулярных выражениях. В то же время в математической теории автоматов и в рамках полукольца эту операцию может быть записана, как +.
author: Еделькин Герман

- question: >
  Законы связанные с оператором итерации (в контексте регулярных выражений и языков)
answer: >
  Существует ряд законов, связанных с операцией итерации и её разновидностями + и ? в стиле UNIX. 
  • (L^*)^* = L^*. Этот закон утверждает, что при повторной итерации язык уже итерированного выражения не меняется. Язык выражения (L^*)^* содержит все цепочки, образованные конкатенацией цепочек языка L^*. Последние же цепочки построены из цепочек языка L. Таким образом, цепочки языка ( также являются конкатенациями цепочек из L и, следовательно, принадлежат языку L^*.
  • ∅^* = ε. Итерация языка ∅ состоит из одной-единственной цепочки ε.
  • ε* = ε. Легко проверить, что единственной цепочкой, которую можно образовать конкатенацией любого количества пустых цепочек, будет всё та же пустая цепочка.
  • L⁺ = L(L^*) = (L^*)L. 
    Поскольку L⁺ по определению равно L∣LL∣LLL∣…. 
    А также в силу того, что L^* = ε∣L∣LL∣LLL∣…, то 
    L(L^*) = Lε∣LL∣LLL∣LLLL∣… 
    Если учесть, что Lε = L, то очевидно, что бесконечные разложения для L(L^*) и для L⁺ совпадают. Это доказывает, что L⁺ = L(L^*). Доказательство того, что L⁺ = (L^*)L, аналогично. 
  • L^* = L⁺|ε. Это легко доказать, поскольку в разложении L⁺ присутствуют те же члены, что и в разложении L^*, за исключением цепочки ε. Заметим, что если язык L содержит цепочку ε, то `|ε` лишнее, т.е. в этом случае L⁺ = L^*.
  • L? = ε|L. В действительности это правило является определением оператора "?".
  Примечание: в данном ответе символ | используется для обозначения объединения, что является стандартом в регулярных выражениях. При этом в математических обозначениях или в рамках теории полуколец операция объединения часто записывается как +. Однако, чтобы избежать путаницы с оператором "позитивной итерации" (+), используется синонимичный символ |.


author: Еделькин Герман

- question: >
  Преобразование НКА в ДКА
answer: >
  Преобразование НКА в ДКА может занимать экспоненциальное время относительно количества состояний НКА. Вычисление ε-замыкания для n состояний занимает O(n³), так как нужно исследовать до n² дуг. Это можно сделать с помощью алгоритма Флойда-Уоршелла нахождения кратчайших путей между всеми парами вершин.
  После вычисления ε-замыкания можно перейти к синтезу ДКА с помощью конструкции подмножеств. Основное влияние на расход времени оказывает количество состояний ДКА, которое может равняться 2ⁿ. Для каждого состояния можно вычислить переходы завремя O(n³), используя ε-замыкание и таблицу переходов НКА для каждого входного символа. Предположим, нужно вычислить δ({q_1, q_2, …, q_k}, a) для ДКА. Из каждого со стояния q_i можно достичь не более n состояний вдоль путей с меткой ε, и каждое из этих состояний может иметь не более, чем n дуг с меткой a. Создав массив, проиндексиро ванный состояниями, можно вычислить объединение не более n множеств, состоящих из не более, чем n состояний, за время, пропорциональное n². 
  Таким способом для каждого состояния q_i можно вычислить множество состояний, достижимых из q_i вдоль пути с меткой a (возможно, включая дуги, отмеченные ε). Поскольку k ≤ n, то существует не более n таких состояний q_i, и для каждого из них вычисление достижимых состояний занимает время O(n²). Таким образом, общее время вычисления достижимых состояний равно O(n³). Для объединения множеств достижимых состояний потребуется только O(n²) дополнительного времени, следовательно, вычисление одного перехода ДКА занимает время O(n³). 
  Заметим, что количество входных символов считается постоянным и не зависит от n. Таким образом, как в этой, так и в других оценках времени работы количество входных символов не рассматривается. Размер входного алфавита влияет только на постоянный коэффициент, скрытый в обозначении “О большого”. 
  Итак, время преобразования НКА в ДКА, включая ситуацию, когда НКА содержит ε переходы, равно O((n³)(2ⁿ)). Конечно, на практике обычно число состояний, которые строятся, намного меньше 2ⁿ. Иногда их всего лишь n. Поэтому можно установить оценку времени работы равной O(n³s), где s — это число состояний, которые в действительности есть у ДКА.
author: Еделькин Герман

- question: >
  Проверка истинности алгебраических тождеств (в контексте регулярных языков и выражений)
answer: >
  Проверка истинности алгебраических тождеств заключается в проверке эквивалентности двух регулярных выражений. Это означает, что оба выражения должны описывать один и тот же язык — множество строк, которые они распознают, должно совпадать.
  Подходы для проверки эквивалентности регулярных выражений:
    1. Преобразование в конечные автоматы: 
      Можно преобразовать оба регулярных выражения в недетерминированные конечные автоматы (НКА), а затем привести их к эквивалентным детерминированным конечным автоматам (ДКА). 
      После этого проверяется эквивалентность автоматов, что означает, что их язык принимаемый ими язык одинаков. 
      Автоматы считаются эквивалентными, если они принимают один и тот же язык, то есть принимают одни и те же строки.
    2. Минимизация автоматов: 
      После получения ДКА для каждого регулярного выражения можно минимизировать оба автомата. 
      Минимизированные ДКА будут эквивалентны тогда и только тогда, когда они изоморфны (имеют одинаковую структуру).
    3. Метод разницы языков:
      Можно построить автомат, который распознает разницу языков, описываемых двумя регулярными выражениями  L_1 и L_2 : это язык, состоящий из всех строк, которые принадлежат L_1, но не принадлежат  L_2, и всех строк, которые принадлежат L_2 , но не принадлежат L_1. 
      Если разность языков пуста (нет таких строк), значит, регулярные выражения эквивалентны.  
author: Еделькин Герман

- question: >
  Доказательство леммы о накачке для регулярных языков (Пусть L - регулярный язык)
answer: >
  Теорема: Для любого регулярного языка L существует число n ∈ ℕ такое, что ∀ w ∈ L, |w| ≥ n найдутся такие три слова x, y, z, что: w = xyz; y ≠ ε; |xy| ≤ n; ∀ k ≥ 0: x(y^k)z ∈ L.
  Доказательсво: Пусть L — регулярный язык, которому соответствует конечный автомат с числом вершин n, а w ∈ L — слово длины не менее n.
  Рассмотрим последовательность вершин конечного автомата в порядке их посещения при разборе слова w: a_0, a_1, a_2, ..., a_m. Последовательность, очевидно, содержит m+1 вершину, и m ≥ n.
  Так как всего в графе только n вершин, хотя бы одна из них повторяется в последовательности. Пусть a_i — первая вершина последовательности из числа повторяющихся, причём второй раз она встретилась в позиции j. Тогда x — первые i символов строки w, y — отрезок w, соответствующий перемещению из a_i в a_j, а z — отрезок w, соответствующий перемещению из a_j в a_n.
  Так как переход от a_i к a_j образует цикл в конечном автомате, по этому циклу можно пройти произвольное (в том числе и нулевое!) число раз, и всякий раз будет получаться строчка, принимаемая автоматом, поэтому ∀ k ∈ ℕ_0: x(y^k)z ∈ L.
  При этом пара состояний a_i, a_j — первый повтор в рассматриваемой последовательности. Значит, все состояния a_0, a_1, ..., a_{j-1} являются различными. Раз так, то их не больше n. Отсюда получаем, что j ≤ n и |xy| ≤ n, что и требовалось доказать.
author: Еделькин Герман

- question: >
  Что делать, если языки имеют разные алфавиты? (в контексте регулярных языков и выражений)
answer: >
  При объединении или пересечении двух языков L и M может оказаться, что они определены в разных алфавитах. Например, возможен случай, когда L1 ⊆ {a, b}^*, а L2 ⊆ {b, c, d}^*. Однако, если язык L состоит из цепочек символов алфавита Σ, то L можно также рассматривать как язык в любом конечном алфавите, включающем Σ (надмножестве Σ). 
  Например, можно представить указанные выше языки L_1 и L_2 как языки в алфавите {a, b, c, d}. То, что ни одна цепочка языка L_1 не содержит символов c или d, несущественно, как и то, что ни одна цепочка языка L_2 не содержит a. Аналогично, рассматривая дополнение языка L, который является подмножеством множества (Σ_1)* для некоторого алфавита Σ_1, можно взять дополнение относительно некоторого алфавита Σ_2, включающего Σ_1 (надмножества Σ_1). В этом случае дополнением L будет (Σ_2)* – L, т.е. дополнение языка L относительно алфавита Σ_2 включает (среди прочих) все цепочки из (Σ_2)*, которые содержат хотя бы один символ алфавита Σ_2, не принадлежащий Σ_1. 
  Если взять дополнение L относительно Σ_1, то ни одна цепочка, содержащая символы из Σ_2 – Σ_1, не попадет в L.
  Таким образом, чтобы избежать неточностей, нужно указывать алфавит, относительно которого берется дополнение. Часто, однако, бывает очевидно, какой алфавит подразумевается в конкретном случае. Например, если язык L определен некоторым автоматом, то в описании этого автомата указывается и алфавит. 
  Итак, во многих ситуациях можно говорить о “дополнении”, не указывая алфавит.
author: Еделькин Герман

- question: >
  Теорема Майхилла-Нероде (англ. Myhill-Nerode) для регулярных языков
answer: >
  Теорема Майхилла-Нероде (англ. Myhill-Nerode). Пусть L — язык и пусть ≡_L — отношение эквивалентности на множестве строк, где u ≡_L u', если для всякой строки v строки uv и u'v или обе лежат в L или обе не лежат. Это отношение называется суффиксной конгруэнтностью для языка L. Утверждается, что язык L регулярен тогда и только тогда, когда число классов эквивалентности в отношении ≡_L конечно.
  Расширение понятия на другие классы языков:
  Подходы, аналогичные теореме Майхилла-Нероде, применяются и в анализе более сложных языков, таких как древесные языки и видимо-контекстно-свободные языки (VPL).
  Суффиксная конгруэнтность древесных языков: Для древесных языков суффиксная конгруэнтность классифицирует деревья на основе их суффиксов. Два дерева эквивалентны, если добавление одного и того же поддерева приводит к деревьям, которые либо оба принадлежат языку, либо оба не принадлежат. Это позволяет разбить множество деревьев на конечное число классов эквивалентности.
  Visibly Pushdown Languages (VPL): Для VPL суффиксная конгруэнтность применяется к сбалансированным словам, где видна структура стека. Два слова считаются эквивалентными, если любые продолжения этих слов приводят к одинаковым конфигурациям стека. Это также позволяет выделить конечное число классов эквивалентности.
author: Еделькин Герман

- question: >
  Что называется конфигурацией ДКА
answer: >
  Пусть M = (Q, Σ, s, F, 𝛿). Q – конечное множество состояний, Σ - алфавит. s ∈ Q – начальное состояние, F ⊆ Q –
  множество заключительных состояний, а 𝛿 : Q × Σ → Q – функция перехода.
  Конфигурацией ДКА M = (Q, Σ, s, F, 𝛿) называется произвольная пара (q, w), где q ∈ Q, w ∈ Σ*.
  Где Σ* Множество слов алфавита Σ, Σ* = ⋃︁_(n ∈ N) Σⁿ.
  Таким образом, Конфигурация (q, w) описывает текущее состояние автомата и оставшуюся часть входного слова, которое нужно обработать.
    q — текущее состояние, в котором находится автомат. 
    w — оставшаяся часть слова, которую автомат ещё не прочитал. 
  Каждый шаг работы ДКА можно представить как переход из одной конфигурации в другую, где автомат «чтение за чтением» меняет состояние в зависимости от текущего символа слова (с помощью функции перехода δ), пока либо не завершит чтение слова, либо не придёт в состояние, из которого больше нет возможных переходов.
author: Еделькин Герман

- question: >
  Как задаётся суффиксная конгруэнтность языка L на множестве слов алфавита?
answer: >
  Σ* - Множество слов алфавита Σ. Σ* = ⋃︁_(n ∈ N) Σⁿ.
  Бинарное отношение ≡_L, называемое суффиксной конгруэнтностью для языка L, задаётся на множестве Σ* следующим образом: 
    ∀x, y ∈ Σ*, x ≡_L y ⇔ ∀ z ∈ Σ*, xz ∈ L ⇔ yz ∈ L
  Проще говоря, слова x и y находятся в отношении ≡_L, если для каждого слова z приписывание его справа к x приводит к слову, принадлежащему языку L, тогда и только тогда, когда приписывание справа того же слова z к y также приводит к слову, принадлежащему L. Это отношение называется суффиксной конгруэнтностью для языка L.
  Таким образом, бинарное отношение ≡_L делит множество Σ* на классы эквивалентности. Каждому классу эквивалентности соответствуют слова, которые ведут себя одинаково с точки зрения принадлежности к языку L после добавления любого другого слова.
author: Еделькин Герман

- question: >
  Пусть a – регулярное выражение алфавита. Как Язык L(a), являющийся подмножеством множества слов алфавита, определяется по регулярному выражению a индукцией по структуре a?  
answer: >
  Чтобы определить язык L(a) ⊆ Σ* по регулярному выражению a, можно использовать индукцию по структуре выражения a, основываясь на его составных частях. То есть мы последовательно определяем язык, соответствующий каждому элементарному случаю и операции над регулярными выражениями: 
    1. Пустое множество: L(∅) = ∅ — язык, который не содержит ни одного слова. 
    2. Базовый символ: L(a) = {a}, где a ∈ Σ. Это язык, состоящий из одного слова, представляющего символ a.
    3. Объединение языков: L(a ∪ b) = L(a) ∪ L(b). Если регулярное выражение a ∪ b описывает объединение двух языков, то язык L(a ∪ b) включает все слова из L(a) и L(b).
    4. Конкатенация языков: L(a ∘ b) = L(a) ∘ L(b). Здесь a∘b описывает конкатенацию языков, и язык L(a∘b) состоит из всех слов, которые можно получить, последовательно объединяя слова из L(a) и L(b).
    5. Замыкание Клини (итерация): L(a*) = L(a)*. Замыкание Клини для регулярного выражения a представляет собой множество всех возможных конкатенаций любого количества (включая ноль) слов из L(a). Это позволяет получить язык, включающий все повторения слов из L(a).
  Таким образом, используя эти правила, можно по шагам построить язык для любого регулярного выражения, последовательно применяя операторы к более простым выражениям и определяя язык для каждой из составляющих частей.
author: Еделькин Герман

- question: >
  Лемма о разрастании для регулярных языков
answer: >
  Лемма о разрастании также называется леммой о накачке (по-английски - никаких разночтений: pumping lemma)
  Теорема: Для любого регулярного языка L существует число n ∈ ℕ такое, что для любого слова w ∈ L, |w| ≥ n найдутся такие три слова x, y, z, что: 
    1. w = xyz; y ≠ ε; 
    2. |xy| ≤ n; 
    3. ∀ k ≥ 0: x(y^k)z ∈ L.
  Таким образом эта лемма утверждает, что любой регулярный язык допускает представление всех своих достаточно длинных цепочек в виде соединения трех цепочек, причем средняя цепочка из этих трех не пуста, ограничена по длине, и ее `накачка` — повторение любое число раз — или выбрасывание не выводит за пределы языка (т.е. дает цепочки, принадлежащие данному регулярному языку).
author: Еделькин Герман

- question: >
    Какие факторы должны быть сбалансированны в хорошо написанном регулярном выражении?
  answer: >
    В хорошо написанном регулярном выражении должны быть сбалансированы несколько факторов:
     • Регулярное выражение должно находить именно те фрагменты текста, которые соответствуют заданным условиям. В зависимости от задачи, подход может различаться: например, fullmatch проверяет полное совпадение всей строки с выражением, в то время как search подходит для нахождения фрагментов внутри строки. Такое разграничение позволяет выбирать правильный метод для каждой задачи, будь то полное соответствие или частичное.
     • Регулярное выражение должно оставаться понятным и легким для поддержки. Сложные, трудно читаемые выражения могут затруднить их использование и усложнить внесение изменений, повышая риск ошибок.
     • При использовании механизма недетерминированного конечного автомата (НКА) выражение должно быть эффективно и приводить к быстрому результату. Однако стоит учитывать, что конструкции с итерацией Клини (* и +) особенно в начале выражения могут усилить недетерминизм, что повышает вероятность долгого перебора вариантов и ухудшает производительность. Хорошо составленное регулярное выражение должно минимизировать такие конструкции, если это возможно, чтобы избежать избыточной сложности и не затягивать обработку.
  author: Еделькин Герман
