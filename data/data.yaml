- answer: 'Язык, распознаваемый недетерминированным конечным автоматом (НКА) – это
    все такие слова,  по которым существует хотя бы один путь из стартовой вершины
    в терминальную.

    '
  author: Лисов Алексей
  id: 0
  questions:
  - Что представляет собой язык, распознаваемый недетерминированным конечным автоматом
    (НКА)?
- answer: 'Регулярный язык может быть задан с помощью конечного автомата.  Так как
    автомат конечен, то мы можем его обойти (пройти через все состояния) за конечное
    время.  Так как нам нужно найти самое короткое слово, то эта задача сводится к
    тому, что нам необходимо  найти кратчайший путь от стартовой вершины до какой-либо
    терминальной. По определению это  можно сделать с помощью поиска в ширину (bfs,
    breadth-first search). Поиск в ширину - алгоритм, находящий  все кратчайшие пути
    от заданной вершины в невзвешенном графе. Запускаем поиск в ширину и выйдем из
    него,  когда пришли в терминальное состояние. Так как нам нужно явно найти кратчайшее
    слово, то после этого делаем  восстановление ответа. Это можно сделать используя
    дополнительную структуру данных (например массив prev), для того,  чтобы для каждого
    состояния v хранить состояние u, из которого мы в него пришли. Мы можем пройти
    от найденной  вершины по массиву prev, пока не придем в начальное состояние. Записав
    все переходы мы получим кратчайшее слово,  принадлежащее регулярному языку.

    '
  author: Лисов Алексей
  id: 1
  questions:
  - Дан регулярный язык, опиши алгоритм нахождения кратчайшего слова, принадлежащего
    этому регулярному языку
- answer: 'Обозначим регулярный язык за L и пусть длина слов, количество которых мы
    хотим найти - l. Так как язык L регулярен, то мы можем построить соответствующий
    ему конечный автомат A. Решим задачу с помощью динамического программирования.
    Пусть a_(q,i) – количество слов длины i, переводящих  автомат A из начального
    состояния q0 в состояние q.  Чтобы пересчитать эту величину, нужно просуммировать
    значения динамического программирования из предыдущего по длине слоя для всех
    состояний, из которых есть ребро в состояние q. Ответом является сумма элементов
    столбца, отвечающего за длину l, соответствующих терминальным вершинам.

    '
  author: Лисов Алексей
  id: 2
  questions:
  - Опиши алгоритм подсчета количества слов определенной длины в заданном регулярном
    языке
- answer: 'Языки недетерминированных автоматов с магазинной памятью являются контекстно-свободными.
    То есть эти языки могут быть заданы с помощью контекстно свободных грамматик.

    '
  author: Лисов Алексей
  id: 3
  questions:
  - Какими являются языки недетерминированных автоматов с магазинной памятью?
- answer: Магазинная память у автомата с магазинной памятью является стеком.
  author: Лисов Алексей
  id: 4
  questions:
  - Какая структура данных может описать магазинную память у автомата с магазинной
    памятью?
- answer: 'ε-замыкание состояния q – это множество состояний, достижимых из q только
    по ε-переходам.  Соответственно эпсилон замыкание для каждой из вершин автомата
    можно предподсчитать с помощью поиска в глубину  (dfs) для каждой вершины.

    '
  author: Лисов Алексей
  id: 5
  questions:
  - Опиши алгоритм нахождения эпсилон замыкания для каждой из вершин автомата?
- answer: 'Прямым произведением двух ДКА A1=⟨Σ1,Q1,s1,T1,δ1⟩ и A2=⟨Σ2,Q2,s2,T2,δ2⟩
    называется ДКА  A=⟨Σ,Q,s,T,δ⟩, где:  1) Σ = Σ1∪Σ2, то есть он работает над пересечением
    алфавитов двух данных автоматов  2) Q = Q1×Q2, множество пар состояниий включает
    в себя состояния обоих автоматов  3) s =⟨s1,s2), стартуем с символов в обоих автоматах  4)
    T=T1×T2, терминальные состояния включают в себя терминальные состояния обоих автоматов  5)
    δ(⟨q1,q2⟩,c)=⟨δ1(q1,c),δ2(q2,c)⟩, то есть переходим по символу в обоих автоматах"

    '
  author: Лисов Алексей
  id: 6
  questions:
  - Дай определение произведения двух автоматов
- answer: 'Для этого нужно заменить переход из состояния q в состояние p по символу
    x на такой же переход,  только добавить z_0/z_0, где z_0 это дно стека. Из этого
    следует, что регулярные языки являются подмножеством  МП-автоматных языков (языков
    автоматов с магазинной памятью).

    '
  author: Лисов Алексей
  id: 7
  questions:
  - Как из недетерминированного конечного автомата A сделать pushdown automat B?
- answer: 'Теорема Клини (англ. Kleene''s theorem) гласит о том, что множество языков,
    принимаемых детерминированным конечным автоматом совпадает с  множеством языком,
    принимаемых академическим регулярным выражением.

    '
  author: Лисов Алексей
  id: 8
  questions:
  - Теорема Клини (англ. Kleene's theorem)
- answer: 'Язык L называется префиксным, если для любого слова w не равного слову
    v из L не верно, что w – префикс v.  Также такие языки называют беспрефиксными.

    '
  author: Лисов Алексей
  id: 9
  questions:
  - Какой язык называется префиксным (беспрефиксным)
- answer: 'Это значит, что язык M принимается детерминированным конечным автоматом
    с магазинной памятью по терминальному  состоянию, а также язык M – префиксный
    (то есть если для любого w не равного v из языка M не верно, что w – префикс v).

    '
  author: Лисов Алексей
  id: 10
  questions:
  - 'Что можно сказать о языке M, который принимается детерминированным конечным автоматом  с
    магазинной памятью по пустому стеку

    '
- answer: 'Язык Дика (англ. Dyck''s language) не является регулярным. Докажем с помощью
    леммы о накачке. Предположим, что он регулярный, тогда по лемме о накачке существует  n,
    являющееся длиной накачки. Возьмём последовательность из n открывающих, а затем
    n закрывающих скобок.  Для неё существуют соответствующие x, y, z из леммы о
    накачке. Но так как |xy| <= n, то y  состоит только из открывающих скобок, причём
    по условию леммы y не пустая. А значит при i = 2 в строке xy^iz  получится больше
    открывающих скобок, чем закрывающих, то есть это будет не правильной скобочной
    последовательностью.  Получили противоречие. Следовательно язык Дика с единственным
    типом скобок не является регулярным.

    '
  author: Лисов Алексей
  id: 11
  questions:
  - 'Является ли регулярным язык Дика (англ. Dyck''s language) с единственным типом
    скобок? (язык Дика - множество правильных скобочных структур вместе с пустой структурой,  образующее
    язык над алфавитом {a,b}.)

    '
  - 'Является ли регулярным язык правильных скобочных последовательностей с единственным
    типом скобок?

    '
  - 'Является ли регулярным язык ПСП с единственным типом скобок?

    '
- answer: 'Да, разность контекстно-свободного и регулярного языка является контекстно-свободным
    языком.

    '
  author: Лисов Алексей
  id: 12
  questions:
  - 'Является ли контекстно-свободным языком разность контекстно-свободного и регулярного
    языка?

    '
- answer: 'Переход машины Тьюринга — это функция, зависящая от состояния конечного
    управления и обозреваемого символа.  За один переход машина Тьюринга должна выполнить
    следующие действия: изменить состояние,  записать ленточный символ в обозреваемую
    клетку, сдвинуть головку влево или вправо.

    '
  author: Дмитрий Теньшов
  id: 13
  questions:
  - 'Что такое переход машины Тьюринга?

    '
- answer: 'Языки, допустимые с помощью машины Тьюринга, называются рекурсивно перечислимыми,
    или РП-языками.

    '
  author: Дмитрий Теньшов
  id: 14
  questions:
  - 'Какие языки допускаются при помощи машины Тьюринга?

    '
- answer: 'Память в состоянии — конечное управление можно использовать не только для
    представления позиции в «Программе» машины Тьюринга,  но и для хранения конечного
    объема данных.

    '
  author: Дмитрий Теньшов
  id: 15
  questions:
  - 'Опишите прием «память в состоянии» машины Тьюринга.

    '
- answer: 'Подпрограмма машины Тьюринга представляет собой множество состояний, выполняющее
    некоторый полезный процесс.  Это множество включает в себя стартовое состояние
    и еще одно состояние,  которое не имеет переходов и служит состоянием «возврата»
    для передачи управления какому-либо множеству состояний,  вызвавшему данную подпрограмму.
    «Вызов» подпрограммы возникает везде, где есть переход в ее начальное состояние.

    '
  author: Дмитрий Теньшов
  id: 16
  questions:
  - 'Опишите прием «Подпрограммы» машины Тьюринга.

    '
- answer: 'Хотя позиции конечны в каждый момент времени, всё множество позиций может
    быть и бесконечным.  Если состояние должно представлять любую позицию головки,
    то в состоянии должен быть компонент данных,  имеющий любое целое в качестве значения.
    Из-за этого компонента множество состояний должно быть бесконечным,  даже если
    только конечное число состояний используется в любой конечный момент времени.
    Определение же машин Тьюринга требует,  чтобы множество состояний было конечным.
    Таким образом, запомнить позицию ленточной головки в конечном управлении нельзя.

    '
  author: Дмитрий Теньшов
  id: 17
  questions:
  - 'Можно ли запомнить позицию ленточной головки в позиции управления у машины Тьюринга?

    '
- answer: 'Счетчиковые машины — это класс машин, обладающий возможностью запоминать
    конечное число целых чисел (счетчиков)  и совершать различные переходы в зависимости
    от того, какие из счетчиков равны 0 (если таковые вообще есть).  Счетчиковая машина
    может только прибавить 1 к счетчику или вычесть 1 из него,  но отличить значения
    двух различных ненулевых счетчиков она не способна.

    '
  author: Дмитрий Теньшов
  id: 18
  questions:
  - 'Что такое счетчиковая машина?

    '
- answer: 'Каждый язык, допускаемый счетчиковой машиной, рекурсивно перечислим. Причина
    в том,  что счетчиковые машины являются частным случаем магазинных, а магазинные
    — частным случаем многоленточных машин Тьюринга,  которые по теореме допускают
    только рекурсивно перечислимые языки.

    '
  author: Дмитрий Теньшов
  id: 19
  questions:
  - 'Какой язык допускается счетчиковой машиной?

    '
- answer: 'Для имитации машины Тьюринга и, следовательно, для допускания любого рекурсивно
    перечислимого языка, достаточно двух счетчиков.  Для обоснования этого утверждения
    вначале доказывается, что достаточно трех счетчиков,  а затем три счетчика имитируются
    с помощью двух.

    '
  author: Дмитрий Теньшов
  id: 20
  questions:
  - 'Допускается ли любой рекурсивно перечислимый язык двухсчетчиковой машиной?

    '
- answer: 'Универсальной машиной Тьюринга называют машину Тьюринга, которая может
    заменить собой любую машину Тьюринга.  Получив на вход программу и входные данные,
    она вычисляет ответ, который вычислила бы по входным данным машина Тьюринга,  чья
    программа была дана на вход.

    '
  author: Дмитрий Теньшов
  id: 21
  questions:
  - 'Что такое универсальная машина Тьюринга?

    '
- answer: 'Рассмотрим компьютер, обладающий следующими свойствами: у него есть только
    инструкции,  увеличивающие максимальную длину слова не более чем на один; у него
    есть только инструкции,  которые многоленточная машина Тьюринга может выполнить
    на словах длиной k за O(k^2) или меньшее число шагов.  Шаг — это выполнение одной
    инструкции. Таким образом, выполнение n шагов работы компьютера можно проимитировать  на
    многоленточной машине Тьюринга с использованием не более O(n^3) шагов.

    '
  author: Дмитрий Теньшов
  id: 22
  questions:
  - 'Какое время необходимо многоленточной машине Тьюринга для имитации шагов компьютера?

    '
- answer: 'Многодорожечная машина Тьюринга, машина Тьюринга с односторонней лентой,
    многоленточная машина Тьюринга  и недетерминированная машина Тьюринга, несмотря
    на различия в их конструкции или правилах работы,  обладают одинаковой вычислительной
    мощностью, то есть способны вычислить одни и те же классы функций.  Различия между
    видами машин Тьюринга (например, между машинами с одним или несколькими лентами)  могут
    повлиять на эффективность вычислений (время или пространство), но не на саму вычислительную
    мощность.

    '
  author: Дмитрий Теньшов
  id: 23
  questions:
  - 'Как связаны мощности следующих машин Тьюринга: многодорожечная машина Тьюринга,  машина
    Тьюринга с односторонней лентой, многоленточная машина Тьюринга, недетерминированная
    машина Тьюринга?

    '
- answer: 'Если проблему P1 можно свести к проблеме P2 и если P1 неразрешима, то и
    P2 неразрешима.

    '
  author: Дмитрий Теньшов
  id: 24
  questions:
  - 'Если проблема P1 неразрешима и ее можно свести к проблеме P2, то является ли
    проблема P2 неразрешимой?

    '
- answer: 'Рандомизированная машина Тьюринга — это вариант многоленточной машины Тьюринга.
    Первая лента,  как обычно для многоленточных машин, содержит вход. Вторая лента
    также начинается непустыми клетками.  В принципе, вся она содержит символы 0 и
    1, выбранные с вероятностью 1/2. Вторая лента называется случайной лентой.  Третья
    и последующие, если используются, вначале пусты и при необходимости выступают
    как рабочие.

    '
  author: Дмитрий Теньшов
  id: 25
  questions:
  - 'Что такое рандомизированная машина Тьюринга?

    '
- answer: 'Языки, допускаемые машинами Тьюринга, называются рекурсивно-перечислимыми
    (РП), а РП-языки, допускаемые МТ, которые всегда останавливаются, — рекурсивными.
    “Разрешимость” есть  синоним “рекурсивности”, однако языки чаще называются “рекурсивными”,
    а проблемы (которые  представляют собой языки, интерпретируемые как вопросы) —
    “разрешимыми”.  Если язык не является рекурсивным, то проблема, которую выражает
    этот язык, называется “неразрешимой”. Рекурсивный язык позволяет построить разрешающую
    функцию: т.е. МТ, возвращающую один из двух результатов (да-нет), и корректно
    завершающую работу.

    '
  author: Филимонов Михаил
  id: 26
  questions:
  - Рекурсивные языки.
- answer: 'Язык L является рекурсивно-перечислимым (РП-языком), если L = L(M) для
    некоторой машины Тьюринга M. Проблема останова машины Тьюринга является РП, но
    не рекурсивной. В действительности, определенная А. М. Тьюрингом  машина допускала,
    не попадая в допускающее состояние, а останавливаясь. Для МТ  M можно определить
    H(M) как множество входов w, на которых M останавливается  независимо от того,
    допускает ли M вход w. Тогда проблема останова состоит в опре  делении множества
    таких пар (M, w), у которых w принадлежит H(M). Это еще один  пример проблемы/языка,
    которая является РП, но не рекурсивной.

    '
  author: Филимонов Михаил
  id: 27
  questions:
  - Рекурсивно-перечислимые языки. Примеры языков, которые являются рекурсивно-перечислимыми,
    но не рекурсивными.
- answer: 'Язык диагонализации L_d — это множество всех цепочек w_i, не принадлежащих
    L(M_i). Понятие M_i, “i-й машины Тьюринга”. Это машина Тьюринга M, кодом которой
    является i-я двоичная цепочка w_i. В язык L_d  входит каждая цепочка в алфавите
    {0, 1}, которая, будучи проинтерпретированной как код МТ, не принадлежит языку
    этой МТ. Язык L_d является хорошим примером не РП-языка, т.е. его не допускает
    ни одна машина Тьюринга.

    '
  author: Филимонов Михаил
  id: 28
  questions:
  - Что такое язык диагонализации?
- answer: 'Язык L_d не является рекурсивно-перечислимым, т.е. не существует машины
    Тьюринга, которая допускала бы L_d. Доказательство. Допустим, что L_d = L(M) для
    некоторой МТ M. Так как L_d — язык над алфавитом {0, 1}, M должна содержаться
    в построенной нами последовательности машин Тьюринга, поскольку эта последовательность
    содержит все МТ с входным алфавитом {0, 1}. Следовательно, в ней есть, по крайней
    мере, один код машины M, скажем, i, т.е. M = M_i. Понятие M_i, “i-й машины Тьюринга”.
    Это МТ M, кодом которой является i-я двоичная цепочка w_i. Выясним теперь, принадлежит
    ли w_i языку L_d. Если w_i принадлежит L_d, то M_i допускает w_i. Но тогда (по
    определению L_d) w_i не принадлежит L_d, так как L_d содержит лишь такие w_j,
    для которых M_j не допускает w_j. Точно так же, если w_i не принадлежит L_d, то
    M_i не допускает w_i. Но тогда (по определению L_d) w_i принадлежит L_d. Поскольку
    w_i не может одновременно и принадлежать, и не принадлежать L_d, приходим к противоречию
    с нашим предположением о том, что M существует. Таким образом, L_d не является
    рекурсивно-перечислимым языком.

    '
  author: Филимонов Михаил
  id: 29
  questions:
  - Является ли язык диагонализации рекурсивно-перечислимым?
- answer: 'Рекурсивные функции были введены в 30-х годах XX века С. К. Клини.  Это
    название закрепилось за одним из наиболее распространённых вариантов  уточнения
    общего понятия арифметического алгоритма, то есть такого алгоритма,  допустимые
    исходные данные которого представляют собой системы натуральных чисел,  а возможные
    результаты применения — натуральные числа. Языки называются рекурсивными, если
    они являются рекурсивным подмножеством набора всех  возможных конечных последовательностей
    по алфавиту языка. Тезис Чёрча — Тьюринга: любая функция,  которая может быть
    вычислена физическим устройством, может быть вычислена машиной Тьюринга. То есть
    рекурсивные функции вычисляют те же классы алгоритмов, что и машины Тьюринга.
    Эквивалентно, формальный язык  является рекурсивным, если существует машина Тьюринга,
    которая при вводе конечной  последовательности символов всегда останавливается
    и принимает её, если она  принадлежит языку, и останавливается и отвергает её
    в противном случае.

    '
  author: Филимонов Михаил
  id: 30
  questions:
  - Почему языки 'рекурсивные'?
- answer: 'Язык L_u состоит из цепочек, интерпретируемых как код МТ, к которому дописан
    ее вход. Цепочка принадлежит L_u, если эта МТ до пускает данный вход. Язык L_u
    является рекурсивно-перечислимым. Допустим, что L_u рекурсивен. Тогда по теореме
    дополнение L_u (дополнение L_u)  также рекурсивный язык. Но если существует МТ
    M, допускающая L_u, то, используя описанный ниже метод,  можно построить МТ, допускающую
    L_d. Язык диагонализации L_d — это множество всех цепочек w_i, не принадлежащих
    L(M_i). Понятие M_i, “i-й машины Тьюринга”. Это МТ M, кодом которой является i-я
    двоичная цепочка w_i. В язык L_d  входит каждая цепочка в алфавите {0, 1}, которая,
    будучи проинтерпретированной как код МТ, не принадлежит языку этой МТ. Поскольку
    нам известно, что L_d не является РП, приходим к  противоречию с предположением,
    что язык L_u является рекурсивным. Предположим, что L(M) = L_u. Можно  преобразовать
    МТ M в МТ M'', которая допускает L_d с помощью следующих действий: 1. M'' преобразует  входную
    цепочку w в w111w. Легче это сделать, используя для копии w вторую ленту, и затем  преобразовать
    двухленточную МТ в одноленточную. 2. M'' имитирует M на новом входе. Если w есть
    w_i  в нашем перечислении, то M'' определяет, допускает ли M_i вход w_i. Поскольку
    M допускает L_u, то она  допускает тогда и только тогда, когда M_i не допускает
    w_i, т.е. когда w_i принадлежит L_d. Таким образом,  M'' допускает w тогда и только
    тогда, когда w принадлежит L_d. Поскольку по теореме машины M'' не существует,  приходим
    к выводу, что язык L_u не является рекурсивным.

    '
  author: Филимонов Михаил
  id: 31
  questions:
  - 'Почему универсальный язык является рекурсивно-перечислимым, но не рекурсивным.

    '
- answer: 'L_ne – непустой язык состоит из кодов всех машин Тьюринга, которые допускают
    хотя бы одну цепочку.  Он рекурсивно-перечислим, но не рекурсивный. Чтобы доказать
    РП, достаточно предъявить МТ, допускающую L_ne.  Проще всего это сделать, описав
    недетерминированную МТ M. Работа M заключается в следующем: 1. На вход M подается  код
    МТ M_i. 2. Используя недетерминизм, M угадывает вход w, который, возможно, допускается
    M_i.  3. M проверяет, допускает ли M_i свой вход w. В этой части M может моделировать
    работу универсальной МТ U,  допускающей L_u (язык L_u состоит из цепочек, интерпретируемых
    как код МТ, к которому дописан ее вход. Цепочка принадлежит L_u, если эта МТ до
    пускает данный вход). 4. Если M_i допускает w, то и M допускает свой вход, т.е.
    M_i. Понятие M_i, “i-й машины  Тьюринга”. Это МТ M, кодом которой является i-я
    двоичная цепочка w_i. В этот язык входит каждая цепочка  в алфавите {0, 1}, которая,
    будучи проинтерпретированной как код МТ, не принадлежит языку этой МТ.  Таким
    образом, если M_i допускает хотя бы одну цепочку, то M угадает ее (среди прочих,
    конечно) и допустит M_i.  Если же L(M_i) = ∅, то ни одна из угаданных w не допускается
    M_i, и M не допустит M_i. Таким образом, L(M) = L_ne.

    '
  author: Филимонов Михаил
  id: 32
  questions:
  - 'Является ли язык, состоящий из кодов всех машин Тьюринга,  которые допускают
    хотя бы одну цепочку, рекурсивно-перечислимым/рекурсивным?

    '
- answer: 'L_e – пустой язык состоит из кодов всех МТ, языки которых пусты. Он не
    рекурсивно-перечислим.

    '
  author: Филимонов Михаил
  id: 33
  questions:
  - 'Является ли пустой язык, состоящий из кодов всех машины Тьюринга, языки которых
    пусты, рекурсивно-перечислимым/рекурсивным?

    '
- answer: 'Свойство называется тривиальным, если оно либо пустое (т.е. никакой язык
    вообще ему не удовлетворяет), либо содержит все РП-языки (рекурсивно-перечислимые).
    В противном случае свойство назы вается нетривиальным.  Теорема Райса: Всякое
    нетривиальное свойство языков, допускаемых МТ, является неразрешимым. Например,
    множество кодов  машин Тьюринга, допускающих пустой язык, согласно теореме Райса
    является неразрешимым. В действительности  этот язык не является РП, хотя его
    дополнение — множество кодов МТ, допускающих хотя бы одну цепочку, —  является
    РП, но не рекурсивным.

    '
  author: Филимонов Михаил
  id: 34
  questions:
  - 'Теорема Райса

    '
- answer: 'Алгоритм решения становится очевидным, если заметить, что, когда МТ делает
    пять переходов,  она обозревает не более девяти клеток вокруг начальной позиции
    головки. Поэтому можно проимитировать  пять переходов МТ на любом из конечного
    числа входов, длина которых не более девяти. Если все эти  имитации не достигают
    останова, то делается вывод, что на любом входе данная МТ совершает более пяти
    переходов.

    '
  author: Филимонов Михаил
  id: 35
  questions:
  - 'Существует ли такой вход для заданной машины Тьюринга,  при обработке которого
    машина выполняет более пяти переходов,  прежде чем достигнет состояния останова
    (либо завершится, либо зациклится)?

    '
- answer: 'Экземпляр проблемы соответствий Поста состоит из двух списков равной
    длины в некотором алфавите Σ.  Как правило, мы будем называть их списками A и
    B, и писать A = w_1, w_2, …, w_k и B = x_1, x_2, …, x_k при  некотором целом k.
    Для каждого i пара (w_i, x_i) называется парой соответствующих цепочек. Мы говорим,
    что  экземпляр ПСП имеет решение, если существует последовательность из одного
    или нескольких целых чисел  i_1, i_2, …, i_m, которая, если считать эти числа
    индексами цепочек и выбрать соответствующие цепочки из  списков A и B, дает одну
    и ту же цепочку, т.е. w_i_1w_i_2…w_i_m = x_i_1xi_2…x_i_m. В таком случае последовательность  i_1,
    i_2, …, i_m называется решающей последовательностью, или просто решением, данного
    экземпляра ПСП.

    '
  author: Филимонов Михаил
  id: 36
  questions:
  - 'Что такое проблема соответствий Поста.

    '
- answer: 'Модифицированной проблемой соответствий Поста, или МПСП.  В модифицированной
    ПСП на решение накладывается дополнительное требование,  чтобы первой парой в
    решении была пара первых элементов списков A и B.  Более формально, экземпляр
    МПСП состоит из двух списков A = w_1, w_2, …, w_k  и B = x_1, x_2, …, x_k, и решением
    является последовательность из 0 или  нескольких целых чисел i_1, i_2, …, i_m,
    при которой  w_1w_i_1w_i_2…w_i_m = x_1x_i_1x_i_2…x_i_m. Отметим, что цепочки обязательно
    начинаются парой (w_1, x_1),  хотя индекс 1 даже не указан в качестве начального
    элемента решения. Кроме того, в отличие от ПСП,  решение которой содержит хотя
    бы один элемент, решением МПСП может быть и пустая последовательность (когда w_1
    = x_1).

    '
  author: Филимонов Михаил
  id: 37
  questions:
  - 'Что такое модифицированная проблема соответствий Поста.

    '
- answer: 'Заданы два списка, содержащие одинаковое количество цепочек.  Спрашивается,
    можно ли, выбирая последовательности соответствующих  цепочек из этих двух списков,
    построить путем их конкатенации одну  и ту же цепочку. ПСП является важным примером
    неразрешимой проблемы.  Сводимость ПСП к ряду других проблем обеспечивает доказательство
    их неразрешимости

    '
  author: Филимонов Михаил
  id: 38
  questions:
  - 'Разрешима ли проблема соответствий Поста

    '
- answer: 'Вопрос о неоднозначности КС-грамматики (контекстно-свободной грамматики)
    неразрешим.  Неразрешимые проблемы, связанные с контекстно-свободными языками.  Посредством
    сведения ПСП(проблема соответствий Поста) к вопросу об определении некоторых свойств
    КС-грамматики можно доказать неразрешимость многих вопросов  о КС-языках или их
    грамматиках. В силу неразрешимости ПСП это сведение доказывает неразрешимость
    про блемы неоднозначности КС-грамматики.  Так же, например, о включении одного
    КС-языка в  другой или о пустоте пересечения двух КС-языков."

    '
  author: Филимонов Михаил
  id: 39
  questions:
  - 'Разрешим ли вопрос о неоднозначности КС-грамматики (контекстно-свободной грамматики)

    '
- answer: 'Нейтральный (единичный) элемент в контексте операций в регулярных выражениях
    — это элемент, для которого верно: если данная операция применяется к единичному
    элементу и некоторому выражению, то результат равен этому выражению. Для регулярных
    выражений нейтральные элементы зависят от конкретного типа операции: 1. Конкатенация:
    Нейтральным элементом для конкатенации является пустая строка (обозначается ε).
    При конкатенации любой строки с ε результат остается неизменным. 2. Объединение
    (дизъюнкция): Для операции объединения нейтральным элементом является пустое множество
    (обозначается ∅). Объединение любого выражения с ∅ не изменяет его.

    '
  author: Захарин Сергей
  id: 40
  questions:
  - 'Что называется нейтральным элементом операции в регулярных выражениях?

    '
- answer: 'Нулевой элемент (или аннулятор) в контексте операций в регулярных выражениях
    — это элемент, который при применении операции с другим выражением всегда возвращает
    сам нулевой элемент. В алгебре нулевой элемент обнуляет результат операции, независимо
    от второго аргумента. В контексте регулярных выражений это понятие также применимо,
    и оно зависит от типа операции: 1. Конкатенация: Для конкатенации нулевым элементом
    является пустое множество (обозначаемое ∅). При конкатенации любого выражения
    с ∅ результатом всегда будет ∅. 2. Объединение (дизъюнкция): Для операции объединения
    (дизъюнкции) нулевого элемента как такового не существует. Объединение с ∅ даёт
    исходное выражение, а не ∅, то есть ∅ здесь является нейтральным, а не нулевым
    элементом.

    '
  author: Захарин Сергей
  id: 41
  questions:
  - 'Что называется нулевым элементом (аннулятором) операции в регулярных выражениях?

    '
- answer: 'Два выражения с переменными являются эквивалентными, если при подстановке
    любых языков вместо переменных оба выражения представляют один и тот же язык.

    '
  author: Захарин Сергей
  id: 42
  questions:
  - 'В каком случае два регулярных выражения с переменными являются эквивалентными?

    '
- answer: 'Объединение и конкатенация ассоциативны. Коммутативно только объединение.
    Конкатенация дистрибутивна относительно объединения. Объединение идемпотентно.

    '
  author: Захарин Сергей
  id: 43
  questions:
  - 'Какие операторы регулярных выражений ассоциативны? Коммутативны? Дистрибутивны?
    Идемпотентны?

    '
- answer: 'Закон идемпотентности операции объединения утверждает, что объединение
    двух одинаковых выражений можно заменить одним таким выражением.

    '
  author: Захарин Сергей
  id: 44
  questions:
  - 'Закон идемпотентности операции объединения для регулярных выражений

    '
- answer: 'Строку также часто называют словом. Обращением строки (a_1)(a_2)...(a_n)
    называется строка, записанная в обратном порядке, т.е. (a_n)(a_n-1)...(a_1). Обращение
    w обозначается w^R. Таким образом, например, (0010)^R есть 0100, а ε^R = ε.

    '
  author: Захарин Сергей
  id: 45
  questions:
  - 'Что такое обращение строки в формальных языках?

    '
  - 'Реверс строки

    '
- answer: 'Обращение языка L, обозначаемое L^R, состоит из всех строк, являющихся
    реверсами (обращениями) строк из исходного языка L. То есть, если L — это язык,
    состоящий из строк w_1, w_2, ..., w_n, то обращение этого языка L^R включает строки,
    полученные путём инвертирования каждой из строк языка L. Например, если L = {001,
    10, 111}, то L^R = {100, 01, 111}.

    '
  author: Захарин Сергей
  id: 46
  questions:
  - 'Что такое обращение языка?

    '
- answer: 'Строку также часто называют словом. Гомоморфизм строк — это такая функция
    на множестве строк, являющаяся расширением функции отображения символов алфавита
    в строки относительно операции конкатенации.

    '
  author: Захарин Сергей
  id: 47
  questions:
  - 'Что такое гомоморфизм строк в регулярных языках?

    '
- answer: 'Регулярное выражение над алфавитом Σ = {c_1, c_2, …, c_k} — способ порождения
    языка над Σ. Определяется рекурсивно следующим образом: Для любого i слово c_i
    является регулярным выражением, задающим язык из одного слова ci. ε является регулярным
    выражением, задающим язык из одной пустой строки, а ∅ — пустой язык. Если a_1
    и a_2 являются регулярными выражениями, задающими языки L_1 и L_2 соответственно,
    то (a_1)|(a_2) — регулярное выражение, задающее L_1 ⋃ L_2. Если a_1 и a_2 являются
    регулярными выражениями, задающими языки L_1 и L_2 соответственно, то (a_1)(a_2)
    — регулярное выражение, задающее L_1L_2. Если a_1 является регулярным выражением,
    задающим язык L_1, то (a_1)* — регулярное выражение, задающее (L_1)*.

    '
  author: Захарин Сергей
  id: 48
  questions:
  - 'Как рекурсивно определяется регулярное выражение?

    '
- answer: 'Итерация (“звездочка”, или замыкание Клини) языка L обозначается L* и представляет
    собой множество всех тех цепочек, которые можно образовать путем конкатенации
    любого количества цепочек из L. При этом допускаются повторения, т.е. одна и та
    же цепочка из L может быть выбрана для конкатенации более одного раза. Например,
    если L = {0, 1}, то L* — это все цепочки, состоящие из нулей и единиц. Если L
    = {0, 11}, то в L* входят цепочки из нулей и единиц, содержащие четное количество
    единиц, например, цепочки 011, 11110 или ε, и не входят цепочки 01011 или 101.
    Более формально язык L* можно представить как бесконечное объединение L^i, где
    L^0 = ε, L^1 = L и Li для i>1 равен LL...L(конкатенация i копий L).

    '
  author: Захарин Сергей
  id: 49
  questions:
  - 'Что такое замыкание Клини и где оно используется в регулярных выражениях?

    '
- answer: 'Также называется леммой о накачке для контекстно-свободных языков. Пусть
    L — контекстно-свободный язык над алфавитом Σ, тогда существует такое натуральное
    n, что для любого слова ω, принадлежащего L, длины не меньше n найдутся слова
    u, v, x, y, z, принадлежащие Σ*, для которых верно: uvxyz = ω, vy ≠ ε, |vxy| <=
    n и ∀k >= 0 u(v^k)x(y^k)z ∈ L. Иначе говоря, любую достаточно длинную цепочку
    в КС-языке можно разбить на пять частей так, что повторение второй и четвёртой
    частей произвольное количество раз (возможно, 0) не приведут к выходу за пределы
    языка.

    '
  author: Захарин Сергей
  id: 50
  questions:
  - 'Лемма о разрастании для контекстно-свободных языков

    '
  - 'Лемма о накачке для контекстно-свободных языков

    '
- answer: 'Регулярные языки замкнуты относительно следующих операций: 1. Объединение
    2. Пересечение 3. Дополнение 4. Разность 5. Обращение 6. Итерация (звездочка)
    7. Конкатенация 8. Гомоморфизм (подстановка цепочек вместо символов языка) 9.
    Обратный гомоморфизм.

    '
  author: Захарин Сергей
  id: 51
  questions:
  - 'Относительно каких операций замкнуты регулярные языки?

    '
  - 'Объединение двух регулярных языков

    '
  - ' Пересечение двух регулярных языков

    '
  - ' Разность двух регулярных языков

    '
- answer: 'Для регулярных выражений существует три закона, связанных с этими понятиями.
    • ∅ + L = L + ∅ = L. Этот закон утверждает, что ∅ является единицей объединения.
    • εL = Lε = L. Этот закон гласит, что ε является единицей конкатенации. • ∅L =
    L∅ = ∅. Этот закон утверждает, что ∅ является нулевым элементом конкатенации.

    '
  author: Захарин Сергей
  id: 52
  questions:
  - 'Законы регулярных выражений, связанные с единичным элементом и нулевым элементом

    '
- answer: 'Существует три приема интерпретации ленты и конечного управления машины
    Тьюринга: память в состоянии, многодорожечные ленты, подпрограммы.

    '
  author: Пишикина Мария
  id: 53
  questions:
  - 'Какие существуют приемы интерпретации ленты и конечного управления машины Тьюринга?

    '
- answer: 'При использовании приема «Многодорожечные ленты» рассматривается лента
    машины Тьюринга, образованная несколькими дорожками.  Каждая дорожка может хранить
    один символ (в одной клетке), и алфавит машины Тьюринга состоит из кортежей, с
    одним компонентом для каждой «дорожки».

    '
  author: Пишикина Мария
  id: 54
  questions:
  - 'Опишите прием «Многодорожечные ленты» в машине Тьюринга.

    '
- answer: 'Каждый язык, допускаемый многоленточной машиной Тьюринга, рекурсивно перечислим.

    '
  author: Пишикина Мария
  id: 55
  questions:
  - 'Существуют ли не рекурсивно перечислимые языки, допускаемые многоленточными машинами
    Тьюринга?

    '
- answer: 'Время, необходимое одноленточной машине Тьюринга для имитации n переходов
    многоленточной машины Тьюринга, есть O(n^2).

    '
  author: Пишикина Мария
  id: 56
  questions:
  - 'Какое время необходимо одноленточной машине Тьюринга для имитации переходов многоленточной
    машины Тьюринга?

    '
- answer: 'Мультистековая (многомагазинная) машина представляет собой детерминированный
    МП-автомат (или машина с магазинной памятью) с несколькими магазинами. Он получает
    свои входные данные, как и МП-автомат, из некоторого их источника,  а не с ленты
    или из магазина, как машина Тьюринга. Мультистековая машина имеет конечное управление,
    то есть конечное множество состояний, и конечный магазинный алфавит, используемый
    для всех магазинов.  Переход мультистековой машины основывается на состоянии,
    входном символе и верхних символах всех магазинов.

    '
  author: Пишикина Мария
  id: 57
  questions:
  - 'Что такое «мультистековая (многомагазинная) машина»?

    '
- answer: '«Односчетчиковые машины» — это класс машин, которые могут запоминать значение
    одного целого числа («счетчика») и совершать различные переходы в зависимости
    от того, равен ли счетчик 0.  Односчетчиковая машина может только прибавить 1
    к счетчику или вычесть 1 из него, но не способна различать различные ненулевые
    значения счетчика. Каждый язык, допускаемый односчетчиковой машиной, является
    КС-языком. Контекстно-свободный (КС) язык — это язык, задаваемый контекстно-свободной
    грамматикой.  Контекстно-свободной грамматикой называется грамматика, у которой
    в левых частях всех правил стоят только одиночные нетерминалы.

    '
  author: Пишикина Мария
  id: 58
  questions:
  - 'Как называется язык, который допускается односчетчиковой машиной?

    '
- answer: 'Имитация машины Тьюринга на компьютере в принципе возможна, если допустить,
    что для имитации значащей части ленты существует потенциально бесконечный запас
    сменных запоминающих устройств вроде диска.  Поскольку физические ресурсы, необходимые
    для создания дисков, конечны, данный довод сомнителен. Однако, поскольку пределы
    памяти Вселенной неизвестны или, без сомнения, обширны,  предположение о бесконечности
    ресурсов (как для ленты машины Тьюринга) является практически реалистичным и в
    целом допустимо.

    '
  author: Пишикина Мария
  id: 59
  questions:
  - Можно ли имитировать машину Тьюринга на компьютере?
- answer: 'Машина Тьюринга может имитировать n шагов компьютера за O(n^6) своих шагов.

    '
  author: Пишикина Мария
  id: 60
  questions:
  - 'Какое время необходимо одноленточной машине Тьюринга для имитации переходов компьютера?

    '
- answer: 'Несмотря на кажущуюся большую мощность недетерминированных машин в связи
    с тем, что они выполняют несколько возможных вычислений сразу  (требуя только,
    чтобы хоть одно из них заканчивалось в допускающем состоянии), любой язык, допускающийся
    недетерминированной машиной Тьюринга,  также допускается и обычной детерминированной
    машиной Тьюринга, поскольку она может моделировать любой недетерминированный переход,
    делая многократные копии состояния, если встречается неоднозначность.

    '
  author: Пишикина Мария
  id: 61
  questions:
  - 'Почему язык, допускающийся в недетерминированных машинах Тьюринга, также допускается
    и обычной детерминированной машиной Тьюринга?

    '
- answer: 'Машина Тьюринга может имитировать память и управление реального компьютера
    путем использования одной ленты для записи всех элементов памяти и их содержимого
    — регистров, основной памяти, дисков и других запоминающих устройств.  Таким образом,
    можно быть уверенным, что все, не выполнимое машиной Тьюринга, не может быть сделано
    и компьютером.

    '
  author: Пишикина Мария
  id: 62
  questions:
  - 'Как машина Тьюринга имитирует реальный компьютер?

    '
- answer: 'Имея дело с рандомизированными машинами Тьюринга, нужно быть более аккуратным
    с тем, что значит допускание входа такой машиной; становится возможным, что машина
    Тьюринга не определяет функции математически корректно (т.е. независимо от рандомизированных
    данных).  Проблема в том, что при анализе действий рандомизированной машины Тьюринга
    со входом приходится рассматривать все возможные случайные последовательности
    на второй ленте. Вполне возможно, что машина Тьюринга  допускает при одних случайных
    последовательностях, но отвергает при других; в действительности, если рандомизированная
    машина Тьюринга должна делать что-то более эффективно, чем детерминированная машина
    Тьюринга,  то существенно, чтобы различные последовательности на рандомизированной
    ленте приводили к различному поведению.

    '
  author: Пишикина Мария
  id: 63
  questions:
  - 'Какая проблема может возникнуть при допуске языка в рандомизированную машину
    Тьюринга?

    '
- answer: "1) Композиция (суперпозиция) машин Тьюринга - пусть две машины Тьюринга\
    \ X и Y вычисляют функции f(P) и g(P) соответственно, тогда можно построить машину\
    \ Тьюринга T = Y(X), вычисляющую суперпозицию функций g(f(P)).  2) Разветвление\
    \ машин Тьюринга - пусть две машины Тьюринга X и Y вычисляют функции f(P) и g(P)\
    \ соответственно, причём множеством значений функции f(P) является множество {0,\
    \ 1}, тогда можно построить машину Тьюринга T = X->Y,  которая перерабатывает\
    \ слово P в g(P), если f(P)=1 и оставляет его без изменений если f(P)=0.  3) Цикл\
    \ машин Тьюринга - пусть две машины Тьюринга X и Y вычисляют функции f(P) и g(P)\
    \ соответственно, причём множеством значений функции f(P) является множество {0,\
    \ 1}, тогда можно построить машину Тьюринга T = X∘Y, которая  выполняет следующую\
    \ последовательность действий: \n  1 - вычисляет f(P) и если f(P)=1, то вычисляет\
    \ новое значение P=g(P), а если f(P)=0, то переходит к заключительному состоянию\
    \ с выходным словом P; \n  2 - повторяет действие 1 до тех пор пока для очередного\
    \ значения P не будет выполнено f(P)=0.\n"
  author: Пишикина Мария
  id: 64
  questions:
  - 'Перечисли возможные операции над машинами Тьюринга.

    '
- answer: 'Машина Тьюринга называется самоприменимой, если она останавливается, когда
    в качестве входного слова для неё используется описание самой машины.

    '
  author: Пишикина Мария
  id: 65
  questions:
  - 'Что такое самоприменимая машина Тьюринга?

    '
- answer: 'Определение 1: Частично упорядоченное множество (A, ≤) называется фундированным,  если
    в любом непустом подмножестве A есть минимальный элемент.   Определение 2: Частично
    упорядоченное множество (A, ≤) называется фундированным, если в нём нет бесконечных  убывающих
    цепей, то есть в A нельзя выбрать бесконечную последовательность элементов a0,
    a1, a2, …, такую,  что a0 > a1 > a2 > … > an > …  Определение 3: Частично упорядоченное
    множество (A, ≤) называется фундированным, если для него выполняется принцип индукции:
    для любого свойства P(x) выполнено условие: [∀a ((∀a’ < a (P(a’))) → P(a))] →
    (∀a (P(a))). То есть, если для любого a из множества A из истинности P(a’) для
    всех a’ < a следует истинность P(a), то свойство P(a) верно при всех a. Теорема:
    Три определения фундированного множества эквивалентны друг другу.

    '
  author: Дьячков Егор
  id: 66
  questions:
  - 'Определение фундированного множества

    '
- answer: 'Трансфинитная индукция — метод доказательства, обобщающий математическую
    индукцию на случай несчетного числа  значений параметра. Трансфинитная индукция
    основана на следующем утверждении: пусть M — вполне упорядоченное  множество,
    P(x) — некоторое утверждение для x из M. Если для любого x из M, из того, что
    P(y) истинно  для всех y < x, следует, что верно P(x), и если P(x) верно для минимального
    элемента множества M,  то утверждение P(x) верно для любого x из M.

    '
  author: Дьячков Егор
  id: 67
  questions:
  - 'Что называется трансфинитной индукцией?

    '
- answer: 'Теоретико-множественные операции: Пусть K,L ⊆ Σ∗. 1) Объединение K и L:
    K ∪ L = { w | w ∈ K или w ∈ L} 2) Пересечение K и L: K ∩ L = { w | w ∈ K и w ∈
    L} 3) Язык Σ∗ − L называется дополнением (англ. complement) языка L относительно
    алфавита Σ. Когда из контекста ясно, о каком алфавите идёт речь, говорят просто,
    что язык Σ∗ − L является дополнением языка L. 4) Конкатенация K и L: Конкатенация
    двух языков, K и L — это язык, состоящий из всех возможных конкатенаций строки
    из K и строки из L. KL = K·L={ uv | u ∈ K и v ∈ L} 5) Степень языка: конкатенация
    k экземпляров одного и того же языка называется её k-й степенью. L^k = L · ...
    · L (повторяется k раз) = {w_1 ... w_k | w_1,...,w_k ∈ L}. В частности, L^0 =
    {ε} для всякого языка L. 6) Замыкание Клини (англ. Kleene closure): замыканием
    языка L (обозначение L∗) называется язык ∪(L^n), где n ∈ [0,∞).  Другими словами,
    это объединение L^n при n от нуля (включительно) до бесконечности.  Эта операция
    также называется звёздочкой Клини (англ. Kleene star, star operation). 7) Гомоморфизм:
    Пусть Σ_1 и Σ_2 — алфавиты. Если отображение h : Σ∗_1 → Σ∗_2 удовлетворяет условию
    h(x · y) = h(x) · h(y) для всех слов x ∈ Σ∗_1 и y ∈ Σ∗_1, то отображение h называется
    гомоморфизмом (морфизмом). Также могут использоваться другие операции, например,
    обратный гомоморфизм.

    '
  author: Дьячков Егор
  id: 68
  questions:
  - 'Какие существуют операции над языками в теории формальных языков?

    '
- answer: 'Теорема Цермело (англ. Zermelo’s theorem): На любом множестве A можно ввести
    такой порядок ≤, что множество (A, ≤) будет вполне упорядоченным.

    '
  author: Дьячков Егор
  id: 69
  questions:
  - 'Теорема Цермело

    '
- answer: 'Свободным моноидом  M  над множеством  S  (обозначается как  M_S ) называется
    моноид над множеством   S^*  — набором всевозможных последовательностей (или списков)
    конечной длины (в том числе и нулевой),  образованных из элементов множества  S,
    — с ассоциативной операцией. Поскольку операция в свободном моноиде не накладывает
    дополнительных соотношений между элементами множества  S,  все слова в  S^*  однозначно
    определяются своим синтаксисом. Часто для свободного моноида над множеством  S   используется
    операция конкатенации, которая в данном случае является полугрупповой операцией.
    Нейтральным элементом  свободного моноида является пустая последовательность.

    '
  author: Дьячков Егор
  id: 70
  questions:
  - 'Что такое свободный моноид над множеством?

    '
- answer: 'В теории автоматов используется несколько рекурсивно определяемых понятий,
    относительно которых будет необходимо  доказывать те или иные утверждения. Важными
    примерами таких понятий являются деревья и выражения. Подобно индукции,  все рекурсивные
    определения включают базис, где определяется одна или несколько элементарных структур,
    и индуктивный  шаг, с помощью которого более сложные структуры определяются через
    структуры, определенные ранее.  Пример: Рассмотрим рекурсивное определение дерева.
    Базис: одиночный узел есть дерево, и этот узел является корнем  дерева. Индукция:
    Если T1, T2, ..., Tk — деревья, то можно построить новое дерево следующим образом.  Возьмем
    в качестве корня новый узел N. Возьмем по одному экземпляру деревьев T1, T2 ,...,
    Tk.  Добавим ребра, соединяющие корень N с корнями каждого из деревьев T1, T2,
    ..., Tk.

    '
  author: Дьячков Егор
  id: 71
  questions:
  - 'Опиши структурную индукцию и приведи пример ее использования

    '
- answer: 'Нётерова индукция — это обобщение трансфинитной индукции, которое заключается
    в следующем:  пусть ⟨X, R⟩ — фундированное множество, P(x) — некоторое утверждение
    об элементах множества X, и пусть мы хотим  показать, что P(x) верно для всех
    x ∈ X. Для этого достаточно показать, что если x ∈ X, и P(y) верно для всех  таких
    y ∈ X, что y R x, то P(x) также верно. Другими словами: ∀x ∈ X ((∀y ∈ X (y R x
    → P(y))) → P(x)) → ∀x ∈ X (P(x)).

    '
  author: Дьячков Егор
  id: 72
  questions:
  - 'Что такое нётерова индукция?

    '
- answer: 'Отношением порядка, или частичным порядком, на множестве M называется бинарное
    отношение ϕ на M (определяемое  некоторым множеством R_{ϕ} ⊆ M × M), удовлетворяющее
    следующим условиям: Рефлексивность: ∀a (a ϕ a)  Транзитивность: ∀a, b, c ((a ϕ
    b) ∧ (b ϕ c) ⇒ a ϕ c) Антисимметричность: ∀a, b ((a ϕ b) ∧ (b ϕ a) ⇒ a = b) Множество
    M, на котором задано отношение частичного порядка, называется частично упорядоченным.  Если
    быть совсем точным, то частично упорядоченным множеством называется пара ⟨M, ϕ⟩,
    где M — множество,  а ϕ — отношение частичного порядка на M.

    '
  author: Дьячков Егор
  id: 73
  questions:
  - 'Что называется частичным порядком на множестве M?

    '
- answer: 'Размерность частично упорядоченного множества ⟨M, ϕ⟩ равна максимальной
    численности совокупности линейных порядков <_i (i ∈ I). В основе этого определения
    находится свойство продолжаемости частичного порядка до линейного.

    '
  author: Дьячков Егор
  id: 74
  questions:
  - 'Чему равна размерность частично упорядоченного множества?

    '
- answer: '1) Линейно упорядоченные: Частично упорядоченное множество (X,<) называется
    линейно упорядоченным, или просто упорядоченным, если любые x, y ∈ X сравнимы.
    2) Плотные: Два элемента x, y линейно упорядоченного множества называют соседними,
    если x < y и не существует элемента между ними, то есть такого z, что x < z <
    y. Линейно упорядоченное множество называют плотным, если в нём нет соседних
    элементов (то есть между любыми двумя есть третий). 3) Вполне упорядоченные:
    Фундированные линейно упорядоченные множества называются вполне упорядоченными,
    а соответствующие порядки — полными. 4) Тривиально упорядоченные: Диагональное
    отношение △ (однородное на множестве A отношение ρ называется △: диагональным
    (единичным), если xρy ⇔ x = y. Для единичного отношения на A часто используют
    также обозначение 1_A.)  на произвольном множестве можно рассматривать не только
    как эквивалентность, но и как частичный порядок. Множество с таким порядком называют
    тривиально упорядоченным. 5) Решётки: Частично упорядоченное множество (L, ≤)
    называется решёткой, если для любой пары элементов a, b ∈ L существуют sup{a,
    b} и inf {a, b} 6) Фундированные: Частично упорядоченное множество (P, ≤) называется
    фундированным, если всякое непустое подмножество S ⊆ P имеет минимальный элемент.

    '
  author: Дьячков Егор
  id: 75
  questions:
  - 'Какие существуют специальные типы частично упорядоченных множеств?

    '
- answer: 'Каждое частично упорядоченное множество (и каждый предпорядок) можно рассматривать
    как категорию, в которой каждое  множество морфизмов Hom(A, B) состоит не более
    чем из одного элемента. Например, эту категорию можно определить так: Hom(A, B)
    = {(A, B)}, если A ≤ B (и пустое множество в противном  случае); правило композиции
    морфизмов: (y, z) ∘ (x, y) = (x, z). Каждая категория-предпорядок эквивалентна
    частично  упорядоченному множеству. Функтор из категории-частично упорядоченного
    множества — это коммутативная диаграмма.

    '
  author: Дьячков Егор
  id: 76
  questions:
  - 'Как можно рассматривать частично упорядоченное множество в теории категорий?

    '
- answer: 'Совместная индукция — это метод, который используется, когда невозможно
    доказать по индукции отдельное утверждение.  Вместо этого необходимо доказать
    одновременно целую группу утверждений S_1(n), S_2(n), …, S_k(n) с помощью индукции  по
    n. В теории автоматов такая ситуация возникает достаточно часто. Например, существует
    общая ситуация,  когда действие автомата описывается группой утверждений, по одному
    для каждого состояния. В этих утверждениях  говорится, какие последовательности
    входных сигналов приводят автомат в каждое из его состояний. Строго говоря,  доказательство
    группы утверждений не отличается от доказательства их конъюнкции (логическое «И»)
    — всех этих  утверждений одновременно. Например, группу утверждений S_1(n), S_2(n),
    …, S_k(n) можно заменить одним утверждением  S_1(n) ∧ S_2(n) ∧ … ∧ S_k(n). Однако,
    если необходимо доказывать несколько действительно независимых утверждений,  то
    проще рассматривать их отдельно, доказывая для каждого свой базис и индуктивный
    шаг.  Такой тип доказательства называется совместной индукцией.

    '
  author: Дьячков Егор
  id: 77
  questions:
  - 'Опиши совместную индукцию

    '
- answer: 'Ординалом называется порядковый тип вполне упорядоченного множества, то
    есть класс всех изоморфных ему упорядоченных  множеств. Теорема (о трансфинитной
    рекурсии): Фиксируем некоторый ординал α. Пусть h : X^{<α} → X. Тогда существует
    и единственная f : α → X такая,  что для любого β ∈ α, f(β) = h(f ⏐ β). То есть
    можно построить единственную функцию f, определённую на всём ординале α, такую,  что
    её значение в каждой точке β определяется значениями функции на всех предыдущих
    отрезках  (меньших β) с использованием некоторого правила, заданного функцией
    h.

    '
  author: Дьячков Егор
  id: 78
  questions:
  - 'Напиши теорему о трансфинитной рекурсии

    '
- answer: 'Аксиома выбора: Для любого непустого множества x существует выбирающая
    функция, т.е. ψ : 2^x \{∅} → x , такая, что ∀y ⊆ x : y ≠ ∅ → ψ(y) ∈ y. Аксиома
    регулярности (фундирования): каждое непустое множество X содержит элемент x такой,
    что X ∩ x = ∅. ∀X(¬(X = ∅) → (∃x ∈ X)(x ∩ X = ∅)) То есть для любого не пустого
    множества Х, существует элемент х в Х такой, что пересечение Х и х пусто. Это
    означает, что (х) не содержит в себе элементов из (Х). Следствие: не существует
    бесконечной последовательности множеств x_0,x_1,x_2,... такой, что x_0 ∋ x_1
    ∋ x_2 ∋ ...  (в частности, ∃/ X(X ∈ X)) — достаточно рассмотреть X = {x_0,x_1,x_2,...}
    и применить аксиому. Из аксиомы выбора  следует, что верно и обратное: из несуществования
    бесконечной последовательности x_0 ∋ x_1 ∋ x_2 ∋ ... вытекает  аксиома регулярности
    — иначе (∃X ≠ ∅)(∀x ∈ X)(x ∩ X ≠ ∅) и по аксиоме выбора существует множество
    {x_0,x_1,x_2,...},  в котором x_0 ∈ X, x_1 ∈ X ∩ x_0, x_2 ∈ X ∩ x_1 и т.д.

    '
  author: Дьячков Егор
  id: 79
  questions:
  - 'Напиши аксиому регулярности и ее следствие

    '
- answer: "Для проверки принадлежности слова w к языку L, распознаваемому детерминированным\
    \ конечным автоматом (сокр. ДКА), используется рекурсивный алгоритм, который определяет,\
    \ можно ли дойти до заключительного состояния автомата, прочитывая символы из\
    \ w. \nНа вход подаются: - детерминированный конечный автомат A, заданный как\
    \ кортеж (Q, Σ, δ, q₀, F), где Q — множество состояний, Σ — алфавит, δ — функция\
    \ переходов, q₀ — начальное состояние, F — множество заключительных состояний;\
    \ - начальное состояние q из множества Q; - слово w, которое представляется как\
    \ последовательность символов из алфавита Σ.\nАлгоритм возвращает true, если слово\
    \ w принадлежит языку, распознаваемому автоматом из состояния q, и false в противном\
    \ случае. \nПошаговое описание алгоритма: 1. Если слово w пустое (обозначается\
    \ ε), алгоритм проверяет, принадлежит ли текущее состояние q множеству заключительных\
    \ состояний F. Если принадлежит, возвращается true; в противном случае возвращается\
    \ false. 2. Если слово w непустое, алгоритм разбивает его на первый символ (head(w))\
    \ и оставшуюся часть (tail(w)). Затем он вызывает функцию δ, чтобы перейти в следующее\
    \ состояние на основе текущего состояния q и первого символа head(w). После этого\
    \ алгоритм рекурсивно вызывает себя для оставшейся части слова tail(w) и нового\
    \ состояния, полученного после перехода.\nСложность алгоритма зависит от длины\
    \ слова w: O(|w|), где |w| — это длина слова.\n"
  author: Шиятов Наиль
  id: 80
  questions:
  - 'Как реализуется алгоритм для проверки принадлежности слова w к языку L в детерминированном
    конечном автомате (сокр. ДКА)?

    '
- answer: "Реализация операции дополнения для детерминированного конечного автомата\
    \ (сокр. ДКА) предполагает преобразование автомата таким образом, чтобы он принимал\
    \ все слова, которые не были приняты исходным автоматом. Поскольку ДКА имеет единственный\
    \ путь для каждого слова, которое принимается только в случае достижения финального\
    \ состояния, можно поменять местами финальные и нефинальные состояния и добавить\
    \ состояние-ловушку, если это необходимо, для корректного дополнения. Алгоритм\
    \ предусматривает линейную сложность и включает состояние-ловушку, чтобы гарантировать,\
    \ что автомат правильно обрабатывает все возможные слова языка. Если автомат не\
    \ полон (то есть не определены переходы для некоторых символов), добавляется состояние-ловушка,\
    \ в которое ведут все отсутствующие переходы из каждого состояния. Входные данные:\
    \ - Детерминированный конечный автомат A, представленный как (Q, Σ, δ, q₀, F),\
    \ где Q — множество состояний, Σ — алфавит, δ — функция переходов, q₀ — начальное\
    \ состояние, а F — множество финальных состояний.\nНа выходе: - Новый ДКА B, представленный\
    \ как (Q′, Σ, δ′, q′₀, F′), такой что язык L(B) является дополнением языка L(A).\n\
    Шаги алгоритма: 1. Установить Q′ = Q, δ′ = δ, q′₀ = q₀ и F′ = ∅. 2. Если у автомата\
    \ отсутствуют переходы для некоторых символов в состояниях, добавить новое состояние\
    \ trap (ловушка) в Q′. Обновить δ′, направив все отсутствующие переходы из каждого\
    \ состояния в trap. 3. Для каждого состояния q из Q:\n   - Если q не принадлежит\
    \ F (то есть не является финальным состоянием), добавить q в F′.\n4. Включить\
    \ trap в F′, чтобы гарантировать, что любое слово, которое не принимается в исходном\
    \ автомате, будет принято в дополненном автомате.\n"
  author: Шиятов Наиль
  id: 81
  questions:
  - 'Как реализуется операция дополнения языка в детерминированном конечном автомате
    (сокр. ДКА)?

    '
- answer: 'Операция дополнения для детерминированного конечного автомата (сокр. ДКА)
    сохраняет минимальность, поскольку каждое состояние дополненного автомата B распознает
    дополнение языка, который распознавало то же состояние в исходном автомате A.
    Если состояния исходного автомата A распознают попарно разные языки, то и состояния
    автомата B также будут распознавать различные языки. В соответствии с критерием
    минимальности, ДКА является минимальным, если его состояния распознают различные
    языки, то есть если каждое состояние соответствует уникальному подмножеству языка.
    Однако, если исходный минимальный ДКА был сокращённым (trim), то после дополнения
    может появиться состояние-ловушка. Для сохранения числа состояний может потребоваться
    удалить это состояние-ловушку.

    '
  author: Шиятов Наиль
  id: 82
  questions:
  - 'Почему операция дополнения для детерминированного конечного автомата (сокр. ДКА)
    сохраняет минимальность автомата?

    '
- answer: "Цель универсального алгоритма заключается в том, чтобы, принимая два детерминированных\
    \ конечных автомата (сокр. ДКА), распознающих языки L₁ и L₂, и бинарную булевую\
    \ операцию (например, объединение, пересечение или разность), возвращать ДКА,\
    \ распознающий результат применения этой операции к языкам L₁ и L₂. Для корректной\
    \ работы алгоритма с операциями объединения или разности необходимо, чтобы в исходных\
    \ ДКА явно присутствовали все ловушки (или «непринимающие» состояния). Если ловушка\
    \ отсутствует, алгоритм может не учесть все возможные переходы, и результат может\
    \ быть некорректным. Алгоритм работает следующим образом:\nВход: - ДКА A₁ = (Q₁,\
    \ Σ, δ₁, q₀₁, F₁) - ДКА A₂ = (Q₂, Σ, δ₂, q₀₂, F₂)\nВыход: - Новый ДКА A = (Q,\
    \ Σ, δ, q₀, F), где L(A) — результат бинарной операции L(A₁) ♢ L(A₂)\nСтруктура\
    \ алгоритма: 1. Инициализация:\n   - Q, δ, F ← ∅.\n   - Начальное состояние q₀\
    \ ← [q₀₁, q₀₂].\n   - W ← {q₀} — очередь, содержащая начальное состояние.\n2.\
    \ Пока очередь W не пуста:\n   - Извлечь [q₁, q₂] из W.\n   - Добавить [q₁, q₂]\
    \ в Q.\n   - Если (q₁ ∈ F₁) ♢ (q₂ ∈ F₂), то добавить [q₁, q₂] в F.\n   - Для каждого\
    \ символа a из алфавита Σ:\n     - Вычислить δ₁(q₁, a) и δ₂(q₂, a).\n     - Если\
    \ пара состояний [δ₁(q₁, a), δ₂(q₂, a)] не находится в Q, добавить ее в W.\n \
    \    - Добавить переход ([q₁, q₂], a, [δ₁(q₁, a), δ₂(q₂, a)]) в δ.\n\nЛогика работы\
    \ с различными операциями: - Для операции объединения (L₁ ∪ L₂) нужно, чтобы каждое\
    \ состояние переходило в ловушку, если оно не может принять строку, которая не\
    \ принадлежит ни одному из языков. Поэтому наличие всех ловушек в исходных ДКА\
    \ обязательно. - Для операции пересечения (L₁ ∩ L₂) алгоритм работает аналогично,\
    \ но состояния будут попадать в финальные только если оба исходных состояния —\
    \ финальные. - Для операции разности (L₁ - L₂) алгоритм требует, чтобы все состояния,\
    \ которые могут перейти в финальные состояния, но не могут переходить в финальные\
    \ состояния второго автомата, были учтены и правильно обработаны.\nЭтот алгоритм\
    \ подходит для выполнения любых бинарных операций над языками, распознаваемыми\
    \ ДКА, с учетом правильной обработки состояния-ловушки для операции объединения\
    \ и пересечения.\n"
  author: Шиятов Наиль
  id: 83
  questions:
  - 'Какова цель и структура универсального алгоритма для выполнения бинарных булевых
    операций над языками, распознаваемыми детерминированным конечным автоматом (сокр.
    ДКА)?

    '
- answer: 'Количество состояний у результирующего детерминированного конечного автомата
    (ДКА), полученного в результате выполнения бинарной булевой операции (например,
    объединения, пересечения или разности) над двумя ДКА, будет O(|Q₁| ⋅ |Q₂|), где
    |Q₁| и |Q₂| — количество состояний в исходных автоматах A₁ и A₂. Это количество
    состояний достигается независимо от выполняемой булевой операции, поскольку для
    каждой пары состояний из A₁ и A₂ создается новое состояние в результирующем автомате.
    Для демонстрации достижимости этого предела рассмотрим алфавит Σ = {a} и язык
    Multₙ, который включает все слова длиной, кратной n. Минимальный ДКА для этого
    языка представляет собой цикл из n состояний, где начальное состояние также является
    единственным заключительным. Если взять два взаимно простых числа n₁ и n₂, то
    пересечение языков Multₙ₁ и Multₙ₂ будет равно языку Mult(n₁ ⋅ n₂), и минимальный
    ДКА для этого языка будет иметь не менее n₁ ⋅ n₂ состояний. Однако минимальность
    не сохраняется в общем случае. Например, минимальный ДКА для языка L ∩ L будет
    иметь только одно состояние, в то время как результат выполнения операции над
    автоматами (то есть объединения, пересечения или разности) будет иметь количество
    состояний, равное количеству состояний минимального ДКА для L. Это связано с тем,
    что операция бинарной булевой операции может привести к увеличению количества
    состояний, даже если исходные автоматы были минимальными. Важно также отметить,
    что для операции объединения двух ДКА, распознающих взаимно простые языки, результирующий
    автомат будет иметь количество состояний, равное произведению состояний этих двух
    автоматов. Это происходит, потому что все возможные комбинации состояний обоих
    автоматов должны быть учтены, и минимальность при этом не сохраняется из-за природы
    самой операции объединения.

    '
  author: Шиятов Наиль
  id: 84
  questions:
  - 'Каково количество состояний у результирующего детерминированного конечного автомата
    (сокр. ДКА) при выполнении бинарной булевой операции над двумя ДКА, и в каких
    случаях минимальность не сохраняется?

    '
- answer: 'Детерминированный конечный автомат (сокр. ДКА) принимает пустой язык тогда
    и только тогда, когда у него нет достижимых финальных состояний. Функция Empty(A)
    определяет, что автомат принимает пустой язык, если множество финальных состояний
    F пусто и если все финальные состояния недостижимы из начального состояния.

    В случае, когда автомат представлен как кортеж множеств (Q, Σ, δ, q₀, F), проверка
    на пустой язык сводится к выполнению двух шагов: 1. Проверка, что множество финальных
    состояний F пусто. 2. Проверка, что все финальные состояния недостижимы из начального
    состояния с помощью обхода графа состояний.

    Если финальные состояния F пусты, автомат сразу принимается как принимающий пустой
    язык. В случае, если F не пусто, алгоритм проверяет, достижимы ли эти состояния
    из начального состояния. Время выполнения зависит от реализации. Если мы храним
    булевое значение, указывающее, есть ли в ДКА конечное состояние, то сложность
    функции Empty() составляет O(1). Если для проверки, что F = ∅, требуется линейный
    обход множества состояний Q, то сложность будет O(|Q|), где |Q| — количество состояний.  При
    этом, поскольку из каждого состояния может исходить лишь константное число переходов,
    на оценку сложности не влияет размер множества переходов, если размер алфавита
    считается константным. В случае с недетерминированным конечным автоматом (сокр.
    НКА) количество переходов могло бы повлиять на сложность, но в ДКА это не так.

    '
  author: Шиятов Наиль
  id: 85
  questions:
  - 'Как определяется, что детерминированный конечный автомат (сокр. ДКА) принимает
    пустой язык, и какова сложность алгоритма проверки?

    '
- answer: 'Детерминированный конечный автомат (сокр. ДКА) принимает универсальный
    язык Σ* тогда и только тогда, когда все его состояния являются финальными. Автомат
    принимает универсальный язык, если множество финальных состояний F совпадает с
    множеством всех состояний Q автомата. Это условие гарантирует, что автомат будет
    принимать все слова из Σ*, так как любое слово приведет к одному из финальных
    состояний. Если автомат находится в нормальной форме (каждое состояние достижимо
    из начального), то проверка сводится к проверке равенства множества F и множества
    Q, что имеет сложность O(1), а также к проверке, что автомат полон (т.е. есть
    переходы по всем буквам из всех состояний). В противном случае, если автомат не
    находится в нормальной форме, необходимо сначала проверить достижимость состояний,
    что может потребовать O(|Q|) времени для поиска всех достижимых состояний, где
    |Q| — это количество состояний автомата. Затем, если все состояния достижимы,
    проверяется равенство множеств F и Q, что дает сложность O(|Q|).

    '
  author: Шиятов Наиль
  id: 86
  questions:
  - 'Как определяется, что детерминированный конечный автомат (сокр. ДКА) принимает
    универсальный язык Σ∗, и какова сложность алгоритма проверки?

    '
  - 'Как определить, что детерминированный конечный автомат (ДКА) принимает универсальный
    язык Σ∗

    '
  - 'Можно ли определить, что ДКА принимает универсальный язык?

    '
- answer: 'Для проверки того, что язык L(A₁), распознаваемый детерминированным конечным
    автоматом A₁, является подмножеством языка L(A₂), распознаваемого детерминированным
    конечным автоматом A₂, используется алгоритм, который строит все возможные комбинации
    состояний из обоих автоматов (т.е. пары состояний [q₁, q₂], где q₁ — состояние
    из A₁, а q₂ — состояние из A₂). Затем для каждой такой пары проверяется, что если
    состояние q₁ является финальным в A₁ (q₁ ∈ F₁), то состояние q₂ должно быть финальным
    в A₂ (q₂ ∈ F₂). Если находится хотя бы одна пара, где q₁ является финальным состоянием
    в A₁, а q₂ не является финальным в A₂, то алгоритм возвращает false, что означает,
    что L(A₁) не является подмножеством L(A₂). В противном случае, если таких пар
    не найдено, алгоритм возвращает true, подтверждая, что L(A₁) является подмножеством
    L(A₂).

    '
  author: Шиятов Наиль
  id: 87
  questions:
  - 'Как можно проверить, что язык, распознаваемый одним детерминированным конечным
    автоматом (сокр. ДКА), является подмножеством языка, распознаваемого другим ДКА?

    '
- answer: 'Равенство языков двух детерминированных конечных автоматов (сокр. ДКА)
    L(A₁) = L(A₂) проверяется с помощью симметрической разности L(A₁) Δ L(A₂). Если
    симметрическая разность пуста, то языки равны. Алгоритм проверки равенства двух
    языков модифицирует алгоритм проверки включения языков, проверяя, что для состояний
    [q₁, q₂] выполняется одно из следующих условий: если q₁ ∈ F₁ и q₂ ∉ F₂, или если
    q₁ ∉ F₁ и q₂ ∈ F₂, то возвращается false, что означает, что языки не равны. В
    противном случае возвращается true. Назовём такой алгоритм стандартным алгоритмом
    проверки равенства языков двух ДКА.

    '
  author: Шиятов Наиль
  id: 88
  questions:
  - 'Как проверяется равенство языков двух детерминированных конечных автоматов (сокр.
    ДКА)?

    '
- answer: 'Альтернативный подход заключается в минимизации двух детерминированных
    конечных автоматов (сокр. ДКА) A₁ и A₂, а затем проверке, являются ли они изоморфными.
    Проверка изоморфизма может быть пропущена, если применить алгоритм бисимуляции
    (англ. CSR, coarsest stable refinement) к объединению двух недетерминированных
    конечных автоматов (сокр. НКА) A₁ ∪ A₂ и разделить состояния на блоки. Языки равны,
    если начальные состояния обоих автоматов находятся в одном блоке после завершения
    алгоритма.

    '
  author: Шиятов Наиль
  id: 89
  questions:
  - 'Какой альтернативный подход существует для проверки равенства двух детерминированных
    конечных автоматов (сокр. ДКА), помимо алгоритма стандартного алгоритма проверки
    равенства языков двух ДКА?

    '
- answer: 'Если используется алгоритм Хопкрофта для вычисления бисимуляции (англ.
    CSR, coarsest stable refinement), то проверка равенства языков может быть выполнена
    за время O(n log n), где n — это сумма состояний автоматов A₁ и A₂.

    '
  author: Шиятов Наиль
  id: 90
  questions:
  - 'Какая сложность проверки равенства языков двух детерминированных конечных автоматов
    (сокр. ДКА) с использованием алгоритма Хопкрофта для вычисления бисимуляции (англ.
    CSR, coarsest stable refinement)?

    '
- answer: 'Первое преимущество заключается в том, что стандартный алгоритм проверки
    равенства языков двух детерминированных конечных автоматов (сокр. ДКА) A₁ и A₂
    работает "на лету" (on-the-fly). Это позволяет проверять равенство языков L(A₁)
    и L(A₂) ещё на этапе их построения и прерывать выполнение при обнаружении различий.
    Второе преимущество — возможность модифицировать алгоритм так, чтобы он возвращал
    контрпример (witness) — слово, принадлежащее симметрической разности L(A₁) и L(A₂),
    если языки не равны.

    '
  author: Шиятов Наиль
  id: 91
  questions:
  - 'Какие преимущества имеет стандартный алгоритм проверки равенства двух детерминированных
    конечных автоматов (сокр. ДКА) по сравнению с методом минимизации автоматов для
    проверки равенства языков?

    '
- answer: 'Частичные производные Антимирова — это метод, который используется в классической
    теории автоматов для преобразования регулярных выражений в конечные автоматы.
    Для вычисления частичной производной от большого регулярного выражения, алгоритм
    вычисляет частичные производные рекурсивно. Базовые случаи: 1. Если регулярное
    выражение состоит из одного символа c, то его частичная производная по c равна
    пустому слову. 2. Если регулярное выражение состоит из одного символа, отличного
    от c, то его частичная производная по c пустое множество. 3. Частичная производная
    от пустого слова ε по любому символу пустое множество. Сложные случаи: Пусть r_1
    и r_2 - регулярные выражения, L - язык, который описывается регулярным выражением.  1.
    Если пустое слово принадлежит L(r_1), то частичная производная от r_1 r_2 по c
    получается путем взятия частичных производных от r_1 и r_2 по c и конкатенацией
    результата со вторым регулярным выражением r_2. 2. Если пустое слово не принадлежит
    L(r_1), то частичная производная от r_1 r_2 по c получается путем взятия частичной
    производной от r_1 по c и конкатенацией результата со вторым регулярным выражением
    r_2. 3. Частичная производная от r_1 | r_2 по c является объединением частичных
    производных от r_1 и r_2 по c. 4. Частичная производная от r* по c состоит из
    всех конкатенаций r''r*, где r'' - это частичная производная от r по c. Алгоритм
    построения частных производных возвращает их множество. Полученные частичные производные
    используются для построения автомата Антимирова, где состояния автомата соответствуют
    элементам этого множества.

    '
  author: Егорова Алиса
  id: 92
  questions:
  - 'Как можно вычислить частичные производные Антимирова?

    '
- answer: 'Бисимуляция определяет, когда два автомата ведут себя одинаково с точки
    зрения наблюдателя, который может видеть только входные символы и выходные состояния.
    Чтобы определить отношение бисимуляции на конечных автоматах, к отношению бисимуляции
    на LTS(Система размеченных переходов) нужно добавить ограничения на бисимуляцию
    начальных и конечных состояний. Более точно, для бисимуляции НКА(недетерминированный
    конечный автомат) A1 и A2 необходимы следующие условия:  1) каждому состоянию
    A1 бисимилярно состояние A2 и наоборот  2) стартовому состоянию A1 бисимилярно
    стартовое состояние A2  2) каждому финальному состоянию A1 бисимилярно финальное
    состояние A2 и наоборот  Бисимилярные НКА распознают равные языки. Состояния q_i
    и q_j в НКА А бисимилярны, если они связаны LTS-бисимуляцией и имеют одинаковую
    финальность в А. Бисимуляцию НКА можно переформулировать как отношение бисимуляции
    состояний НКА такое, что стартовые состояния бисимилярны. Отношение бисимуляции
    имеет важное свойство: бисимилярные состояния в автомате можно объединить без
    изменения его семантики. Это преобразование часто позволяет существенно упростить
    НКА.

    '
  author: Егорова Алиса
  id: 93
  questions:
  - 'Какие условия необходимы для бисимуляции двух НКА?

    '
- answer: 'Состояния q_i и q_j в НКА(недетерминированный конечный автомат) А бисимилярны,
    если они связаны LTS-бисимуляцией(форма бисимуляции в системе размеченных переходов,
    которая используется для сравнения поведения автоматов) и имеют одинаковую финальность
    в А, то есть состояния либо оба являются конечными, либо оба не являются конечными
    состояниями. Все состояния-ловушки в любом полном автомате (т.е. с явно присутствующими
    переходами по всем буквам алфавита) бисимилярны друг другу. Все финальные состояния
    без переходов из них (кроме как в ловушки) также бисимилярны.

    '
  author: Егорова Алиса
  id: 94
  questions:
  - 'Являются ли финальные состояния и состояния-ловушки бисимилярными в НКА?

    '
- answer: 'Трансформационный моноид M_A для ДКА А - это моноид над базисом функций
    F_a таких, что F_a(q_i) = q_j тогда и только тогда, когда состояние q_i переходит
    в состояние q_j по a в А.  Иначе можно сказать, что трансформационный моноид M_A
    определяется множеством классов эквивалентности {w | w ∈ ∑+} таким, что w_i =
    w_j тогда и только тогда, когда F_{w_i} = F_{w_j}. В трансформационном моноиде
    строки являются действиями над состояниями автомата.

    '
  author: Егорова Алиса
  id: 95
  questions:
  - 'Что такое трансформационный моноид?

    '
- answer: 'Для трансформационного моноида M_A верны эти свойства: 1) M_A определяется
    фактормножеством классов эквивалентности и правилами переписывания, задающими
    эквивалентность. Пустое слово обычно не включается в множество w_i. 2) Поскольку
    множество F_{w_i} в случае ДКА конечно, то M_A содержит конечное число классов
    эквивалентности (верно и обратное: каждый такой моноид определяет ДКА). F_{w_i}
    - множество возможных действий над состояниями автомата. 3) Трансмоноид строится
    для ДКА без ловушек; переход в ловушку обозначается в таблице переходов прочерком.
    4) Для единообразия записи трансформаций и перестановок в алгебре, в таблице переходов
    пишут только номера состояний ДКА А. Таблица переходов - таблица, в которой столбцы
    соответствуют состояниям автомата, строки - символам входного алфавита, а каждая
    ячейка содержит состояние, в которое происходит переход по соответствующему символу
    из соответсвующего состояния.

    '
  author: Егорова Алиса
  id: 96
  questions:
  - 'Какие свойства есть у трансформационного моноида?

    '
- answer: 'Построим таблицу переходов, в которой столбцы соответствуют состояниям
    автомата, строки - символам входного алфавита, а каждая ячейка содержит состояние,
    в которое происходит переход по соответствующему символу из соответсвующего состояния.
    Таким образом определяем соответсвие между буквами и множествами переходов по
    ним и будем расширять этот список новыми словами в лексикографическом порядке.
    Если очередное слово задает такую же трансформацию, как и уже рассмотренное, порождаем
    соответствующее правило переписывания.

    '
  author: Егорова Алиса
  id: 97
  questions:
  - 'Как строится трансформационный моноид?

    '
- answer: 'Определим отношение синтаксической конгруэнтности слов:  w_i ~ по L w_j
    ⇔ для любых x, y (x w_i y ∈ L ⇔ x w_j y ∈ L). То есть, заменяя подслова из одного
    класса эквивалентности друг на друга, мы не меняем принадлежности слова, в котором
    сделана замена, языку. Синтаксическая конгруэнтность делит все слова на классы
    эквивалентности. Слова в одном классе можно заменять друг на друга, не нарушая
    принадлежности к языку. Синтаксический моноид M(L) - это множество классов эквивалентности
    языка L относительно ~ по L (отношение бисимуляции по L). То есть такая полугруппа
    с единицей над w ∈ ∑*, что  w_i = w_j ⇔ w_i ~ по L w_j (равенство здесь понимается
    в алгебраическом смысле: как возможность преобразовать w_i и w_j к одному и тому
    же слову) Лемма. Синтаксический моноид регулярного языка L совпадает с трансформационным
    моноидом минимального ДКА, его распознающего. Синтаксический моноид - атрибут
    языка, а трансформационный моноид - атрибут конкретного автомата, распознающего
    этот язык.

    '
  author: Егорова Алиса
  id: 98
  questions:
  - 'Что такое синтаксический моноид?

    '
- answer: 'L-некоторый регулярный язык. Определим отношение эквивалентности по Нероуду
    как: w_i ≡ по L w_j ⇔ для любых y (w_i y ∈ L ⇔ w_j y ∈ L). Таким образом, два
    слова эквивалентны по Нероуду тогда и только тогда замена префикса слова на другой
    префикс из того же класса эквивалентности не меняет принадлежности слова языку.  Теорема
    Майхилла-Нероуда.(Критерий регулярности языка) Язык L регулярен тогда и только
    тогда, когда множество классов эквивалентности ≡ по L конечно. Доказательство:
    =>: Пусть L регулярен. Тогда он порождается некоторым DFA A с конечным числом
    состояний N. Значит, множество {q_i | q_0 переходит по w в q_i} конечно, а для
    каждых двух w_1, w_2 таких, что q_0 переходит по w_1 в q_i и q_0 переходит по
    w_2 в q_i выполняется w_1 ≡ по L w_2. <=: Пусть все слова в ∑* принадлежат N классам
    эквивалентности A_1...A_n по ≡ по L. Построим по ним DFA A, распознающий L. Классы
    A_i сопоставим состояниям: 1) Начальным объявим класс эквивалентности A_0 такой,
    что ε ∈ A_0. 2) Конечными объявим такие A_j, что для любого w ∈ A_j: (w ∈ L).
    3) Если w_i a ≡ по L w_j, то  w_i переходит по a в w_j.

    '
  author: Егорова Алиса
  id: 99
  questions:
  - 'Доказательство теоремы Майхилла-Нероуда (англ. Myhill-Nerode theorem)?

    '
- answer: 'Минимизация ДКА. Рассмотрим один из методов минимизиции:  1) Построим таблицу
    всех двухэлементных множеств {q_i, q_j} q_i, q_j ∈ Q (множество состояний). 2)
    Пометим все пары, в которых один элемент финальный, а другой нет. 3) Пометим все
    множества {q_i, q_j} такие, что существует такой a, что (q_i переходит по a в
    q_1'' и q_j переходит по a в q_2'' и {q_1'',q_2''} - помеченная пара). 4) Продолжаем
    шаг 3, пока не будет появляться новых помеченых пар. Пары оставшиеся непомеченными,
    можно объединить. Существуют и другие методы минимизации ДКА, например, алгоритм
    минимизации Бреннера и алгоритм Хопкрофта.

    '
  author: Егорова Алиса
  id: 100
  questions:
  - 'Как минимизировать ДКА?

    '
- answer: 'Для доказательства минимальности детерминированного конечного автомата
    способом построения таблиц необходимо построить таблицу классов эквивалентности.
    Для построения таблицы выбираются w_i - префиксы, которые приводят в различные
    состояния автомата. Эти префиксы используются для определения строк таблицы. Подбираются
    различающие суффиксы z_i, которые используются для определения столбцов таблицы.
    Для каждого префикса w_i и суффикса z_i проверяется, принадлежит ли слово w_i
    z_i языку. Значения таблицы содержат 0 и 1, то есть принадлежит или не принадлежит
    слово языку. Если в этой таблице все строчки различны, значит выбранные w_i действительно
    лежат в различных классах эквивалентности, и ДКА, распознающий язык L, не может
    иметь меньше len(w_i) состояний.  При доказательстве минимальности ДКА достаточно
    подобрать [log_2(n)]+1 различающих суффиксов z_i, где n - число состояний автомата.
    Также можно минимизировать автомат и в случае, если результат равен исходному
    с точностью до нумерации состояний - это означает, что данный автомат минимален.

    '
  author: Егорова Алиса
  id: 101
  questions:
  - 'Как доказать минимальность детерминированного конечного автомата?

    '
- answer: 'Свойства множества функций переходов ДКА: 1) Существует единичная функция
    F_ε такая, что F_ε ∘ F_ξ = F_ξ ∘ F_ε = F_ξ. То есть композиция единичной функции
    с любой другой функцией из множества функций переходов детерминированного конечного
    автомата (ДКА) сохраняет эту другую функцию. 2) Композиция ассоциативна. Таким
    образом, функции переходов по словам из ∑* в ДКА А образуют моноид относительно
    композиции.

    '
  author: Егорова Алиса
  id: 102
  questions:
  - 'Какие свойства есть у множества функций переходов ДКА (детерминированного конечного
    автомата)?

    '
- answer: 'В равных НКА состояния бисимилярны, однако только условия существования
    бисимуляции и биекции бисимилярных состояний недостаточно, чтобы гарантировать
    равенство.

    '
  author: Егорова Алиса
  id: 103
  questions:
  - 'Означает ли бисимуляция состояний равенство НКА?

    '
- answer: 'Трансформационный моноид строится в контексте LTS(Система размеченных переходов),
    то есть без учета финальности состояний.  Поэтому из ДКА, по которому строится
    трансформационный моноид, предварительно удаляются все ловушки, иначе в нем могут
    появиться правила переписывания, не имеющие никакого отношения к языку ДКА.

    '
  author: Егорова Алиса
  id: 104
  questions:
  - 'Учитывает ли трансформационный моноид финальность состояний?

    '
- answer: "В хорошо написанном регулярном выражении должны быть сбалансированы несколько\
    \ факторов:\n • Регулярное выражение должно находить именно те фрагменты текста,\
    \ которые соответствуют заданным условиям. В зависимости от задачи, подход может\
    \ различаться: например, fullmatch проверяет полное совпадение всей строки с выражением,\
    \ в то время как search подходит для нахождения фрагментов внутри строки. Такое\
    \ разграничение позволяет выбирать правильный метод для каждой задачи, будь то\
    \ полное соответствие или частичное.\n • Регулярное выражение должно оставаться\
    \ понятным и легким для поддержки. Сложные, трудно читаемые выражения могут затруднить\
    \ их использование и усложнить внесение изменений, повышая риск ошибок.\n • При\
    \ использовании механизма недетерминированного конечного автомата (НКА) выражение\
    \ должно быть эффективно и приводить к быстрому результату. Однако стоит учитывать,\
    \ что конструкции с итерацией Клини (* и +) особенно в начале выражения могут\
    \ усилить недетерминизм, что повышает вероятность долгого перебора вариантов и\
    \ ухудшает производительность. Хорошо составленное регулярное выражение должно\
    \ минимизировать такие конструкции, если это возможно, чтобы избежать избыточной\
    \ сложности и не затягивать обработку.\n"
  author: Еделькин Герман
  id: 105
  questions:
  - 'В хорошо написанном регулярном выражении должны быть сбалансированы какие факторы?

    '
- answer: 'Механизм недетерминированного конечного автомата (НКА) обладает рядом возможностей,
    недоступных для детерминированного конечного автомата (ДКА), что делает его более
    гибким и мощным инструментом для работы с регулярными выражениями:  1. Возможность
    использовать захваченную строку по имени группы вне регулярного выражения: НКА
    поддерживает возможность захвата текста, заключённого в круглые скобки в регулярном
    выражении, и использования этих захваченных фрагментов в дальнейшем, что позволяет
    гибко работать с результатами сопоставлений. 2. Позиционные и сложные проверки
    с нулевой длиной совпадения: НКА может выполнять позиционные проверки (например,
    проверки начала или конца строки) и другие сложные проверки, не требующие дополнительных
    символов для совпадения.  3. Минимальные квантификаторы и упорядоченный выбор:
    В отличие от ДКА, который обеспечивает поиск минимального совпадения в целом,
    НКА поддерживает локальные минимальные квантификаторы и упорядоченный выбор, что
    позволяет регулировать последовательность проверок и минимизировать длину совпадений
    на более локальном уровне.  4. Захватывающие квантификаторы и атомарная группировка:
    НКА поддерживает захватывающие квантификаторы и атомарную группировку, что позволяет
    эффективно контролировать совпадения и избегать ненужных проверок.  5. Обработка
    многоопределённости: НКА поддерживает обработку языков, в которых на одном и том
    же месте могут быть несколько вариантов ввода, что позволяет учитывать альтернативные
    пути при распознавании строки (например, через операторы выбора, такие как | в
    регулярных выражениях). Это даёт НКА гибкость, так как он может одновременно рассматривать
    несколько возможных путей для распознавания. В отличие от этого, ДКА ограничен
    обработкой языков, где каждый ввод имеет строго определённый путь разбора, и требует
    создания отдельных состояний для каждой альтернативы, что делает его менее компактным
    и сложным в плане реализации для таких выражений.

    '
  author: Еделькин Герман
  id: 106
  questions:
  - 'Какие возможности механизм НКА может поддерживать, недоступные для ДКА? (в конетексте
    регулярных выражений и языков)

    '
- answer: '1. L + M = M + L — коммутативный закон для объединения утверждает, что
    два языка можно объединять в любом порядке.  2. (L + M) + N = L + (M + N) — это
    ассоциативный закон объединения, который говорит, что для объединения трёх языков
    можно сначала объединить как два первых, так и два последних из них. Вместе с
    коммутативным законом этот закон позволяет объединять любое количество языков
    в произвольном порядке, разбивая их на любые группы, и результат будет одним и
    тем же. Очевидно, что некоторая цепочка принадлежит объединению L_1 ∪ L_2 ∪ …
    ∪ L_k тогда и только тогда, когда она принадлежит одному или нескольким языкам
    L_i.  3. (LM)N = L(MN) — ассоциативный закон конкатенации гласит, что для конкатенации
    трёх языков можно сначала соединить как два первых, так и два последних из них.

    '
  author: Еделькин Герман
  id: 107
  questions:
  - 'Три закона для коммутативности и ассоциативности регулярных языков

    '
- answer: '1. L∣M=M∣L — коммутативный закон для объединения утверждает, что операнды
    в регулярных выражениях объединения можно менять местами, и это не изменяет язык,
    который они распознают. 2. ((L∣M)∣N)=(L∣(M∣N)) — это ассоциативный закон объединения,
    который говорит, что для объединения трёх регулярных выражений можно сначала объединить
    как два первых, так и два последних из них, и результат будет тот же. Вместе с
    коммутативным законом этот закон позволяет менять порядок и группировку операндов
    в объединении произвольного числа регулярных выражений без изменения распознаваемого
    ими языка. 3. (LM)N = L(MN) — ассоциативный закон конкатенации гласит, что для
    конкатенации трёх регулярных выражений можно сначала соединить два первых, а затем
    третий, либо наоборот, и результат останется одинаковым. Примечание: в данном
    ответе для операции объединения используется символ |, который является стандартным
    в регулярных выражениях. В то же время в математической теории автоматов и в рамках
    полукольца эту операцию может быть записана, как +.

    '
  author: Еделькин Герман
  id: 108
  questions:
  - 'Три закона для коммутативности и ассоциативности регулярных выражений

    '
- answer: 'Для регулярных выражений существует закон дистрибутивности, но, поскольку
    операция конкатенации некоммутативна, то он формулируется в виде следующих двух
    законов:  • L(M∣N)=(LM∣LN). Этот закон называется левосторонним дистрибутивным
    законом конкатенации относительно объединения.  • (M∣N)L=(ML∣NL). Этот закон называется
    правосторонним дистрибутивным законом конкатенации относительно объединения. Примечание:
    в данном ответе для операции объединения используется символ |, который является
    стандартным в регулярных выражениях. В то же время в математической теории автоматов
    и в рамках полукольца эту операцию может быть записана, как +.

    '
  author: Еделькин Герман
  id: 109
  questions:
  - 'Дистрибутивные законы для регулярных выражений

    '
- answer: "Существует ряд законов, связанных с операцией итерации и её разновидностями\
    \ + и ? в стиле UNIX.  • (L^*)^* = L^*. Этот закон утверждает, что при повторной\
    \ итерации язык уже итерированного выражения не меняется. Язык выражения (L^*)^*\
    \ содержит все цепочки, образованные конкатенацией цепочек языка L^*. Последние\
    \ же цепочки построены из цепочек языка L. Таким образом, цепочки языка ( также\
    \ являются конкатенациями цепочек из L и, следовательно, принадлежат языку L^*.\
    \ • ∅^* = ε. Итерация языка ∅ состоит из одной-единственной цепочки ε. • ε* =\
    \ ε. Легко проверить, что единственной цепочкой, которую можно образовать конкатенацией\
    \ любого количества пустых цепочек, будет всё та же пустая цепочка. • L⁺ = L(L^*)\
    \ = (L^*)L. \n  Поскольку L⁺ по определению равно L∣LL∣LLL∣…. \n  А также в силу\
    \ того, что L^* = ε∣L∣LL∣LLL∣…, то \n  L(L^*) = Lε∣LL∣LLL∣LLLL∣… \n  Если учесть,\
    \ что Lε = L, то очевидно, что бесконечные разложения для L(L^*) и для L⁺ совпадают.\
    \ Это доказывает, что L⁺ = L(L^*). Доказательство того, что L⁺ = (L^*)L, аналогично.\
    \ \n• L^* = L⁺|ε. Это легко доказать, поскольку в разложении L⁺ присутствуют те\
    \ же члены, что и в разложении L^*, за исключением цепочки ε. Заметим, что если\
    \ язык L содержит цепочку ε, то `|ε` лишнее, т.е. в этом случае L⁺ = L^*. • L?\
    \ = ε|L. В действительности это правило является определением оператора \"?\"\
    . Примечание: в данном ответе символ | используется для обозначения объединения,\
    \ что является стандартом в регулярных выражениях. При этом в математических обозначениях\
    \ или в рамках теории полуколец операция объединения часто записывается как +.\
    \ Однако, чтобы избежать путаницы с оператором \"позитивной итерации\" (+), используется\
    \ синонимичный символ |.\n"
  author: Еделькин Герман
  id: 110
  questions:
  - 'Законы связанные с оператором итерации (в контексте регулярных выражений и языков)

    '
- answer: 'Преобразование НКА в ДКА может занимать экспоненциальное время относительно
    количества состояний НКА. Вычисление ε-замыкания для n состояний занимает O(n³),
    так как нужно исследовать до n² дуг. Это можно сделать с помощью алгоритма Флойда-Уоршелла
    нахождения кратчайших путей между всеми парами вершин. После вычисления ε-замыкания
    можно перейти к синтезу ДКА с помощью конструкции подмножеств. Основное влияние
    на расход времени оказывает количество состояний ДКА, которое может равняться
    2ⁿ. Для каждого состояния можно вычислить переходы завремя O(n³), используя ε-замыкание
    и таблицу переходов НКА для каждого входного символа. Предположим, нужно вычислить
    δ({q_1, q_2, …, q_k}, a) для ДКА. Из каждого со стояния q_i можно достичь не более
    n состояний вдоль путей с меткой ε, и каждое из этих состояний может иметь не
    более, чем n дуг с меткой a. Создав массив, проиндексиро ванный состояниями, можно
    вычислить объединение не более n множеств, состоящих из не более, чем n состояний,
    за время, пропорциональное n².  Таким способом для каждого состояния q_i можно
    вычислить множество состояний, достижимых из q_i вдоль пути с меткой a (возможно,
    включая дуги, отмеченные ε). Поскольку k ≤ n, то существует не более n таких состояний
    q_i, и для каждого из них вычисление достижимых состояний занимает время O(n²).
    Таким образом, общее время вычисления достижимых состояний равно O(n³). Для объединения
    множеств достижимых состояний потребуется только O(n²) дополнительного времени,
    следовательно, вычисление одного перехода ДКА занимает время O(n³).  Заметим,
    что количество входных символов считается постоянным и не зависит от n. Таким
    образом, как в этой, так и в других оценках времени работы количество входных
    символов не рассматривается. Размер входного алфавита влияет только на постоянный
    коэффициент, скрытый в обозначении “О большого”.  Итак, время преобразования НКА
    в ДКА, включая ситуацию, когда НКА содержит ε переходы, равно O((n³)(2ⁿ)). Конечно,
    на практике обычно число состояний, которые строятся, намного меньше 2ⁿ. Иногда
    их всего лишь n. Поэтому можно установить оценку времени работы равной O(n³s),
    где s — это число состояний, которые в действительности есть у ДКА.

    '
  author: Еделькин Герман
  id: 111
  questions:
  - 'Преобразование НКА в ДКА

    '
- answer: "Проверка истинности алгебраических тождеств заключается в проверке эквивалентности\
    \ двух регулярных выражений. Это означает, что оба выражения должны описывать\
    \ один и тот же язык — множество строк, которые они распознают, должно совпадать.\
    \ Подходы для проверки эквивалентности регулярных выражений:\n  1. Преобразование\
    \ в конечные автоматы: \n    Можно преобразовать оба регулярных выражения в недетерминированные\
    \ конечные автоматы (НКА), а затем привести их к эквивалентным детерминированным\
    \ конечным автоматам (ДКА). \n    После этого проверяется эквивалентность автоматов,\
    \ что означает, что их язык принимаемый ими язык одинаков. \n    Автоматы считаются\
    \ эквивалентными, если они принимают один и тот же язык, то есть принимают одни\
    \ и те же строки.\n  2. Минимизация автоматов: \n    После получения ДКА для каждого\
    \ регулярного выражения можно минимизировать оба автомата. \n    Минимизированные\
    \ ДКА будут эквивалентны тогда и только тогда, когда они изоморфны (имеют одинаковую\
    \ структуру).\n  3. Метод разницы языков:\n    Можно построить автомат, который\
    \ распознает разницу языков, описываемых двумя регулярными выражениями  L_1 и\
    \ L_2 : это язык, состоящий из всех строк, которые принадлежат L_1, но не принадлежат\
    \  L_2, и всех строк, которые принадлежат L_2 , но не принадлежат L_1. \n    Если\
    \ разность языков пуста (нет таких строк), значит, регулярные выражения эквивалентны.\n"
  author: Еделькин Герман
  id: 112
  questions:
  - 'Проверка истинности алгебраических тождеств (в контексте регулярных языков и
    выражений)

    '
- answer: 'Теорема: Для любого регулярного языка L существует число n ∈ ℕ такое, что
    ∀ w ∈ L, |w| ≥ n найдутся такие три слова x, y, z, что: w = xyz; y ≠ ε; |xy| ≤
    n; ∀ k ≥ 0: x(y^k)z ∈ L. Доказательсво: Пусть L — регулярный язык, которому соответствует
    конечный автомат с числом вершин n, а w ∈ L — слово длины не менее n. Рассмотрим
    последовательность вершин конечного автомата в порядке их посещения при разборе
    слова w: a_0, a_1, a_2, ..., a_m. Последовательность, очевидно, содержит m+1 вершину,
    и m ≥ n. Так как всего в графе только n вершин, хотя бы одна из них повторяется
    в последовательности. Пусть a_i — первая вершина последовательности из числа повторяющихся,
    причём второй раз она встретилась в позиции j. Тогда x — первые i символов строки
    w, y — отрезок w, соответствующий перемещению из a_i в a_j, а z — отрезок w, соответствующий
    перемещению из a_j в a_n. Так как переход от a_i к a_j образует цикл в конечном
    автомате, по этому циклу можно пройти произвольное (в том числе и нулевое!) число
    раз, и всякий раз будет получаться строчка, принимаемая автоматом, поэтому ∀ k
    ∈ ℕ_0: x(y^k)z ∈ L. При этом пара состояний a_i, a_j — первый повтор в рассматриваемой
    последовательности. Значит, все состояния a_0, a_1, ..., a_{j-1} являются различными.
    Раз так, то их не больше n. Отсюда получаем, что j ≤ n и |xy| ≤ n, что и требовалось
    доказать.

    '
  author: Еделькин Герман
  id: 113
  questions:
  - 'Доказательство леммы о накачке для регулярных языков

    '
- answer: 'Пусть L - регулярный язык. При объединении или пересечении двух языков
    L и M может оказаться, что они определены в разных алфавитах. Например, возможен
    случай, когда L1 ⊆ {a, b}^*, а L2 ⊆ {b, c, d}^*. Однако, если язык L состоит
    из цепочек символов алфавита Σ, то L можно также рассматривать как язык в любом
    конечном алфавите, включающем Σ (надмножестве Σ).  Например, можно представить
    указанные выше языки L_1 и L_2 как языки в алфавите {a, b, c, d}. То, что ни одна
    цепочка языка L_1 не содержит символов c или d, несущественно, как и то, что ни
    одна цепочка языка L_2 не содержит a. Аналогично, рассматривая дополнение языка
    L, который является подмножеством множества (Σ_1)* для некоторого алфавита Σ_1,
    можно взять дополнение относительно некоторого алфавита Σ_2, включающего Σ_1 (надмножества
    Σ_1). В этом случае дополнением L будет (Σ_2)* – L, т.е. дополнение языка L относительно
    алфавита Σ_2 включает (среди прочих) все цепочки из (Σ_2)*, которые содержат хотя
    бы один символ алфавита Σ_2, не принадлежащий Σ_1.  Если взять дополнение L относительно
    Σ_1, то ни одна цепочка, содержащая символы из Σ_2 – Σ_1, не попадет в L. Таким
    образом, чтобы избежать неточностей, нужно указывать алфавит, относительно которого
    берется дополнение. Часто, однако, бывает очевидно, какой алфавит подразумевается
    в конкретном случае. Например, если язык L определен некоторым автоматом, то в
    описании этого автомата указывается и алфавит.  Итак, во многих ситуациях можно
    говорить о “дополнении”, не указывая алфавит.

    '
  author: Еделькин Герман
  id: 114
  questions:
  - 'Что делать, если языки имеют разные алфавиты? (в контексте регулярных языков
    и выражений)

    '
- answer: 'Теорема Майхилла-Нероде (англ. Myhill-Nerode). Пусть L — язык и пусть ≡_L
    — отношение эквивалентности на множестве строк, где u ≡_L u'', если для всякой
    строки v строки uv и u''v или обе лежат в L или обе не лежат. Это отношение называется
    суффиксной конгруэнтностью для языка L. Утверждается, что язык L регулярен тогда
    и только тогда, когда число классов эквивалентности в отношении ≡_L конечно. Расширение
    понятия на другие классы языков: Подходы, аналогичные теореме Майхилла-Нероде,
    применяются и в анализе более сложных языков, таких как древесные языки и видимо-контекстно-свободные
    языки (VPL). Суффиксная конгруэнтность древесных языков: Для древесных языков
    суффиксная конгруэнтность классифицирует деревья на основе их суффиксов. Два дерева
    эквивалентны, если добавление одного и того же поддерева приводит к деревьям,
    которые либо оба принадлежат языку, либо оба не принадлежат. Это позволяет разбить
    множество деревьев на конечное число классов эквивалентности. Visibly Pushdown
    Languages (VPL): Для VPL суффиксная конгруэнтность применяется к сбалансированным
    словам, где видна структура стека. Два слова считаются эквивалентными, если любые
    продолжения этих слов приводят к одинаковым конфигурациям стека. Это также позволяет
    выделить конечное число классов эквивалентности.

    '
  author: Еделькин Герман
  id: 115
  questions:
  - 'Теорема Майхилла-Нероде (англ. Myhill-Nerode) для регулярных языков

    '
- answer: "Пусть M = (Q, Σ, s, F, \U0001D6FF). Q – конечное множество состояний, Σ\
    \ - алфавит. s ∈ Q – начальное состояние, F ⊆ Q – множество заключительных состояний,\
    \ а \U0001D6FF : Q × Σ → Q – функция перехода. Конфигурацией ДКА M = (Q, Σ, s,\
    \ F, \U0001D6FF) называется произвольная пара (q, w), где q ∈ Q, w ∈ Σ*. Где Σ*\
    \ Множество слов алфавита Σ, Σ* = ⋃︁_(n ∈ N) Σⁿ. Таким образом, Конфигурация (q,\
    \ w) описывает текущее состояние автомата и оставшуюся часть входного слова, которое\
    \ нужно обработать.\n  q — текущее состояние, в котором находится автомат. \n\
    \  w — оставшаяся часть слова, которую автомат ещё не прочитал. \nКаждый шаг работы\
    \ ДКА можно представить как переход из одной конфигурации в другую, где автомат\
    \ «чтение за чтением» меняет состояние в зависимости от текущего символа слова\
    \ (с помощью функции перехода δ), пока либо не завершит чтение слова, либо не\
    \ придёт в состояние, из которого больше нет возможных переходов.\n"
  author: Еделькин Герман
  id: 116
  questions:
  - 'Что называется конфигурацией ДКА

    '
- answer: "Σ* - Множество слов алфавита Σ. Σ* = ⋃︁_(n ∈ N) Σⁿ. Бинарное отношение\
    \ ≡_L, называемое суффиксной конгруэнтностью для языка L, задаётся на множестве\
    \ Σ* следующим образом: \n  ∀x, y ∈ Σ*, x ≡_L y ⇔ ∀ z ∈ Σ*, xz ∈ L ⇔ yz ∈ L\n\
    Проще говоря, слова x и y находятся в отношении ≡_L, если для каждого слова z\
    \ приписывание его справа к x приводит к слову, принадлежащему языку L, тогда\
    \ и только тогда, когда приписывание справа того же слова z к y также приводит\
    \ к слову, принадлежащему L. Это отношение называется суффиксной конгруэнтностью\
    \ для языка L. Таким образом, бинарное отношение ≡_L делит множество Σ* на классы\
    \ эквивалентности. Каждому классу эквивалентности соответствуют слова, которые\
    \ ведут себя одинаково с точки зрения принадлежности к языку L после добавления\
    \ любого другого слова.\n"
  author: Еделькин Герман
  id: 117
  questions:
  - 'Как задаётся суффиксная конгруэнтность языка на множестве слов алфавита?

    '
- answer: "Чтобы определить язык L(a) ⊆ Σ* по регулярному выражению a, можно использовать\
    \ индукцию по структуре выражения a, основываясь на его составных частях. То есть\
    \ мы последовательно определяем язык, соответствующий каждому элементарному случаю\
    \ и операции над регулярными выражениями: \n  1. Пустое множество: L(∅) = ∅ —\
    \ язык, который не содержит ни одного слова. \n  2. Базовый символ: L(a) = {a},\
    \ где a ∈ Σ. Это язык, состоящий из одного слова, представляющего символ a.\n\
    \  3. Объединение языков: L(a ∪ b) = L(a) ∪ L(b). Если регулярное выражение a\
    \ ∪ b описывает объединение двух языков, то язык L(a ∪ b) включает все слова из\
    \ L(a) и L(b).\n  4. Конкатенация языков: L(a ∘ b) = L(a) ∘ L(b). Здесь a∘b описывает\
    \ конкатенацию языков, и язык L(a∘b) состоит из всех слов, которые можно получить,\
    \ последовательно объединяя слова из L(a) и L(b).\n  5. Замыкание Клини (итерация):\
    \ L(a*) = L(a)*. Замыкание Клини для регулярного выражения a представляет собой\
    \ множество всех возможных конкатенаций любого количества (включая ноль) слов\
    \ из L(a). Это позволяет получить язык, включающий все повторения слов из L(a).\n\
    Таким образом, используя эти правила, можно по шагам построить язык для любого\
    \ регулярного выражения, последовательно применяя операторы к более простым выражениям\
    \ и определяя язык для каждой из составляющих частей.\n"
  author: Еделькин Герман
  id: 118
  questions:
  - 'Пусть a – регулярное выражение алфавита. Как Язык M(a), являющийся подмножеством
    множества слов алфавита, определяется по регулярному выражению a индукцией по
    структуре a?

    '
- answer: "Лемма о разрастании также называется леммой о накачке (по-английски - никаких\
    \ разночтений: pumping lemma) Теорема: Для любого регулярного языка M существует\
    \ число n ∈ ℕ такое, что для любого слова w ∈ M, |w| ≥ n найдутся такие три слова\
    \ x, y, z, что: \n  1. w = xyz; y ≠ ε; \n  2. |xy| ≤ n; \n  3. ∀ k ≥ 0: x(y^k)z\
    \ ∈ M.\nТаким образом эта лемма утверждает, что любой регулярный язык допускает\
    \ представление всех своих достаточно длинных цепочек в виде соединения трех цепочек,\
    \ причем средняя цепочка из этих трех не пуста, ограничена по длине, и ее `накачка`\
    \ — повторение любое число раз — или выбрасывание не выводит за пределы языка\
    \ (т.е. дает цепочки, принадлежащие данному регулярному языку).\n"
  author: Еделькин Герман
  id: 119
  questions:
  - 'Лемма о разрастании для регулярных языков

    '
  - 'Лемма о накачке для регулярных языков

    '
- answer: "В хорошо написанном регулярном выражении должны быть сбалансированы несколько\
    \ факторов:\n • Регулярное выражение должно находить именно те фрагменты текста,\
    \ которые соответствуют заданным условиям. В зависимости от задачи, подход может\
    \ различаться: например, fullmatch проверяет полное совпадение всей строки с выражением,\
    \ в то время как search подходит для нахождения фрагментов внутри строки. Такое\
    \ разграничение позволяет выбирать правильный метод для каждой задачи, будь то\
    \ полное соответствие или частичное.\n • Регулярное выражение должно оставаться\
    \ понятным и легким для поддержки. Сложные, трудно читаемые выражения могут затруднить\
    \ их использование и усложнить внесение изменений, повышая риск ошибок.\n • При\
    \ использовании механизма недетерминированного конечного автомата (НКА) выражение\
    \ должно быть эффективно и приводить к быстрому результату. Однако стоит учитывать,\
    \ что конструкции с итерацией Клини (* и +) особенно в начале выражения могут\
    \ усилить недетерминизм, что повышает вероятность долгого перебора вариантов и\
    \ ухудшает производительность. Хорошо составленное регулярное выражение должно\
    \ минимизировать такие конструкции, если это возможно, чтобы избежать избыточной\
    \ сложности и не затягивать обработку.\n"
  author: Еделькин Герман
  id: 120
  questions:
  - 'Какие факторы должны быть сбалансированны в хорошо написанном регулярном выражении?

    '
- answer: 'Контекстно-свободный язык L называется существенно неоднозначным, если
    все его грамматики неоднозначны (Неоднозначной грамматикой (англ. ambiguous grammar)
    называется грамматика,  в которой можно вывести некоторое слово более чем одним
    способом (то есть для строки (слова) есть более одного дерева разбора).  Если
    хотя бы одна грамматика языка L однозначна, то L является однозначным языком.

    '
  author: Якубов Павел
  id: 121
  questions:
  - 'Что такое существенно неоднозначный контекстно-свободный язык?

    '
- answer: 'Символ X называется полезным в грамматике Γ = ⟨N, Σ, P, S⟩, если существует
    некоторое порождение вида S ⇒* αXβ ⇒* w, где w ∈ Σ*, что экивалентно тому, что
    символ  является одновременно и порождающим, и достижимым (Символ X называется
    порождающим (англ. generating),  если X ⇒* w для некоторой терминальной цепочки
    w. Заметим, что каждый терминал является  порождающим, поскольку w может быть
    этим терминалом, порождаемым за 0 шагов.  Символ X называется достижимым (англ.
    reachable), если существует порождение S ⇒* αXβ для некоторых α и β).  Если символ
    X не является полезным, то называется бесполезным, что эквивалентно тому, что
    он является недостижимым (терминалы, нетерминалы) или непорождающим (нетерминалы).
    Эти определения возможны в силу независимости переписывания нетерминала от контекста
    в КС-грамматиках,  что также делает проблему пустоты языка КС-грамматики разрешимой:  язык
    грамматики непустой <=> стартовый нетерминал не является бесполезным, или, что
    эквивалентно,  в грамматике есть хотя бы один порождающий и достижимый нетерминал.
    Очевидно, что исключение бесполезных символов из грамматики не изменяет порождаемого
    языка, поэтому все бесполезные символы можно обнаружить и удалить.

    '
  author: Якубов Павел
  id: 122
  questions:
  - 'Что такое полезный символ в контекстно-свободной грамматике Γ = ⟨N, Σ, P, S⟩?

    '
- answer: 'Все ε-порождающие символы Γ можно найти с помощью следующего алгоритма.
    1. Найти все ε-правила. Составить множество Z, состоящее из нетерминалов, входящих
    в левые части таких правил. 2. Перебираем правила грамматики Γ. Если найдено правило
    A→C_1C_2...C_k, для которого верно, что каждый C_i принадлежит Z, то добавить
    A в Z. 3. Если на шаге 2 множество Z изменилось, то повторить шаг 2. Докажем корректность
    алгоритма. Для доказательства корректности алгоритма достаточно показать, что,
    если множество Z ε-порождающих  нетерминалов на очередной итерации алгоритма не
    изменялось, то алгоритм нашел все ε-порождающие нетерминалы. Пусть после завершения
    алгоритма существуют нетерминалы такие, что они являются ε-порождающими,  но не
    были найдены алгоритмом. Выберем из этих нетерминалов нетерминал B, из которого
    выводится ε за наименьшее число шагов. Тогда в грамматике есть правило B→C_1C_2...C_k,
    где каждый нетерминал C_i — ε-порождающий. Каждый C_i входит в множество Z ε-порождающих
    нетерминалов, так как иначе вместо B необходимо было взять C_i. Следовательно,
    на одной из итераций алгоритма B уже добавился в множество Z ε-порождающих нетерминалов.
    Противоречие. Следовательно, алгоритм находит все ε-порождающие нетерминалы.

    '
  author: Якубов Павел
  id: 123
  questions:
  - 'Пусть Γ = ⟨N, Σ, P, S⟩ — КС-грамматика. Опиши алгоритм нахождения всех ε-порождающих
    символов Γ.

    '
- answer: '1. Неоднозначна ли данная КС-грамматика Γ? 2. Является ли данный КС-язык
    существенно неоднозначным? 3. Пусто ли пересечение двух КС-языков? 4. Равны ли
    два данных КС-языка? 5. Равен ли Σ* данный КС-язык, где Σ — алфавит этого языка?
    Отметим, что вопрос 1 о неоднозначности отличается от остальных тем, что это вопрос
    о грамматике, а не о языке. Все остальные вопросы предполагают, что язык представлен
    грамматикой или МП-автоматом, но это все равно вопросы о языке (или языках). Например,
    в противоположность вопросу 1 вопрос 2 требует по данной грамматике Γ (или МП-автомату)
    определить,  существует ли некоторая эквивалентная ей однозначная грамматика Γ′.  Если
    Γ сама по себе однозначна, то ответом, безусловно, будет “да”, но если Γ неоднозначна,  то
    для языка грамматики Γ может существовать другая грамматика Γ′, которая однозначна.

    '
  author: Якубов Павел
  id: 124
  questions:
  - 'Список наиболее значительных неразрешимых вопросов о контекстно-свободных грамматиках
    и языках

    '
- answer: 'Если L — КС-язык, а R — регулярный язык, то L ∩ R является КС-языком. Доказательство:
    Построим автомат с магазинной памятью  (МП-автомат, англ. pushdown automaton,
    PDA) для пересечения регулярного языка и КС-языка. Пусть регулярный язык задан
    своим ДКА, а КС-язык — своим МП-автоматом c допуском по допускающему состоянию.
    Построим прямое произведение этих автоматов так же, как строилось прямое произведение
    для двух ДКА. Более формально, пусть R — регулярный язык, заданный своим ДКА ⟨Σ,
    Q_1, s_1, T_1, δ_1⟩, и L — КС-язык, заданный своим МП-автоматом: ⟨Σ, Γ, Q_2, s_2,
    T_2, z_0, δ_2⟩. Тогда прямым произведением назовем следующий автомат: Q={⟨q_1,
    q_2⟩ | q_1 ∈ Q_1, q_2 ∈ Q_2}. Иначе говоря, состояние в новом автомате — пара
    из состояния первого автомата и состояния второго автомата. s=⟨s_1, s_2⟩ Стековый
    алфавит Γ остается неизменным. T={⟨t_1, t_2⟩ ∣ t_1 ∈ T_1, t_2 ∈ T_2}. Допускающие
    состояния нового автомата — пары состояний, где оба состояния были допускающими
    в своем автомате. δ(⟨q_1, q_2⟩, c, d)=⟨δ_1(q_1, c), δ_2(q_2, c, d)⟩. При этом
    на стек кладется то, что положил бы изначальный МП-автомат при совершении перехода
    из состояния q_2, видя на ленте символ c и символ d на вершине стека. Этот автомат
    использует в качестве состояний пары из двух состояний каждого автомата, а за
    операции со стеком отвечает только МП-автомат. Слово допускается этим автоматом
    тогда и только тогда, когда слово допускается и ДКА и МП-автоматом, то есть язык
    данного автомата  совпадает с L ∩ R.

    '
  author: Якубов Павел
  id: 125
  questions:
  - 'Замкнуты ли контекстно-свободные языки относительно операции ''пересечение с
    регулярным языком''?

    '
- answer: 'Неукорачивающая грамматика (англ. noncontracting grammar) — это формальная
    грамматика, всякое правило из P которой имеет вид α→β, где α, β ∈ {Σ ∪ N}+ и |α|⩽|β|
    (возможно правило S→ε, но тогда S не встречается в правых частях правил).

    '
  author: Якубов Павел
  id: 126
  questions:
  - 'Что такое неукорачивающаяся грамматика в теории формальных языков?

    '
- answer: 'Грамматикой в ослабленной нормальной форме Грейбах (англ. Greibach weak
    normal form) называется контекстно-свободная грамматика, в которой могут содержаться
    только правила одного из следующих типов: A→aγ, S→ε, где a — терминал, A — нетерминал
    (возможно, стартовый), S — стартовый нетерминал (причём он не должен встречаться
    в правых частях правил), ε — пустая строка, γ — строка из произвольного числа
    терминалов и нетерминалов.

    '
  author: Якубов Павел
  id: 127
  questions:
  - 'Что такое грамматика в ослабленной нормальной форме Грейбах?

    '
- answer: "Рассмотрим контекстно-свободную грамматику Γ. Для приведения её к нормальной\
    \ ослабленной форме Грейбах нужно выполнить три шага. На каждом шаге мы строим\
    \ новую грамматику, допускающую тот же язык, что и Γ. 1. Избавимся от ε-правил.\
    \ Для этого воспользуемся алгоритмом удаления ε-правил. 2. Воспользуемся алгоритмом\
    \ устранения левой рекурсии. Получим грамматику, все правила которой будут иметь\
    \ следующий вид: A_i→aγ, A_i→A_jγ, где A_i, A_j — нетерминалы, a — терминал, γ\
    \ — произвольная последовательность из терминалов и нетерминалов, i<j. Если данное\
    \ условие выполняется для всех A_i, то в грамматике нет правил вида A_i ⇒* A_i,\
    \ а значит не будет левой рекурсии. 3. Воспользуемся следующей функцией для придания\
    \ грамматике нужного вида: function greibah(правила A_1...A_n из контекстно-свободной\
    \ грамматики Γ) {\n    for i = n .. 1 {\n        for j = i + 1 .. n {\n      \
    \      Для каждого правила вывода из A_j вида A_j→α_1|...|α_k заменить каждое\
    \ правило A_i→A_jγ на A_i→α_1γ|...|α_kγ.\n            С помощью данного преобразования\
    \ любое правило, правая часть которого начинается с нетерминала,\n           \
    \ будет превращено в эквивалентное, правая часть которого начинается с терминала,\
    \ что удовлетворяет\n            определению ослабленной нормальной формы Грейбах.\n\
    \        }\n    }\n} После каждой итерации главного цикла все правила для A_k\
    \ (где k⩾i) будут иметь вид A_k→aγ. Значит, после применения процедуры все правила\
    \ грамматики будут иметь вид A→aγ. Пример: 0. Исходная грамматика\t S→XA|BB B→b|SB\
    \ X→b A→a 1. Удаление ε-правил\t S→XA|BB B→b|SB X→b A→a 2. Удаление стартового\
    \ нетерминала из правых частей правил\t S→XA|BB B→bAB|BBB|b X→b A→a 3. Удаление\
    \ левой рекурсии\t S→XA|BB B→bAB|b|bABZ|bZ Z→BB|BBZ X→b A→a 4. Выполняем функцию\
    \ greibah для правила S→XA|BB\t S→bA|bABB|bB|bABZB|bZB B→bAB|b|bABZ|bZ Z→BB|BBZ\
    \ X→b A→a 5. Выполняем функцию greibah для правила Z→BB|BBZ\t S→bA|bABB|bB|bABZB|bZB\
    \ B→bAB|b|bABZ|bZ Z→bABB|bB|bABZB|bZB|bABBZ|bBZ|bABZBZ|bZBZ X→b A→a Таким образом,\
    \ мы получили грамматику в ослабленной нормальной форме Грейбах, которая допускает\
    \ тот же язык, что и исходная.\n"
  author: Якубов Павел
  id: 128
  questions:
  - 'Докажи, что любую контекстно-свободную грамматику можно привести к ослабленной
    нормальной форме Грейбах.

    '
- answer: 'Рекурсивный нетерминал (англ. recursive nonterminal symbol) — такой нетерминал
    A контекстно-свободной грамматики G = ⟨N, Σ, P, S⟩, что A ⇒* αAβ для некоторых
    α и β, причем α≠ε ∧ β≠ε.  Если α=ε, то A называется леворекурсивным. Аналогично,
    если β≠ε, то A называется праворекурсивным. Контекстно-свободная грамматика, содержащая
    рекурсивный нетерминал, называется самоприменимой (англ. self-embedded).

    '
  author: Якубов Павел
  id: 129
  questions:
  - 'Что такое рекурсивный нетерминал?

    '
- answer: 'Нетерминалы A, B ∈ N в грамматике G = ⟨N, Σ, P, S⟩ называются взаимно рекурсивными
    (англ. mutual recursive), если ∃ α_1, β_1, α_2, β_2 ∈ (Σ ∪ N)* : A ⇒* α_1Bβ_1
    ∧ B ⇒* α_2Aβ_2 .

    '
  author: Якубов Павел
  id: 130
  questions:
  - 'Что такое взаимно рекурсивные нетерминалы?

    '
- answer: 'Рассмотрим контекстно-свободную грамматику Γ. Для приведения ее к нормальной
    форме Хомского необходимо выполнить пять шагов. На каждом шаге мы строим новую
    Γ_i, которая допускает тот же язык, что и Γ. 1. Уберём длинные правила. Воспользуемся
    алгоритмом удаления длинных правил из грамматики. Получим грамматику Γ_1, эквивалентную
    исходной, содержащую правила длины 0, 1 и 2. 2. Пусть |Γ| - сумма длин правых
    частей правил. Данный алгоритм добавляет в грамматику O(|Γ|) новых нетерминалов,
    O(|Γ|) новых правил длины O(1) и, следовательно, работает за O(|Γ|). Удаление
    ε-правил. Воспользуемся алгоритмом удаления ε-правил из грамматики. Получим грамматику
    Γ_2, эквивалентную исходной, но в которой нет ε-правил. 3. Удаление цепных правил.
    Воспользуемся алгоритмом удаления цепных правил из грамматики. Алгоритм работает
    таким образом, что новые ε-правила не образуются. Получим грамматику Γ_3, эквивалентную
    Γ. 4. Удалим бесполезные символы. Воспользуемся алгоритмом удаления бесполезных
    символов из грамматики. Так как Γ_3 эквивалентна Γ, то бесполезные символы не
    могли перестать быть бесполезными. Более того, мы только удаляем правила, новые
    ε-правила и цепные правила не могли появиться. 5. Уберём ситуации, когда в правиле
    встречаются несколько терминалов. Для всех правил вида A → u_1u_2 (где u_i — терминал
    или нетерминал) заменим все терминалы u_i на новые нетерминалы U_i и добавим правила
    U_i→u_i. Теперь правила содержат либо одиночный терминал, либо строку из двух
    нетерминалов. Таким образом, мы получили грамматику в нормальной форме Хомского,
    которая допускает тот же язык, что и Γ. Стоит заметить, что порядок выполнения
    операций важен. Первое правило должно быть выполнено перед вторым, иначе время
    нормализации ухудшится до O(2^|Γ|).  (|Γ| - размер грамматики - численно равен
    числу символов в правой части правил вывода). Третье правило идет после второго,
    потому что после удаления ε-правил, могут образоваться новые цепные правила. Также
    четвертое правило должно быть выполнено позже третьего и второго, так как они
    могут порождать бесполезные символы. При таком порядке действий размеры грамматики
    возрастают полиномиально. После удалении длинных правил из каждого правила длины
    k⩾3 могло появиться k−1 новых правил, причем их длина не превышает двух. На этом
    шаге размер грамматики возрастает не более, чем вдвое. При удалении ε-правил из
    грамматики, содержащей правила длины 0, 1 и 2, размеры грамматики могли вырасти
    не больше, чем в 3 раза. Всего цепных правил в грамматике не больше, чем n^2,
    где n — число нетерминалов. При удалении цепных правил мы берем каждую из цепных
    пар и производим добавление нецепных правил, выводимых из второго нетерминала
    в паре. Если максимальная суммарная длина всех правил, выводимых из какого-либо
    нетерминала, равна k, то размер грамматики возрастет не больше, чем на k*n^2.
    Наконец, на последнем шаге может произойти добавление не более, чем |Σ| (Σ — алфавит
    грамматики) новых правил, причем все они будут длины 1.

    '
  author: Якубов Павел
  id: 131
  questions:
  - 'Докажи, что любую контекстно-свободную грамматику можно привести к нормальной
    форме Хомского.

    '
- answer: 'Позицией в слове длины k назовем такое целое i, что 1 ≤ i ≤ k. Символ a
    занимает позицию i в слове ω, если ω = xay и |x| = i - 1. Выделенные (помеченные,
    размеченные) позиции в слове - некоторое подмножество всех позиций в нём. Лемма
    Огдена для контекстно-свободных языков является расширением леммы о накачке для
    контекстно-свободных языков. Она отличается от леммы о накачке тем, что  позволяет
    сосредоточиться на любых p «выделенных» позициях цепочки ω и гарантирует, что
    накачиваемые цепочки содержат от 1 до p выделенных позиций. Преимущество этого
    свойства в том, что язык может иметь цепочки, состоящие из двух частей, одна из
    которых может быть накачана без создания цепочек, не принадлежащих языку, тогда
    как вторая при накачке обязательно порождает цепочки вне языка. Если мы не можем
    утверждать, что накачка имеет место во второй части, то мы не можем завершить
    доказательство того, что язык не контекстно-свободный.  Лемма Огдена утверждает,
    что если язык L контекстно-свободен, то существует некоторое число p > 0 (где
    p может быть, а может и не быть длиной накачки), такое что  для любой строки ω
    ∈ L длины не меньше p и для любой «разметки» p или более позиций в ω,  w может
    быть представлено в виде ω = uvxyz, где u, v, x, y, и z — строки, такие что: 1.
    x содержит по меньшей мере одну помеченную позицию; 2. либо и u и v содержат помеченную
    позицию, либо её содержат и y и z; 3. vxy содержит не более p помеченных позиций;
    4. u(v^i)x(y^i)z принадлежит L для любого i ≥ 0. Лемма Огдена может использоваться
    для доказательства того, что данный язык не является  контекстно-свободным, в
    случаях, когда леммы о накачке для контекстно-свободных языков недостаточно.  Примером
    может быть язык {(a^i)(b^j)(c^k)(d^l) : i = 0 или j = k = l}.  Она также полезна
    для доказательства существенной неоднозначности некоторых языков. Заметим, что
    если все позиции помечены, данная лемма эквивалентна лемме о накачке для контекстно-свободных
    языков.

    '
  author: Якубов Павел
  id: 132
  questions:
  - 'Сформулируй лемму Огдена для контекстно-свободных языков.

    '
- answer: 'Контекстно-свободную грамматику (англ. context-free grammar, CFG) образуют  1.
    Алфавит (Σ) (англ. terminals): Набор терминальных символов, из которых формируются
    строки языка. Эти символы не подлежат дальнейшей замене. Терминалы обозначаются
    строчными буквами из начала латинского алфавита (например: a,b,c). 2. Нетерминальные
    символы (синтаксические категории) (N) (англ. nonterminals): Символы, которые
    могут быть заменены другими символами или последовательностями символов. Каждый
    нетерминальный символ представляет язык, т.е. множество цепочек. Нетерминалы обозначаются
    заглавными буквами латинского алфавита (например: A,B,C). 3. Начальный символ
    (S) (англ. start symbol): Один из нетерминальных символов, который используется
    в качестве точки начала для генерации строк языка. Другие нетерминалы представляют
    дополнительные классы цепочек, которые помогают определить язык, заданный стартовым
    символом. Обычно обозначается буквой S, но может быть любым другим нетерминальным
    символом.  4. Правила продукции (P) (англ. production rules или productions):
    Набор правил, определяющих, как нетерминальные символы могут быть заменены на
    терминальные или другие нетерминальные символы. Каждое правило имеет вид A → α,
    где A — нетерминальный символ, а α — конечная цепочка, состоящая из терминалов
    и нетерминалов, возможно, пустая. Она называется телом продукции и представляет
    способ образования цепочек языка.

    '
  author: Проклашкина Софья
  id: 133
  questions:
  - 'Какие 4 компонента образуют контекстно-свободную грамматику?

    '
- answer: 'Нет, язык палиндромов L не является регулярным языком.  Используем лемму
    о накачке (англ. pumping lemma) для доказательства. Пусть язык палиндромов регулярен
    и n - длина накачки. Рассмотрим в языке такие палиндромы w = a^nba^n. Если L регулярен,
    то w можно разбить на w = xyz так, что y состоит из одной или нескольких a из
    их первой группы. Тогда в слове xz, которое также должно быть в L, если L регулярен,
    слева от b будет меньше a, чем справа. Следовательно, xz не может быть палиндромом,
    что противоречит предположению о регулярности L. Таким образом, для целого ряда
    слов из языка не выполняются условия леммы о накачке, язык нерегулярен. Однако,
    язык палиндромов является контекстно-свободным (доказывается это тем фактом, что
    язык можно описать с помощью контекстно-свободной грамматики следующего вида:
    S → aSa, S → bSb, ... S → zSz, S → a, S → b, ... S → z, S → ε).

    '
  author: Проклашкина Софья
  id: 134
  questions:
  - 'Является ли язык палиндромов регулярным?

    '
- answer: 'Следствие теоремы Майхилла-Нероде (англ. Myhill-Nerode theorem) гласит,
    что язык регулярен тогда и только тогда, когда число классов эквивалентности конечно.  Построим
    бесконечное число классов эквивалентности в языке Дика. Выберем все такие префиксы
    над алфавитом {''('', '')''} (не обязательно являющимися словами в языке Дика)
    следующего вида: S = { (^n | n ≥ 0 }. Для каждого такого префикса суффиксом, оставляющим
    это слово в языке будет являться строка вида S = { )^n | n ≥ 0 }. Число префиксов
    не конечно, каждый префикс является классом эквивалентности, поскольку суффиксы,
    оставляющие слово в языке, для всех префиксов будут отличаться. Следовательно,
    по следствию о классах эквивалентности из теоремы Майхилла-Нероде, язык нерегулярен.

    '
  author: Проклашкина Софья
  id: 135
  questions:
  - 'Докажи, что язык Дика (англ. Dyck language) нерегулярен с помощью теоремы Майхилла-Нероде

    '
- answer: "Для каждой контекстно-свободной грамматики (КС-грамматика, англ. context-free\
    \ grammar, CFG) существует автомат с магазинной памятью (МП-автомат, автомат со\
    \ стеком, англ. pushdown automaton), который распознает тот же язык, что и генерирует\
    \ контекстно-свободная грамматика и наоборот - для каждого автомата с магазинной\
    \ памятью существует контекстно-свободная грамматика, которая генерирует тот же\
    \ язык, что и распознает этот автомат. Формальное определение перехода между ними:\
    \ МП-автомат -> КС-грамматика:\n  Пусть G = (N, Σ, P, S) — контекстно-свободная\
    \ грамматика.\n  Σ: алфавит\n  N: нетерминальные символы\n  P: правила продукции\n\
    \  S: начальный символ\n  Тогда существует автомат с магазинной памятью M, который\
    \ допускает L(G) по пустому магазину\n\n  Построим МП-автомат M = ({q}, Σ, N U\
    \ Σ, δ, q, S)\n  {q}: состояние\n  Σ: конечное множество входных символов\n  N\
    \ U Σ: конечный магазинный алфавит\n  δ: функция переходов\n  q: начальное состояние\n\
    \  S: начальный магазинный символ (“маркер дна”)\n  \n  Функция переходов δ определена\
    \ таким образом:\n  1. δ(q, ε, A) = {(q, β) | A → β — продукция G} для каждой\
    \ переменной A. \n  2. δ(q, a, a) = {(q, ε)} для каждого терминала a.\n\nКС-грамматика\
    \ -> МП-автомат\n  Пусть M = (Q, Σ, Γ, δ, q_0, Z_0) — автомат с магазинной памятью.\
    \ \n  Q: конечное множество состояний\n  Σ: конечное множество входных символов\n\
    \  Γ: конечный магазинный алфавит\n  δ: функция переходов\n  q_0: начальное состояние\n\
    \  Z_0: начальный магазинный символ (“маркер дна”)\n  Тогда существует КС-грамматика\
    \ G, для которой L(G) = N(P).\n  \n  Построим КС-грамматику G = (N, Σ, P, S)\n\
    \  Σ: алфавит\n  N: нетерминальные символы\n  P: правила продукции\n  S: начальный\
    \ символ\n  N состоит из следующих переменных: \n    - Специальный стартовый символ\
    \ S.\n    - Нетерминалы — тройки [p, A, q], где p, q ∈ Q, A ∈ Г. Такие тройки\
    \ имеют следующий смысл: в процессе изменения состояния автомата от p до q символ\
    \ A удаляется с вершины стека, не затрагивая то, что находится ниже.  \n  Грамматика\
    \ G имеет следующие продукции:\n  - по каждому переходу вида (q, t, A) → (p, A_1\
    \ . . . A_k) (q - состояние, t - символ из Σ или ε (пустое слово), A - символ\
    \ из Γ, A_1, A_2 ... A_k - цепочка символов из Γ, которые замещают A в магазине)\
    \ добавим правила для всех состояний автомата q_1, q_2, ... q_k вида [q, A, q_k]\
    \ → t[p, A_1, q_1][q_1, A_2, q_2]...[q_n−1, A_n, q_n].  \n    Такие продукции\
    \ гласят, что один из путей выталкивания A и перехода из состояния q в состояние\
    \ q_k заключается в том, чтобы прочитать t, затем использовать некоторый вход\
    \ для выталкивания A_1 из магазина с переходом из состояния q в состояние q_1,\
    \ далее прочитать некоторый вход, вытолкнуть A_2 и перейти из q_1 в q_2 и т.д.\
    \  \n  - по каждому переходу вида (q, t, A) → (p, ε) добавим правило [q, A, p]\
    \ → t (ε - пустое слово). Такая продукция говорит о том, что данный нетерминал\
    \ [q, A, p] однозначно переписывается в терминальный символ t.\n  - разрешим стартовому\
    \ состоянию переписываться в любое из [q_0, Z_0, q]. Эти продукции гласят, что\
    \ стартовый символ S порождает все цепочки, приводящие автомат к опустошению магазина\
    \ после старта в начальной конфигурации.\n  Таким образом, если обобщить - класс\
    \ языков, допускаемых автоматами с магазинной памятью как по заключительному состоянию,\
    \ так и по пустому магазину, совпадает с классом контекстно-свободных языков\n"
  author: Проклашкина Софья
  id: 136
  questions:
  - 'Как связаны контекстно-свободные грамматики и автоматы с магазинной памятью?

    '
- answer: 'Цепная пара (unit pair) - это пара (A, B), для которой A → B получается
    с использованием лишь цепных продукций. Цепная продукция (unit rule) - правило
    вида A → B, где A и B — нетерминалы.

    '
  author: Проклашкина Софья
  id: 137
  questions:
  - 'Что такое цепная пара в контекстно-свободных языках?

    '
- answer: "Польза нормальной формы Хомского (англ. Chomsky normal form, CNF) в следующих\
    \ аспектах:  - Неукорачивающие применения правил. (Грамматика называется неукорачивающей,\
    \ если для всех её продукций α → β (где α и β — строки нетерминальных и терминальных\
    \ символов) выполняется неравенство |α| ≤ |β|, то есть β имеет не менее как столько\
    \ же символов, сколько α.) - Нет пустых переходов - правила либо финальные, либо\
    \ удлиняющие;  - Контролируемый рост длины сентенциальной формы от количества\
    \ шагов разбора. Сентенциальная форма (англ. Sentential form) — последовательность\
    \ терминалов и нетерминалов, выводимых из начального символа. При каждом шаге\
    \ разбора:\n  • Если применяется правило  A → BC , то длина строки не меняется.\n\
    \  • Если применяется правило  A → a , то длина строки увеличивается на 1.\n \
    \ Таким образом, если у нас есть  n  шагов разбора, то максимальная длина результирующей\
    \ строки может составлять  n  (если все шаги — это замены на терминалы). Поскольку\
    \ каждое правило контролирует, как именно происходит увеличение длины строки,\
    \ можно сказать, что количество шагов разбора прямо пропорционально длине итоговой\
    \ строки. Это позволяет предсказать, как будет расти длина строки в зависимости\
    \ от числа примененных правил.\n- Перевод грамматики в нормальную форму Хомского\
    \ позволяет легче анализировать свойства её языка и проводить разбор слов. (Использование\
    \ CNF позволяет применять алгоритмы синтаксического анализа, такие как алгоритм\
    \ CYK (Cocke-Younger-Kasami), которые работают эффективно и имеют полиномиальную\
    \ временную сложность. При работе с грамматиками в НФХ становится проще доказывать\
    \ различные свойства, такие как выводимость строк или принадлежность строк языку,\
    \ благодаря унифицированной структуре правил)\n"
  author: Проклашкина Софья
  id: 138
  questions:
  - 'Какой смысл нормальной формы Хомского?

    '
- answer: 'Крона дерева разбора (англ. leaves of the parse tree, terminal yield, fringe)
    - множество терминальных символов, упорядоченное в соответствии с номерами их
    достижения при обходе дерева в глубину из корня. Крона дерева разбора представляет
    из себя слово языка, которое выводит это дерево.

    '
  author: Проклашкина Софья
  id: 139
  questions:
  - 'Что такое крона дерева разбора грамматики?

    '
- answer: 'Грамматика называется однозначной (англ. unambiguous grammar), если у каждого
    слова имеется не более одного дерева разбора в этой грамматике, то есть существует
    только один способ разбора.  Существуют языки, которые можно задать одновременно
    как однозначными, так и неоднозначными грамматиками. Однако, есть контекстно-свободные
    языки, для которых не существует однозначных контекстно-свободных грамматик. Такие
    языки и грамматики их порождающие называют существенно неоднозначными (англ. inherently
    ambiguous language).  Существенно неоднозначные грамматики всегда выводят недетерминированный
    язык, однако недетерминированный язык может быть задан однозначной грамматикой
    (например, язык палиндромов)

    '
  author: Проклашкина Софья
  id: 140
  questions:
  - 'Что такое однозначная грамматика?

    '
- answer: 'Контекстно-зависимая грамматика (англ. context-sensitive grammar, CSG)
    представлена в нормальной форме Куроды (НФ Куроды, англ. Kuroda normal form),
    если каждое правило имеет одну из четырех форм:  1. AB → CD; 2. A → BC;  3. A
    → B;  4. A → a или A → ε.  Здесь A, B, C, D — нетерминалы, a a — терминал, ε -
    пустое слово. Любая контекстно-зависимая грамматика, не генерирующая ε, может
    быть представлена в нормальной форме Куроды Контекстно-свободная грамматика (англ.
    context-free grammar, CFG), которая может генерировать ε только из стартового
    терминала и не имеет цепных правил, в НФ Куроды имеет ту же форму, что в нормальной
    форме Хомского (у контекстно-свободных грамматик в левой части стоят только одиночные
    терминалы (правила в форме AB → CD не будут присутствовать))   То есть, грамматика
    в нормальной форме Хомского - это грамматика в нормальной форме Куроды, в которой
    нет эпсилон правил (не генерирует ε) кроме как для стартого нетерминала, нет левых
    частей длины 2 и цепных правил.

    '
  author: Проклашкина Софья
  id: 141
  questions:
  - 'Что такое нормальная форма Куроды?

    '
- answer: 'Контекстно-зависимая грамматика (англ. context-sensitive grammar, CSG)
    представлена в нормальной форме Пенттонена (НФ Пенттонена, англ. Penttonen normal
    form), если каждое правило имеет одну из трех форм:  1. AB → AC;  2. A → BC;  3.
    A → a или A → ε. Здесь A, B, C, D — нетерминалы, a a — терминал, ε - пустое слово.
    Также грамматику Пенттонена называют односторонней нормальной формой (англ. one-sided
    normal form). Она является частным случаем нормальной формы Куроды: когда A =
    C в первом правиле определения. Для каждой контестно-зависимой грамматики существует
    слабо эквивалентная ей грамматика в форме Пенттонена. Слабая эквивалентность двух
    грамматик означает, что они генерируют один и тот же набор строк, т.е. язык, который
    они задают, один и тот же. Контекстно-свободная грамматика (англ. context-free
    grammar, CFG), которая может генерировать ε только из стартового терминала и не
    имеет цепных правил, в нормальной форме Пенттонена имеет ту же форму, что в нормальной
    форме Хомского (англ. Chomsky normal form, CNF) (у контекстно-свободных грамматик
    в левой части стоят только одиночные терминалы (правила в форме AB → AC не будут
    присутствовать)) То есть, грамматика в нормальной форме Хомского - это грамматика
    в нормальной форме Пенттонена, в которой нет эпсилон правил (не генерирует ε)
    кроме как для стартого нетерминала, нет левых частей длины 2 и цепных правил.

    '
  author: Проклашкина Софья
  id: 142
  questions:
  - 'Что такое нормальная форма Пенттонена?

    '
- answer: 'Грамматика представлена в нормальной форме Грейбах (НФ Грейбах, англ. Greibach
    normal form, GNF), если каждое ее правило имеет вид A → aα, где A - нетерминал,
    α - цепочка из нуля или нескольких нетерминалов, a - терминал. Использование нормальной
    формы Грейбах позволяет доказать, что для каждого контекстно-свободного языка
    (не содержащего ε - пустого слова) существует автомат с магазинной памятью без
    переходов по ε, распознающий тот же язык, а также позволяет использовать для разбора
    метод рекурсивного спуска, что удобно в данном случае, поскольку нормальная форма
    Грейбах исключает левую рекурсию.  Число шагов в итоговом дереве разбора будет
    линейным, поэтому недетерминированный алгоритм будет линейным (так как каждое
    использование продукции вводит ровно один терминал в выводимую цепочку, цепочка
    длины n порождается в точности за n шагов), однако детерминированный алгоритм
    может потребовать дополнительных структур данных для обработки возвратов (по аналогии
    с обработкой строки недетерминированным конечным автоматом без ε-переходов - для
    него также необходима корректная обработка возвратов)

    '
  author: Проклашкина Софья
  id: 143
  questions:
  - 'В чем практическая польза нормальной формы Грейбах?

    '
- answer: 'Иерархия грамматик Хомского (англ. Chomsky hierarchy) Класс 0: К нулевому
    классу относятся все формальные грамматики. Элементы этого класса называются неограниченными
    грамматиками (англ. unrestricted grammars), поскольку на них не накладывается
    никаких ограничений. Они задают все языки, которые могут быть распознаны машиной
    Тьюринга. Эти языки также известны как рекурсивно перечислимые (англ. recursively
    enumerable) - язык, для которого существует программа g такая, что g(i)=x_i, L
    = {x_1, x_2, .. , x_n, ..} Класс 1: Первый класс представлен неукорачивающими
    (неукорачивающая грамматика (англ. noncontracting grammar) — это формальная грамматика,
    всякое правило из P которой имеет вид α → β, где α, β ∈ {Σ∪N}+ и |α|⩽|β| (возможно
    правило S → ε, но тогда S не встречается в правых частях правил)) и контекстно-зависимыми
    грамматиками (контекстно-зависимая грамматика (англ. context-sensitive grammar)
    — это формальная грамматика, всякое правило из P которой имеет вид αAβ → αγβ,
    где α, β ∈ {Σ∪N}*, A ∈ N и γ ∈ {Σ∪N}+ (возможно правило S→ε, но тогда S не встречается
    в правых частях правил)). Языки, заданные этими грамматиками, распознаются с помощью
    линейно ограниченного автомата (англ. linear bounded automaton) (недетерминированная
    машина Тьюринга, чья лента ограничена константой, зависящей от длины входа.) Известно,
    что неукорачивающие грамматики эквивалентны контекстно-зависимым.  Класс 2: Второй
    класс составляют контекстно-свободные грамматики, которые задают контекстно-свободные
    языки. Эти языки распознаются с помощью автоматов с магазинной памятью.  Класс
    3: К третьему типу относятся автоматные или регулярные грамматики (англ. regular
    grammars) — самые простые из формальных грамматик, которые задают регулярные языки.
    Они являются контекстно-свободными, но с ограниченными возможностями. Множество
    языков, генерируемых праволинейными грамматиками из этого класса, распознаются
    конечными автоматами. Праволинейная грамматика (англ. right-regular grammar) —
    это формальная грамматика, всякое правило из P которой имеет вид A → γB; или A
    → γ, где γ ∈ Σ; A, B ∈ N.

    '
  author: Проклашкина Софья
  id: 144
  questions:
  - 'Опиши иерархию грамматик Хомского

    '
- answer: 'Производная Бржозовски (Brzozowski derivative) языка L по фиксированному
    слову u - это множество  u^(-1)L = {w|uw ∈ L} слов, которые получены из слов языка
    L, путём удаления в них префикса равного слову u. Производная Бржозовски образуется
    из объединения частных производных Антимирова в одно выражение. Верно следующее:
    ε ∈ u^(-1)L => u ∈ L, то есть, если пустое слово принадлежит производной Бржозовски
    языка L по слову u,  то из это следует, что слово u принадлежит языку L. На практике
    производные Бржозовски (Brzozowski derivative) можно  использовать для проверки
    того, принимает ли регулярное выражение произвольное слово или нет.  Стоит отметить,
    что частная производная Бржозовски регулярного языка по фиксированному слову u
    - это одно  регулярное выражение, а не множество, состоящее из регулярных выражений.

    '
  author: Утебаева Милена
  id: 145
  questions:
  - 'Определение производной языка по слову.

    '
  - 'Производные Бржозовски (Brzozowski derivative) по слову

    '

- answer: 'Степень недетерминизма НКА (NFA), обозначим автомат буквой A, - это функция
    f(n), зависящая от натурального  числа n, такая, что её значение на аргументе
    n равно наибольшему возможному числу путей разбора слова длины n в автомате A.
    Если для любого натурального числа n значение функции f(n) равное единице, то
    автомат A называется однозначным. Если существует некоторое натуральное число
    N, такое, что для любого натурального числа n значение функции f(n) не превосходит
    числа N, то автомат A называется конечно неоднозначным. Если существует натуральное
    k, такое, что значение функции f(n) оценивается как O(n^k),  то автомат A называется
    полиномиально неоднозначным. Если существует натуральное k, такое, что значение
    функции f(n) оценивается как O(k^n),  то автомат A называется экспоненциально
    неоднозначным. Других видов неоднозначностей в недетерминированных конечных автоматах
    (Nondeterministic Finite Automaton) не существует. Экспоненциальная неоднозначность
    возникает тогда, когда существует хотя бы два различных пути из одного состояния
    автомата в другое. Полиномиальная неоднозначность возникает тогда, когда для каждого
    из двух различных состояний,  между которыми существует путь по слову w, существуют
    циклы по w.

    '
  author: Утебаева Милена
  id: 146
  questions:
  - 'Определение степени неоднозначности недетерминированного конечного автомата (Nondeterministic
    Finite Automaton).

    '
  - 'Виды неоднозначностей неоднозначности недетерминированного конечного автомата:
    полиномиальная неоднозначность, экспоненциальная неоднозначность

    '
  - 'Полиномиальная неоднозначность, экспоненциальная неоднозначность недетерминированного
    конечного автомата

    '
- answer: 'Класс языков, которые распознаются PDA (Pushdown Automata) не совпадает
    с классом языков,  которые распознаются распознаются DPDA (Deterministic Pushdown
    Automata). Можно сказать, что класс языков, которые  распознаются PDA, является
    более широким, по сравнению с классом языков, которые распознаются DPDA. Пример
    языка, который распознаётся DPDA и PDA: L = {a^(n)b^(n) | n >= 0}. Пример языка,
    который не распознаётся DPDA, но распознаётся PDA: язык чётных палиндромов

    '
  author: Утебаева Милена
  id: 147
  questions:
  - 'Совпадает ли класс языков, которые распознаются PDA (Pushdown Automata) c классом
    языков, которые  распознаются DPDA (Deterministic Pushdown Automata)?

    '
- answer: 'Беспрефиксный язык (prefix-free) - это язык для которого любые два слова
    из этого языка не являются префиксами друг друга. Беспрефиксными языками являются:  1.
    Множество утверждений, состоящих из переменных, логических операций и скобок,  которые
    могут быть только истины или ложны (то есть множество пропозициональных формул).  Пример:
    (x & y), где x и y - пропозициональные переменные (переменные, значениями  которых
    могут являться логические высказывания), & - логическое «и». 2. Множество правильных
    алгебраических выражений (то есть выражений, определяемых следующим образом: любая
    алгебраическая  переменная является правильным алгебраическим выражением). Если
    A и B - правильные алгебраические выражения, и рассматриваем  в качестве алгебраической
    операции +, то (A + B) является правильным алгебраическим выражением, аналогично
    правильное алгебраическое  выражение определяется и для других операций. Пример:
    (12x + 3y) Замечание: для каждой операции необходимы внешние скобки, иначе свойство
    prefix-free может нарушиться.

    '
  author: Утебаева Милена
  id: 148
  questions:
  - 'Какие языки обладают свойством беспрефиксности (prefix-free)? Примеры беспрефиксных
    языков.

    '
  - 'Свойство беспрефиксности для языка

    '
  - 'Примеры беспрефиксных языков

    '
- answer: 'Для построения VPA (Visibly Pushdown Automata) входной алфавит разбивается
    на три непересекающихся части: алфавит символов вызова,  алфавит внутренних символов,
    алфавит символов возврата. При каждом считывании нового символа обрабатываемой
    строки, происходит  изменение стека в зависимости от того, к какому подалфавиту
    он принадлежит: если прочитанный символ принадлежит алфавиту вызова, то происходит
    закладывание на стек, если прочитанный символ принадлежит алфавиту внутренних
    символов, то стек не меняется,  если прочитанный символ принадлежит алфавиту возврата,
    то со стека происходит снятие верхнего элемента. В PDA (Pushdown Automata), в
    отличие от VPA, со стеком можно совершать действия не зависимо от прочитанного
    символа обрабатываемой строки. Также PDA также отличается функцией перехода: функция
    перехода в PDA позволяет переходить по пустому символу, но при этом изменять стек.  Пример:
    язык чётных палиндромов не распознаётся VPA, однако он распознаётся PDA

    '
  author: Утебаева Милена
  id: 149
  questions:
  - 'Чем VPA (Visibly Pushdown Automata) отличается от PDA (Pushdown Automata)?

    '
  - 'Сравнение VPA (Visibly Pushdown Automata) и PDA (Pushdown Automata)

    '
- answer: 'Лемма Ардена (Arden''s rule): пусть X, Y, Z - произвольные языки, X = YX
    | Z, где Z не зависит от X, пустое слово не принадлежит Y. Тогда имеет место следующее
    равенство для языка L задаваемого регулярным выражением X: L(X) = Y*Z, где оператор
    * является  итерацией Клини (Kleene star). Лемма Ардена позволяет решать системы
    уравнений в регулярных выражениях при помощи нетерминального исключения и подстановки,  однако
    важно требованием является отсутствие цепных правил в грамматике

    '
  author: Утебаева Милена
  id: 150
  questions:
  - 'Формулировка леммы Ардена (Arden''s rule). Уравнения с регулярными выражениями

    '
  - 'Лемма для решения систем уравнений в регулярных языках

    '
- answer: 'Переключающийся автомат A (Alternating Finite Automaton) задаётся шестью
    компонентами: A = (Σ, Q, Q_∀, F, q_0, δ), где Σ - алфавит, Q - множество состояний
    автомата, Q_∀ - множество конъюнктивных состояний, F - множество конечных состояний,
    q_0 - стартовое состояние, δ: (Σ ∪ ε) × Q -> Q, то есть, область определения функции
    перехода - это алфавит,  объединённый с пустым словом, а область значений функции
    перехода - это множество состояний. Слово w допускается AFA (Alternating Finite
    Automaton) тогда и только тогда, когда существует путь  q_0 -> q_1 -> ... -> q_n
    (где слово из символов q_0q_1...q_n равно слову w), что если q_i принадлежит Q_∀
    (множеству конъюнктивных  состояний) и конфигурация имеет вид <q_i, v_i> (то есть,
    осталось прочитать суффикс v_i), то v_i распознаётся по  всем переходам из q_i.
    Таким образом, здесь можно проследить аналогию с логическим «и»

    '
  author: Утебаева Милена
  id: 151
  questions:
  - 'Определение переключающегося автомата (Alternating Finite Automaton).

    '
  - 'Автомат имеющий множество конъюнктивных состояний

    '
  - 'Когда слово допускается переключающимся автоматом?

    '
- answer: 'Конъюнктивная грамматика G задаётся четырьмя компонентами: G = <Σ, N, S,
    Δ>, где Σ - алфавит, N - множество нетерминальных символов, S - начальный символ,
    Δ - множество правил, таких, что они имеют вид: A_i -> φ_1 & φ_2 & ... & φ_n,  где
    φ_j ∈ (Σ ∪ N)*, где каждый φ_j, называемый конъюнктом, состоит из терминальных
    и нетерминальных символов,  символ & обозначает конъюнкцию или логическое «и»,
    а оператор * является итерацией Клини (Kleene star). Если строка W удовлетворяет
    всем условиям φ_1, φ_2, ..., φ_n, то W удовлетворяет правилу A_i

    '
  author: Утебаева Милена
  id: 152
  questions:
  - Определение конъюнктивной грамматики
- answer: 'Пример нерекурсивной конъюнктивной грамматики: S -> AB & DC A -> aA | ε
    B -> bBc | ε C -> cC | ε D -> aDb | ε В правилах для всех нетерминалов (кроме
    стартового, который не встречается в правых частях правил) конъюнкция не используется,  так,
    правило для A задаёт язык a*, где * обозначает итерацию Клини (Kleene star), правило
    для C, аналогично, задаёт язык c*,  правило для B, в свою очередь, задаёт язык
    {b^nc^n | n >= 0}, а правило для D задаёт язык {a^mb^m | m >= 0}.  Получаем, что
    первый конъюнкт - AB, определяет строки вида a*b^nc^n, второй конъюнкт - DC,  определяет
    все строки вида a^mb^mc*, тогда, получается, что правило для S определяет строки
    в языке a*b*c*,  которые содержат одинаковое количество символов a, b и одинаковое
    количество символов b, с,  что означает следующее: S определяет все строки в языке
    a*b*c*,  которые содержат одинаковое количество символов a, b, c, а это есть a^nb^nc^n

    '
  author: Утебаева Милена
  id: 153
  questions:
  - 'Пример конъюнктивной грамматики. Нерекурсивная конъюнктивная грамматика

    '
- answer: 'Обозначим символом G конъюнктивную грамматику, G = <Σ, N, S, Δ>, где Σ
    - алфавит, N - множество нетерминальных символов, S - начальный символ, Δ - множество
    правил. Конъюнктивная грамматика G находится в двоичном нормальном виде,  если
    каждое правило в ней имеет следующий вид:  A_i -> B_1C_1 & B_2C_2 & ... & B_mC_m,
    где m >= 1, B_i, C_i - принадлежат множеству нетерминальных символов N A -> a,
    где символ a принадлежит алфавиту Σ S -> ε, только при условии, что S не находится
    в правой части никаких правил

    '
  author: Утебаева Милена
  id: 154
  questions:
  - 'Определение двоичного нормального вида для конъюнктивной грамматики.

    '
  - 'Конъюнктивная грамматика в двоичном нормальном виде

    '
- answer: 'Переходы DFA над односимвольным алфавитом Σ = {a} образуют конечный граф
    со степенью исхода (числом выходящих из вершины рёбер) 1. Поскольку граф конечный
    и степень исхода равна 1, то последовательность переходов, которая началась в  некотором
    начальном состоянии, в некоторый момент переходит в цикл. Количество состояний
    между начальным состоянием и циклом  называется хвостом детерминированного конечного
    автомата (Deterministic Finite Automaton), а длина цикла - периодом. Существует
    теорема, которая утверждает, что всякая КС-грамматика (context-free grammar) над
    односимвольным алфавитом задаёт регулярный язык, но также известно, что регулярные
    языки замкнуты относительно объединения, это означает,  что объединяя односимвольные
    DFA, можно строить регулярные языки итерационно

    '
  author: Утебаева Милена
  id: 155
  questions:
  - 'Описание односимвольного детерминированного конечного автомата (Deterministic
    Finite Automaton).

    '
- answer: 'Для того, чтобы проверить, что язык не является VPL (Visibly Pushdown Language),
    нужно: 1. Построить всевозможные разбиения алфавита Σ на три части: Σ_int - алфавит
    внутренних символов, Σ_call - алфавит символов вызова, Σ_ret - алфавит символов
    возврата, обозначим это разбиение буквой A = (Σ_int, Σ_call, Σ_ret). 2. Для каждого
    из разбиений A нужно попытаться построить бесконечную серию well matched слов.  Важно
    не забыть про разбиение при котором все символы попадают в Σ_int - алфавит внутренних
    символов. Если удалось построить бесконечную серию well matched слов, то язык
    не является VPL (Visibly Pushdown Language). Это можно объяснить тем, что well
    matched слова никак не влияют на стек, их можно рассматривать как слова во внутреннем  алфавите,
    а поскольку VPA имеет конечное число состояний, то число классов well matched
    слов должно быть конечно. Конгруэнция well matched по отношению эквивалентности
    Майхилла-Нероде означает, что в любом контексте можно заменять  сблансированные
    слова (слова, которые имеют структуру правильной скобочной последовательности
    с единственным типом скобок  относительно действий на стек: вызова - call и возврата
    - return, где call принимается за ''('', a return - за '')'') из одного  класса
    эквивалентности друг на друга и это не повлияет на свойство принадлежности языку.

    '
  author: Утебаева Милена
  id: 156
  questions:
  - 'Как проверить, что язык не является VPL (Visibly Pushdown Language)?

    '
- answer: 'Порождения из стартового символа грамматики приводят к цепочкам, которые
    называются ''выводимыми цепочками'' (''sentential form''). Пусть G = (N, Σ, P,
    S) — контекстно-свободная грамматика, где N — множество нетерминалов, Σ — терминалов,
    P — множество продукций, S — стартовый символ. Тогда любая цепочка α из (N U Σ)*,
    которая выводится из стартового символа S с помощью применения продукций, называется
    выводимой цепочкой.   (N U Σ)* - это множество всех возможных цепочек, составленных
    из символов, принадлежащих множествам терминалов Σ и нетерминалов N. Если цепочка
    α выводится из стартового символа S с заменой на каждом шаге вывода самого левого
    нетерминала, то говорят о левом порождении (leftmost derivation), а если заменяется
    самый правый нетерминал — о правом порождении (rightmost derivation). Язык L(G)
    образуют выводимые цепочки из Σ*, состоящие исключительно из терминалов. Σ* -
    это множество всех возможных цепочек из терминалов Σ (замыкание Клини). Таким
    образом, разница между элементами языка грамматики и ''выводимыми цепочками''
    в том, что элементы языка состоят только из терминалов, а ''выводимые цепочки''
    включают в себя как терминалы, так и нетерминалы.

    '
  author: Коровкин Алексей
  id: 157
  questions:
  - 'Как называются цепочки, к которым приводят порождения из стартового символа контекстно-свободной
    грамматики?

    '
- answer: 'G = (N, Σ, P, S) — контекстно-свободная грамматика, где N — множество нетерминалов,
    Σ — терминалов, P — множество продукций, S — стартовый символ. Деревья разбора
    для G — это деревья со следующими свойствами: каждый внутренний узел отмечен нетерминалом
    из N; каждый лист отмечен либо нетерминалом, либо терминалом, либо ε. При этом,
    если лист отмечен ε, он должен быть единственным сыном своего родителя; если внутренний
    узел отмечен A, и его сыновья отмечены слева направо X_1, X_2, …, X_k, соответственно,
    то A → X_1,X_2 ⋅⋅⋅ X_k является продукцией в P. X может быть ε лишь в одном случае
    — если он отмечает единственного сына, и A → ε — продукция грамматики G.

    '
  author: Коровкин Алексей
  id: 158
  questions:
  - 'Какие основные свойства дерева разбора для контекстно-свободной грамматики?

    '
- answer: 'Цепочка 𝜔 имеет два разных дерева разбора тогда и только тогда, когда 𝜔
    имеет два разных левых порождения из P. Если все цепочки, которые порождает грамматика
    G, имеют два разных дерева разбора, то грамматика считается неоднозначной.

    '
  author: Коровкин Алексей
  id: 159
  questions:
  - 'Может ли цепочка 𝜔, порожденная контекстно-свободной грамматикой G = (N, Σ, P,
    S), иметь два разных дерева разбора, если у нее только одно левое порождение из
    P? Σ — множество терминальных символов, N — множество нетерминальных символов,
    S — стартовый символ, P — множество правил продукций.

    '
- answer: 'Пусть G = (N, Σ, P, S) — контекстно-свободная грамматика, где N — множество
    нетерминалов, Σ — терминалов, P — множество продукций, S — стартовый символ. Если
    терминальная цепочка w принадлежит языку нетерминала A, то существует дерево разбора
    с корнем A и кроной w. Крона w (англ. leaves of the parse tree, yield of a tree)
    вычисляется следующим образом: 1) для текущего нетерминала A, из которого нужно
    вывести w, выбирается продукция A → X_1X_2...X_k, где X_i - терминалы или нетерминалы.
    2) Терминальная цепочка w делится на подцепочки w_1,w_2,...,w_k, такие, что каждая
    w_i соответствует X_i. Если X_i - терминал, то w_i = X_i, то есть w_i представляет
    собой единственный терминал из продукции. Если X_i - нетерминал, то w_i представляет
    собой цепочку, о которой уже сделан вывод, что она принадлежит нетерминалу X_i.
    3) Для каждого нетерминала X_i по индукции строится поддерево с корнем X_i и кроной
    w_i. 4) Корни поддеревьев X_1,X_2,...,X_k соединяются с корнем A, а кроны поддеревьев
    объединяются в последовательность w_1w_2...w_k, которая и является кроной w.

    '
  author: Коровкин Алексей
  id: 160
  questions:
  - 'Пусть G = (N, Σ, P, S) — контекстно-свободная грамматика, где N — множество нетерминалов,
    Σ — терминалов, P — множество продукций, S — стартовый символ. Если терминальная
    цепочка w принадлежит языку нетерминала 𝐴, что можно сказать о дереве разбора,
    связанном с этим нетерминалом?

    '
- answer: 'Терминальная цепочка принадлежит языку грамматики тогда и только тогда,
    когда она является кроной, по крайней мере, одного дерева разбора. Таким образом,
    существование левых порождений, правых порождений и деревьев разбора является
    равносильным условием того, что все они определяют в точности цепочки языка контекстно-свободной
    грамматики.

    '
  author: Коровкин Алексей
  id: 161
  questions:
  - 'Может ли терминальная цепочка принадлежать языку контекстно-свободной грамматики,
    если она не является кроной какого-либо дерева разбора для этой грамматики?

    '
- answer: 'Грамматикой в нормальной форме Хомского (англ. Chomsky normal form) называется
    контекстно-свободная грамматика, в которой могут содержаться правила только следующего
    вида: A→BC; A→a; S→ε, где a — терминал, A,B,C — нетерминалы, S — стартовый символ,
    ε — пустая строка, стартовый символ не содержится в правых частях правил. Таким
    образом, грамматика в нормальной форме Хомского имеет следующие ограничения на
    правила: нетерминал A заменяется на два нетерминала B и C. Нетерминал A заменяется
    на терминал a. В нормальной форме Хомского только стартовый символ может быть
    заменён на пустую строку.

    '
  author: Коровкин Алексей
  id: 162
  questions:
  - 'Что такое нормальная форма Хомского?

    '
- answer: 'Если контекстно-свободная грамматика 𝐺1 строится из грамматики G путем
    удаления цепных продукций, то язык 𝐿(𝐺1), порожденный грамматикой G1, совпадает
    с языком 𝐿(𝐺), порожденному грамматикой G. То есть язык грамматики остаётся неизменным
    после удаления цепных продукций.

    '
  author: Коровкин Алексей
  id: 163
  questions:
  - 'Как изменяется язык контекстно-свободной грамматики после удаления цепных продукций?

    '
- answer: 'Язык L контекстно-свободный тогда и только тогда, когда он определяется
    односторонним недетерминированным автоматом с магазинной памятью.

    '
  author: Коровкин Алексей
  id: 164
  questions:
  - 'Обязательно ли контекстно-свободный язык определяется односторонним недетерминированным
    автоматом с магазинной памятью?

    '
- answer: 'Контекстно-свободные языки замкнуты относительно подстановки, объединения,
    конкатенации, обращения, обратного и прямого гомоморфизмов. Контекстно-свободные
    языки не замкнуты относительно пересечения и дополнения, но пересечение контекстно-свободного
    языка с регулярным всегда является контекстно-свободным языком.

    '
  author: Коровкин Алексей
  id: 165
  questions:
  - 'Относительно каких операций замкнуты контекстно-свободные языки?

    '
- answer: 'CYK-алгоритм (Cocke–Younger–Kasami algorithm) представляет собой эффективный
    метод проверки принадлежности цепочки к контекстно-свободному языку. Он начинается
    с грамматики в нормальной форме Хомского (англ. Chomsky normal form) и на вход
    получает цепочку 𝜔 = 𝑎_1𝑎_2…𝑎_𝑛 из терминалов. За время O(n^3) алгоритм строит
    таблицу, которая говорит, принадлежит ли 𝜔 языку L. При вычислении этого времени
    сама по себе грамматика рассматривается фиксированной, и ее размер вносит лишь
    константный сомножитель в оценку времени, измеряемого в терминах длины цепочки,
    проверяемой на принадлежность L. В CYK-алгоритме строится треугольная таблица,
    в ячейке X_ij которой записываются все нетерминалы A, такие, что существует вывод,
    в результате которого A порождает подцепочку 𝑎_i𝑎_(i+1)...𝑎_j. Таблица заполняется
    построчно снизу вверх, начиная с подцепочек длины 1 и заканчивая полной длиной
    (n) цепочки. Алгоритм позволяет определить, принадлежит ли цепочка 𝜔 языку L,
    проверяя, содержится ли стартовый символ S грамматики G в ячейке X_1n. Существуют
    модификации CYK-алгоритма, не требующие того, чтобы грамматика находилась в нормальной
    форме Хомского, а требующие только отсутствия длинных правил. Эти модификации
    вычисляют эпсилон-замыкания и замыкания по цепным правилам на лету. Для оптимизации
    времени работы CYK-алгоритма можно применить метод "четырех русских".

    '
  author: Коровкин Алексей
  id: 166
  questions:
  - 'Как работает CYK-алгоритм (Cocke–Younger–Kasami algorithm) для проверки принадлежности
    цепочки контекстно-свободному языку?

    '
- answer: 'Пусть G = (N, Σ, P, S) — контекстно-свободная грамматика, где N — множество
    нетерминалов, Σ — множество терминалов, P — множество продукций, и S — стартовый
    символ. Пусть длина G равна n (под длиной подразумевается размер множества продукций
    P). Тогда у G может быть порядка n нетерминалов, и каждый проход индуктивного
    обнаружения порождающих нетерминалов может занимать O(n) времени для проверки
    всех продукций G. Если на каждом проходе обнаруживается только один новый порождающий
    нетерминал, то может понадобиться O(n) проходов. Таким образом, простая реализация
    проверки на порождающие символы требует O(n^2) времени, т.е. является квадратичной.
    Однако существует более аккуратный алгоритм, который заранее устанавливает структуру
    данных для того, чтобы обнаружить порождающие символы всего за O(n) времени. Структура
    данных начинает с массива, индексированного нетерминалами, который говорит, установлено
    ли, что нетерминал является порождающим. Массив изначально заполнен значениями
    ''?'', что означает, что для каждого нетерминала еще не установлено, является
    ли он порождающим или нет. В конце алгоритма каждая отметка ''?'' превращается
    в ''нет'', поскольку каждый нетерминал, не обнаруженный алгоритмом как порождающий,
    на самом деле является непорождающим. Для продукций предварительно устанавливается
    несколько видов полезных ссылок. Во-первых, для каждого нетерминала заводится
    список всех возможных позиций, в которых этот нетерминал встречается. Во-вторых,
    для каждой продукции ведется счетчик числа позиций, содержащих нетерминалы, способность
    которых породить терминальную цепочку еще не учтена. Предположим, что мы уже обнаружили,
    что нетерминал — порождающий. Мы спускаемся по списку позиций в телах, содержащих
    этот нетерминал. Для каждой такой позиции уменьшаем счетчик продукции на 1. Когда
    счетчик достигает 0, это означает, что нетерминал в голове продукции тоже порождающий.
    Такой нетерминал можно поместить в очередь нетерминалов, о которых еще неизвестно,
    являются ли они порождающими.

    '
  author: Коровкин Алексей
  id: 167
  questions:
  - 'Какое время требуется для поиска всех порождающих символов в контекстно-свободной
    грамматике?

    '
- answer: 'Автоматной грамматикой (грамматикой типа 3 или А-грамматикой) называется
    контекстно-свободная грамматика с правилами вида: A → aB (или A → Ba), A → a,
    A → ε. A и B - нетерминалы, a - терминал, ε - пустая строка. А-грамматика может
    иметь только правила вида A → aB – правосторонние правила (нетерминал A может
    быть заменён на строку, состоящую из терминала a, за которым следует нетерминал
    B), правила вида A → Ba – левосторонние правила (нетерминал A может быть заменён
    на строку, состоящую из нетерминала B, за которым следует терминал a), правила
    вида A → a (нетерминал A может быть заменён на терминал a). Нетерминал A может
    быть заменён на пустую строку. Язык, порожденный автоматной грамматикой, также
    называется автоматным.

    '
  author: Коровкин Алексей
  id: 168
  questions:
  - 'Какая грамматика называется автоматной?
  
    '
- answer: 'Порождающая грамматика называется неукорачивающей, если для каждого правила
    (α → β) ∈ P, где P - конечное множество правил порождения, выполняется неравенство
    |α| <= |β|.

    '
  author: Рапота Мария
  id: 169
  questions:
  - 'Какая грамматика в иерархии Хомского называется неукорачивающей?

    '
- answer: 'Вполне упорядоченными называются фундированные множества (множества, в
    которых любое непустое подмножество имеет минимальный элемент), являющиеся линейными
    и упорядоченными.

    '
  author: Рапота Мария
  id: 170
  questions:
  - 'Какие множества в теории порядков называются вполне упорядоченными?

    '
- answer: 'Начальным отрезком вполне упорядоченного множества A называется такое множество
    B, что если элемент x входит в начальный отрезок B, то все элементы, которые меньше
    x (по порядку в A), тоже обязательно должны входить в B. Собственным начальным
    отрезком называется начальный отрезок, не равный самому множеству.

    '
  author: Рапота Мария
  id: 171
  questions:
  - 'Что называется начальным отрезком вполне упорядоченного множества?

    '
- answer: 'Пусть a, b и c - элементы вполне упорядоченного множества M. Элемент a
    называется (непосредственным) предшественником b в множестве M, если a < b и не
    существует такого c, что a < c и c < b.

    '
  author: Рапота Мария
  id: 172
  questions:
  - 'Какой элемент вполне упорядоченного множества называется предшественником?

    '
- answer: 'Пусть a, b и c - элементы вполне упорядоченного множества M. Элемент a
    называется (непосредственным) последователем b в множестве M, если a > b и не
    существует такого c, что a > c и c > b.

    '
  author: Рапота Мария
  id: 173
  questions:
  - 'Какой элемент вполне упорядоченного множества называется последователем?

    '
- answer: 'Пусть A и B — два вполне упорядоченных множества. Тогда либо A изоморфно
    некоторому начальному отрезку множества B, либо B изоморфно некоторому начальному
    отрезку множества A.

    '
  author: Рапота Мария
  id: 174
  questions:
  - 'Если A и B - два вполне упорядоченных множества, изоморфны ли они начальному
    отрезку друг друга?

    '
- answer: 'Никакое бесконечное вполне упорядоченное множество не изоморфно своему
    начальному отрезку (не совпадающему со всем множеством).

    '
  author: Рапота Мария
  id: 175
  questions:
  - 'Изоморфно ли бесконечное вполне упорядоченное множество своему начальному отрезку?

    '
- answer: 'Пусть Z — частично упорядоченное множество, в котором всякое подмножество,
    любые два элемента которого сравнимы, имеет верхнюю границу. Тогда в этом множестве
    Z есть максимальный элемент, и, более того, для любого элемента a ∈ Z существует
    элемент b > a, являющийся максимальным в Z. (Верхняя граница подмножества — элемент,
    больший или равный любого элемента этого подмножества.)

    '
  author: Рапота Мария
  id: 176
  questions:
  - 'Лемма Цорна (англ. Zorn''s lemma) в теории порядков

    '
- answer: 'Множества всех элементов A, которые предшествуют x в порядке A, и множества
    всех элементов A, которые предшествуют x или равны x, являются начальными отрезками.

    '
  author: Рапота Мария
  id: 177
  questions:
  - 'Если x — произвольный элемент вполне упорядоченного множества A, чем являются
    множества всех элементов A, которые предшествуют x в порядке A, и множества всех
    элементов A, которые предшествуют x или равны x?

    '
- answer: '1. Если A изоморфно начальному отрезку множества B, не совпадающему со
    всем B, то говорят, что ординал множества A меньше ординала множества B. 2. Если
    множества A и B изоморфны, то говорят, что у них одинаковые ординалы. 3. Если
    B изоморфно начальному отрезку множества A, то говорят, что ординал множества
    A больше ординала множества B.

    '
  author: Рапота Мария
  id: 178
  questions:
  - 'Как происходит сравнение порядковых типов вполне упорядоченных множеств (порядковый
    тип, или ординал, - это характеристика, описывающая структуру порядка в вполне
    упорядоченном множестве)?

    '
- answer: 'Из любых двух множеств (вполне упорядоченных) одно равномощно подмножеству
    другого.

    '
  author: Рапота Мария
  id: 179
  questions:
  - 'Верно ли, что из любых двух вполне упорядоченных множеств одно равномощно подмножеству
    другого?

    '
- answer: 'Если некоторая NP-полная проблема P1 принадлежит P, то P = NP.

    '
  author: Рапота Мария
  id: 180
  questions:
  - 'Если некоторая NP-полная проблема P1 принадлежит классу P (то есть существует
    полиномиальный алгоритм для её решения), то верно ли, что P = NP (все задачи в
    недетерминированном полиномиальном классе NP могут быть решены за полиномиальное
    время)?

    '
- answer: 'Теорема Кука (англ. Cook''s theorem) гласит о том, что проблема выполнимости
    булевых формул NP-полна.

    '
  author: Рапота Мария
  id: 181
  questions:
  - 'NP-полна ли проблема выполнимости булевых формул, которая заключается в вопросе,
    существуют ли значения переменных (в множестве True, False) такие, что формула
    при этих значениях принимает значение True?

    '
- answer: 'Рассмотрим один из способов удаления цепных правил. Чтобы удалить цепные
    правила, то есть правила вида A -> B, где A, B - нетерминалы, построим множества
    N для каждого нетерминала грамматики.  Множества N для нетерминала содержат набор
    нетерминалов, которые составляют с ним цепную пару, а также сам нетерминал.  Для
    того, чтобы построить множество N для нетерминала, каждое цепное правило из рассматриваемого
    нетерминала добавляем в множество N для этого нетерминала и рекурсивно спускаемся
    по цепным правилам, добавляя цепные в множество N до тех пор пока цепных правил
    не будет найдено. Формально: N_0(A) = {A} N_i(A) = N_i-1(A) U {C | B -> C принадлежит
    P, B принадлежит N_i-1(A)} Если N_i(A) не равен N_i-1(A), то i = i+1, иначе N(A)
    = N_i(A) Следующим шагом является переопределение правил грамматики в соответствии
    с найденными множествами. Для каждого нетерминала мы должны пройти по множеству
    N для него и записать все нецепные правила нетерминалов из N(в левой части правила
    при этом будет нетерминал соответствующий N).  Формально: для каждого множества
    N(A) добавляем в новую грамматику правила A -> a, где a - правая часть правила
    B из N(A) Последним шагов является удаление недостижимых правил.  Рассмотрим пример:
    A -> B | ab B -> a | С C -> b Для этой грамматики N(A) = {A, B, C}, N(B) = {B,
    C}, N(C) = {C}. При переопределении правил для A из N(A) записываем A -> ab, для
    B из N(A) - A -> a, для C из N(A) - A -> b. Так переопределяем для всех множеств
    N. Получаем: для N(A): A -> ab A -> a A -> b для N(B): B -> a B -> b для N(C):
    C -> b После удаления недостижимых получаем: A -> ab | a | b

    '
  author: Егорова Алиса
  id: 182
  questions:
  - 'Как удалить цепные правила в контекстно-свободной грамматике?

    '
- answer: "Позиционный автомат строится  для реализации алгоритма LR-разбора слов.\
    \ Для построения позиционного автомата по контекстно-свободной грамматике строим\
    \ блоки. В первом блоке вводим стартовое правило S'->S, которое говорит о том,\
    \ что по нему можно собрать все слово целиком. Когда мы только начинаем читать\
    \ слово, мы находимся перед правой частью S стартового правила S'->.S. Каждый\
    \ раз при построении блока, мы смотрим на положение разбора слова. В случае, если\
    \ мы находимся в положении перед нетерминалом, то записываем в блок все правила,соответвующие\
    \ этому нетерминалу, с указателем входной цепочки в начале правила. Указатель\
    \ показывает положение рабора слова по текущему правилу, то есть последовательность\
    \ символов, находящихся слева от указателя может быть распознана грамматикой по\
    \ правилам, а символ справа от указателя показывает какой символ можно прочитать\
    \ следующим, чтобы продолжить разбор по этому правилу. Указатель обозначается\
    \ . в правиле.  Разбираем все вариации перехода по терминалам и нетерминалам,\
    \ строя при этом блоки. Для этого из всех правил текущего блока выбираем те, у\
    \ которых указатель разбора находится перед символом, по которому идет переход,\
    \ при этом, перенося указатель . на следующий символ. В случае, если точка оказывается\
    \ в конце правила, то это означает свертку, то есть то, что мы можем распознать/свернуть\
    \ слово. При возникновении в одном блоке свертки и при этом позиция разбора в\
    \ других правилах блока не везде находится на конце правила, тогда эта ситуация\
    \ называется конфликт перенос-свертка, аналогично, если свертка происходит по\
    \ финальному S'->S., тогда этот конфликт - конфликт перенос-свертка(с финальным\
    \ правилом). Если свертка происходит в нескольких правилах блока, тогда эта ситуация\
    \ называется конфликтом свертка-свертка, то есть мы не знаем сколько символов\
    \ снять со стека, чтобы считать, что мы прошли разбор.   Если в конфликте свертка-свертка\
    \ есть правила с одинаковыми по длине частями, но для разных нетерминалов, тогда\
    \ при сбросе со стека символов на стеке остается нетерминал, по которому мы должны\
    \ перейти, в нетерминал, по которому произошла свертка. Так возникает недетерминированный\
    \ выбор нетерминала, в который нужно переходить. Все эти конфликты дают недетерминизм\
    \ разбора. \n"
  author: Егорова Алиса
  id: 183
  questions:
  - 'Как построить позиционный автомат по контекстно-свободной грамматике?

    '
- answer: 'Язык L называется разрешимым, если существует такая вычислимая функция
    f, что если слово w принадлежит L, то f(w) = 1 и, если w не принадлежит L, то
    f(w) = 0  Функция f называется вычислимой, если существует программа, вычисляющая
    функцию f, такая, что:  1. если f(n) определено для натурального числа n, то программа
    завершает свою работу на входе n и выводит f(n) 2. если f(n) не определено, то
    программа зависает на входе n.

    '
  author: Егорова Алиса
  id: 184
  questions:
  - 'Когда язык называется разрешимым?

    '
- answer: 'Да, атрибутные грамматики могут распознавать нерекурсивно перечислимые
    языки, если используемые ими функции невычислимы.

    '
  author: Егорова Алиса
  id: 185
  questions:
  - 'Могут ли атрибутные грамматики распознавать нерекурсивно перечислимые языки?

    '
- answer: 'Да, верно. Visible pushdown languages (VPL)- это подкласс детерминированных
    контекстно-свободных языков. Детерминированные контекстно-свободные языки (DCFL):
    Это языки, которые могут быть распознаны детерминированными стековыми автоматами.
    Эти автоматы имеют один стек и принимают входные строки, следуя детерминированным
    правилам перехода. Это означает, что в любой момент времени у автомата есть только
    один возможный переход для обработки текущего символа входной строки и верхнего
    символа стека. Visible pushdown languages (VPL): Это языки, которые могут быть
    распознаны с помощью VPA(Visible pushdown automata).  Все языки, которые могут
    быть распознаны видимыми стековыми автоматами, также могут быть распознаны детерминированными
    видимыми стековыми автоматами. Однако не все детерминированные контекстно-свободные
    языки являются VPL. Например, {a^2n b^n, n - натуральное число} является детерминированным
    контекстно-свободным языком, но не является VPL. То есть, существует множество
    языков, которые могут быть распознаны детерминированными стековыми автоматами,
    но не могут быть распознаны VPL.

    '
  author: Егорова
  id: 186
  questions:
  - 'Верно ли, что visible pushdown languages являются подмножеством детерминированных
    контекстно-свободных языков?

    '
- answer: "Нет, пересечение LL(k)-языка с регулярным языком не всегда является LL(k)-языком.\
    \  Контрпример: Язык {a^n(b | с)^n} - можно пересечь с регулярным выражением a*(b*\
    \ | c*) и получить {a^n(b^n| с^n)} - не LL(k) \n"
  author: Егорова Алиса
  id: 187
  questions:
  - 'Замкнуты ли LL(k)-языки относительно пересечения с регулярным языком?

    '
- answer: 'Повторные нетерминалы при присвоении атрибутов индексируются по вхождениям
    в правило слева направо. То есть, если дано правило, что значение атрибута для
    A (предка) увеличивается на единицу от значения потомка, то тогда A_0.iter :=
    A_1.iter + 1. Неповторные нетерминалы в уравнениях в уравнениях на атрибуты обычно
    не индексируются, например, T.iter := A.iter + B.iter

    '
  author: Егорова Алиса
  id: 188
  questions:
  - 'Как индексируются нетерминалы в атрибутах нетерминалов атрибутной грамматики?

    '
- answer: 'В первую очередь исходное слово необходимо переписать на основании инициальных
    правил, то есть каждый символ слова заменить на соответсвующее состояние из инициального
    правила для данного терминала.  Далее автомат каждые два соседних состояния в
    получившейся последовательности состояний заменяет на состояние из таблицы правил
    перехода для данной пары. При этом на каждом уровне разбора последовательность
    состояний уменьшается на одно.  Процесс идет до тех пор, пока последовательность
    состояний не будет состоять из единственного состояния. Если данное состояние
    находится в множестве финальных, то слово распознается автоматом Треллиса.

    '
  author: Егорова Алиса
  id: 189
  questions:
  - 'Каким образом можно разобрать слово по автомату Треллиса?

    '
- answer: "Уточненная теорема Глайстера-Шаллита. Если существуют N префиксов y_1,...y_N\
    \ и N суффиксов w_1,...w_N и  для любых i, j(y_i w_i принадлежит языку L и из\
    \ j > 0 следует y_(i-j) w_i не принадлежит языку L), тогда  размер минимального\
    \ НКА не меньше, чем N. То есть существует таблица, где строки и стоблцы обозначают\
    \ выбранные N суффиков и префиксов, значения которой обозначают принадлежность\
    \ полученного из суффикса и префикса слова к языку. Мы выбираем суффксы и префиксы\
    \ так, чтобы на главной диагонали были единицы, а нижняя треугольная или верхняя\
    \ треугольная часть таблицы состояла из нулей. Таблица по Глайстеру-Шаллиту дает\
    \ оценку снизу на количество состояний НКА, а таблица по Майхиллу-Нероде - оценку\
    \ сверху, так как определяет точное число состояний в минимальном ДКА. Однако\
    \ оценка относительно классов эквивалентности по теореме Глайстера-Шаллита не\
    \ всегда точная, то есть может быть ниже чем в действительности, поэтому возможно\
    \ потребуются дополнительные исследования.  \n"
  author: Егорова Алиса
  id: 190
  questions:
  - 'Как определить размер минимального недетерминированного конечного автомата?

    '
- answer: "Пример построения атрибутной грамматки для языка {a^n b^n c^n}. == - означает\
    \ предикат, то есть проверку условия равенства. := - операцию присваивания. ;\
    \ - разделение правил грамматики и атрибутов нетерминалов S -> AT ; T.iter ==\
    \ A.iter A -> aA ; A_0.iter := A_1.iter + 1 A -> epsilon ; A.iter := 0 T -> bTc\
    \ ; T_0.iter := T_1.iter + 1; T -> epsilon ; T.iter := 0 Здесь второе и четвертое\
    \ условия производят подсчет символов a, b, c. Третье и пятое правило задают стартовое\
    \ значение для отсчета равное нулю. Первое условие осуществляет проверку равенства\
    \ количества символов a, b, c. \n"
  author: Егорова Алиса
  id: 191
  questions:
  - 'Приведи пример атрибутной грамматики

    '
- answer: "Если L - контекстно-свободный язык (КС-язык), то его коммутативный образ\
    \ является регулярным языком.  Пример: рассмотрим язык Дика, он является контекстно-свободным,\
    \ Σ = {\"[\", \"]\"}, отобразим \"[\" в b, \"]\" в a, тогда  коммутативный образ\
    \ языка будет задаваться регулярным выражением (ab)^*, что согласуется с контекстной-свободой\
    \ языка Дика. Пример: рассмотрим язык {a^nba^(n!)| n >= 0}, построим его коммутативный\
    \ образ, он будет определяться  так: {a^(n + n!)b | n >= 0}, полученный коммутативный\
    \ образ не является регулярным языком, а значит исходный язык {a^nba^(n!)| n >=\
    \ 0} не является контекстно-свободным. \n"
  author: Утебаева Милена
  id: 192
  questions:
  - 'Теорема Париха Теорема об образе контекстно-свободного языка (КС-языка)

    '
  - 'Проверка языка на контекстную свободу (КС-свойство)

    '
  - 'Методы анализа языка на контекстную свободу (КС-свойство) без использования леммы
    о накачке

    '
- answer: 'Пусть Σ = {a_1, ..., a_n}, тогда коммутативный образ строки w ∈ Σ^* - это
    вектор u, который состоит из количества входящих  в слово w букв из алфавита Σ:
    u = (|w|_{a_1}, |w|_{a_2}, ..., |w|_{a_n}). Коммутативный образ языка L - это
    множество,  состоящее из коммутативных образов всех слов принадлежащих этому языку
    L. Смысл коммутативного образа заключается в том, что операция конкатенации превращается
    в коммутативную. Пример коммутативного образа слова: Σ = {"a", "b", "o"}, w =
    "aboba", тогда коммутативный образ слова w - это вектор u = (2, 2, 1).

    '
  author: Утебаева Милена
  id: 193
  questions:
  - 'Коммутативный образ языка

    '
  - 'Коммутативный образ слова

    '
  - 'Пример коммутативного образа слова

    '
- answer: 'Если образ языка регулярен, то это не означает, что исходный язык является
    контекстно-свободным (КС) языком. Пример: {a^nb^nc^n | n >= 0} не является контекстно-свободным,
    однако его коммутативный образ (abc)^* является регулярным.

    '
  author: Утебаева Милена
  id: 194
  questions:
  - 'Пример не контекстно-свободного языка (КС-языка) с регулярным коммутативным образом.

    '
  - 'Если образ языка регулярен, значит ли это, что исходный язык контекстно-свободный
    (КС)?

    '
- answer: 'Метод подмены: рассмотрим два слова w_1vw_2, w_1vw_3 ∈ L, при этом |v|
    = k - длина слова v (данный фрагмент называется lookahead), префиксы w_1 образуют
    бесконечное (как минимум 2^(k + s)) число классов эквивалентности.  Тогда если
    язык L - это LL(k) язык, то можно считать, что w_1 порождает сентенциальную форму
    хотя бы длины k + s,  и последние s символов в ней раскрываются внутри как w_2,
    так и w_3 (то есть не затрагивается v), тогда их языки взаимозаменяемы.  Отрицание
    данного утверждения доказывает, что язык L не является LL(k). Пример: проверить,
    задаётся ли язык {a^nb^n} ∪ {a^nc^n} LL(k) грамматикой при некотором k. Решение:
    пусть такое k существует, рассмотрим слово a^(n + k)b^(n + k), где число n такое,
    что после чтения a^n символов в стеке будет находиться как минимум k + 2 символа,
    последний символ в стеке распознаёт некоторое подслово b^m суффикса b^(n + k),  так
    как осталось k символов "a" и количество символов в стеке больше k. Подменим исходную
    строку a^(n + k)b^(n + k) на  a^(n + k)c^(n + k), тогда последний символ в стеке
    должен распознать некоторое подслово c^t, а это означает,  что a^(n + k)b^(n +
    k - m)c^t ∈ L, что является неверным в силу определения языка L.

    '
  author: Утебаева Милена
  id: 195
  questions:
  - 'Метод подмены

    '
  - 'Как доказать, что язык не LL(k)?

    '
  - 'Проверка языка на LL(k) свойство

    '
- answer: 'Язык L называется ограниченным, если он является подмножеством некоторого
    языка, задающегося регулярным выражением: w_1^*...w_n^*,  для некоторого конечного
    множества {w_1, ..., w_n}. Примером неограниченного языка является язык палиндромов,
    однако после  пересечения языка палиндромов с языком, задающимся выражением a^*b^*a^*,
    получается ограниченный язык. Период вектора (k_1x_1 + m_1, ..., k_nx_n + m_n)
    - это кортеж (k_1, ..., k_n). Вектор называется стратифицированным, если для него
    выполнено два свойства:  1) Каждый элемент объединения, которым задаётся вектор,
    имеет меньше либо равно 2-ух ненулевых компонент.  Причём только одна ненулевая
    компонента говорит о регулярности элемента. 2) Для некоторых индексов i < j <
    k < l не существует векторов v_1, v_2 таких, что v_1[i] != 0 и v_2[j] != 0  и
    v_1[k] != 0 и v_2[l] != 0. То есть не существует перекрёстных зависимостей.  Критерий
    контекстной свободы языка L: пусть L - ограниченный язык, его слова имеют вид
    w_1^k_1...w_n^k_n, которые соотносятся с векторами (k_1, ..., k_n) из пространства
    V, тогда L - КС-язык <=> множество векторов пространства V является объединением  линейных
    векторов со стратифицированными периодами.  Пример со стратифицированными векторами:
    a^(n_1 + n_2)b^(n_2 + n_3)c^(n_1 + n_3), тогда компоненты имеют вид: (n_1, 0,
    n_1), (n_2, n_2, 0), (0, n_3, n_3) <=> (1, 0, 1), (1, 1, 0), (0, 1, 1) - удовлетворяют
    двум условиям выше. Язык, заданный  a^(n_1 + n_2)b^(n_2 + n_3)c^(n_1 + n_3) является
    контекстно-свободным. Пример с нестратифицированным вектором: a^nb^nc^(n + m),
    тогда компоненты имеют вид: (n, n, n), (0, 0, m) <=> (1, 1, 1), (0, 0, 1).  Вектор
    (1, 1, 1) не является стратифицированным, так как разделяется между тремя компонентами.  Язык,
    заданный a^nb^nc^(n + m) не является контекстно-свободным. Пример с нестратифицированным
    вектором: a^nb^ma^nb^m, компоненты имеют вид (n, 0, n, 0), (0, m, 0, m) <=> (1,
    0, 1, 0), (0, 1, 0, 1). Первое условие стратифицированности выполнено, однако
    есть перекрёстная зависимость,  а именно: зависимость между 1-ой и 3-ей позицией
    первого вектора и 2-ой и 4-ой позицией второго вектора. Язык заданный  a^nb^ma^nb^m
    не является контекстно-свободным.

    '
  author: Утебаева Милена
  id: 196
  questions:
  - 'Определение ограниченного языка

    '
  - 'Определение периода вектора

    '
  - 'Стратифицированность вектора

    '
  - 'Критерий контекстной свободы языка, связанный с векторами

    '
  - 'Методы анализа языка на контекстную свободу (КС-свойство) без использования леммы
    о накачке

    '
- answer: 'Приписывание эндмаркера преобразовывает любой детерминированный контекстно-свободный
    язык в язык,  распознаваемый DPDA по пустому стеку, то есть в беспрефиксный.  Также
    приписывание эндмаркера к детерминированному контекстно-свободному языку превращает
    его  в LR(0) язык.

    '
  author: Утебаева Милена
  id: 197
  questions:
  - 'Приписывание эндмаркера к детерминированному контекстно-свободному языку (КС-языку)

    '
  - 'Как эндмаркер влияет на свойство детерминированного контекстно-свободного языка
    (КС-языка)?

    '
- answer: "Линейный клеточный автомат (автомат Треллиса) - это пятёрка <Σ, Q, F, δ,\
    \ I>, где Σ - алфавит, Q - конечное множество состояний,  F ⊆ Q - множество принимающих\
    \ состояний, δ: Q × Q -> Q - функция перехода, она задаёт значение клетки на следующем\
    \ уровне через текущее состояние клетки и состояние клетки справа от текущей,\
    \ I: Σ -> Q - функция, устанавливающая начальное состояние  в каждой клетке. \
    \ При рассмотрении линейных клеточных автоматов важно то, что они распознают все\
    \ языки, которые задаются линейными грамматиками, однако линейные клеточные автоматы\
    \ не равносильны линейным грамматикам, поскольку класс языков, распознаваемых\
    \ линейными клеточными автоматами, замкнут относительно дополнения, а линейные\
    \ грамматики не замкнуты относительно взятия дополнения.  Утверждение: язык задаётся\
    \ линейной конъюнктивной грамматикой <=> язык задаётся линейным клеточным автоматом.\
    \ Пример: язык Дика с единственным типом скобок распознаётся линейным клеточным\
    \ автоматом, Σ = {\"(\", \")\"}, Q = {↗, ↖, □, −}, F = {□},  I(\"(\") = ↗ и I(\"\
    )\") = ↖, значения функции перехода δ заданы в таблице:\n  ↗ ↖ □ −\n↗ ↗ □ ↗ -\
    \  ↖ - ↖ - -  □ □ ↖ □ □ - - ↖ - -\n"
  author: Утебаева Милена
  id: 198
  questions:
  - 'Определение линейного клеточного автомата

    '
  - 'Когда язык задаётся линейной конъюнктивной грамматикой?

    '
- answer: 'Пусть L - язык в алфавите Σ, h: Σ -> Σ'' (где Σ'' может совпадать с Σ)
    - морфизм. Прообразом L относительно h  (обратным морфизмом, h^(-1)) называется
    максимальный язык L'' = {w | h(w) ∈ L}.  Пример: положим L = {"aab", "bbab"},
    h("a") = "a", h("b") = "ab", h("c") = "aab", h("d") = "aa".  Тогда для "aab" прообразами
    будут: "ab", "c". Для "bbab" прообраза не будет. Получаем, что h^(-1)(L) = {"ab",
    "c"}. Утверждение: пусть h - морфизм.  1) Если язык L регулярный, то обратный
    морфизм h^(-1)(L) - регулярный; 2) Если язык L контекстно-свободный, то обратный
    морфизм h^(-1)(L) также является контекстно-свободным. Таким образом, можно сформулировать
    критерий контекстной свободы (КС-свойства) языка: если гомоморфный образ языка
    не  является контекстно-свободным, то исходный язык не является контекстно-свободным.

    '
  author: Утебаева Милена
  id: 199
  questions:
  - 'Обратный морфизм

    '
  - 'Пример обратного морфизма

    '
  - 'Критерий контекстной свободы языка

    '
  - 'Методы анализа языка на контекстную свободу (КС-свойство) без использования леммы
    о накачке

    '
- answer: 'Атрибутная грамматика - это контекстно-свободная грамматика, к правилам
    которой добавлены условия на атрибуты.  Атрибуты - это переменные, ассоциированные
    с символами грамматики.  Типы наследования атрибутов:  1) Наследование от потомка
    к предку. Грамматика с таким типом наследования называется S-атрибутной грамматикой.
    S-атрибутная грамматика - контекстно-свободная грамматика, в которой к правилам
    A_0 -> t_1t_2...t_n добавлены условия вида A_0.attr = f(t_1.attrv, t_2.attrv,
    ..., t_n.attrv), где t_i.attrv - это вектор из атрибутов, соответствующих нетерминалу
    t_i. 2) Наследование от потомка и нетерминалов слева. Грамматика с таким типом
    наследования называется L-атрибутной грамматикой.  L-атрибутная грамматика - контекстно-свободная
    грамматика, в которой к правилам A_0 -> t_1t_2...t_n добавлены условия вида t_j.attr_i
    = f(A_0.attrv, t_1.attrv, ..., t_{j - 1}.attrv), где t_k.attrv - это вектор из
    атрибутов, соответствующих нетерминалу t_k, f - некоторая функция, от атрибутов
    нетерминалов, стоящих слева от текущего. Смысл атрибутов заключается в том, что
    с их помощью можно удобно выражать проверяемые или отслеживаемые свойства грамматики.  Пример:
    регулярные выражения, язык которых содержит ε. S -> a; S.ε = False S_0 -> (S_1S_2);
    S_0.ε = S_1.ε and S_2.ε S_0 -> (S_1 | S_2); S_0.ε = S_1.ε or S_2.ε S_0 -> (S_1^*);
    S_0.ε = True

    '
  author: Утебаева Милена
  id: 200
  questions:
  - 'Атрибутная грамматика

    '
  - 'Типы атрибутных грамматик

    '
- answer: 'Контекстно-свободный язык (КС язык) называется детерминированным, если
    он принимается некоторым DPDA  (deterministic pushdown automaton).  Пример детерминированного
    контекстно-свободного языка (DCFL): {a^nb^n | n >= 0}. Контекстно-свободный язык
    (КС язык) называется однозначным, если он порождается некоторой однозначной КС-грамматикой,
    то есть  КС-грамматикой, в которой каждая цепочка порождаемого ею языка имеет
    единственное дерево вывода.  Пример однозначной грамматики: S => ε | (S)S. Пример
    однозначного, но недетерминированного языка: язык палиндромов. В общем случае
    проблема однозначности контекстно-свободных грамматик неразрешима, однако для
    класса детерминированных КС-языков она является разрешимой.

    '
  author: Утебаева Милена
  id: 201
  questions:
  - 'Чем детерминированность контекстно-свободного языка (КС языка) отличается от
    однозначности контекстно-свободного языка (КС языка)?

    '
  - 'Как связаны понятия «детерминированность» и «однозначность» для контекстно-свободных
    языков (КС языков)?

    '
  - 'Детерминированность и однозначность это одно и то же для контекстно-свободного
    языка (КС языка)?

    '
- answer: 'Полный детерминированный конечный автомат с множеством состояний Q над
    алфавитом Σ называется синхронизируемым, если существуют слово w ∈ Σ^* и состояние
    s ∈ Q такие, что q.w = s для всех q ∈ Q.  В этом случае слово w называют синхронизирующим
    и говорят, что оно синхронизирует ДКА A к состоянию s.

    '
  author: Дмитрий Теньшов
  id: 202
  questions:
  - 'Что такое синхронизируемый детерминированный конечный автомат?

    '
- answer: 'Класс синхронизируемых детерминированных конечных автоматов (ДКА) замкнут
    относительно взятия подавтоматов и фактор-автоматов; при этом каждое слово,  синхронизирующее
    данный ДКА, будет синхронизировать все его подавтоматы и фактор-автоматы.

    '
  author: Дмитрий Теньшов
  id: 203
  questions:
  - 'Верно ли, что класс синхронизируемых детерминированных конечных автоматов замкнут
    относительно взятия подавтоматов и фактор-автоматов?

    '
- answer: 'Подмножество S''⊆ S называется устойчивым в автомате A, если любой x ∈
    X переводит любое состояние s ∈ S'' в состояние, которое также принадлежит S''.
    То есть δ(s, x) ∈ S'' для любых s ∈ S'' и x ∈ X. Если S'' устойчиво в A, то,  ограничивая
    функцию переходов δ на S''×X, получают автомат A'' = (S'', X, δ) — подавтомат
    автомата A, соответствующий S''.

    '
  author: Дмитрий Теньшов
  id: 204
  questions:
  - 'Что такое подавтомат конечного (бесконечного) автомата?

    '
- answer: 'Отношение эквивалентности θ ⊆ S×S называется конгруэнцией автомата A =
    (S, X, δ), если оно согласовано с функцией переходов в том смысле,  что (∀s, t
    ∈ S)(∀x ∈ X)((s, t) ∈ θ ⇒ (δ(s, x), δ(t, x)) ∈ θ). Это означает, что если два
    состояния s и t являются эквивалентными по отношению θ, то при любом входном x
    из X автомат, находясь в состоянии s или в состоянии t, перейдёт в состояния,
    которые также будут эквивалентны по θ. Любой автомат имеет две тривиальных конгруэнции
    - нулевая конгруэнция (каждое состояние образует своё собственное класс эквивалентности)
    и единичная конгруэнция (один единственный класс эквивалентности, который содержит
    все состояния). Каждая конгруэнция θ автомата A определяет его фактор-автомат
    A/θ = (S/θ, X, δ),  где δ(θ(s), x) := θ(δ(s, x)) для любых s ∈ S, x ∈ X.

    '
  author: Дмитрий Теньшов
  id: 205
  questions:
  - 'Что такое фактор-автомат конечного (бесконечного) автомата?

    '
- answer: "Детерминированный конечный автомат (ДКА) A с множеством состояний Q над\
    \ алфавитом Σ называется ориентируемым, если состояния из Q можно расположить\
    \ в циклическом порядке q_0, q_1, . . ., q_(n−1),  где n = |Q|,так, чтобы действие\
    \ букв из Σ сохраняло этот циклический порядок. Чтобы строго определить последнее\
    \ условие, скажем,  что последовательность p_0 , p_1 , . . . , p_(m−1) (не обязательно\
    \ различных) состояний из Q правильно ориентирована, если оставив в ней ровно\
    \ одно состояние из каждого блока p_i = p_(i+1) (mod m) = · · · = p_(i+k) (mod\
    \ m) одинаковых соседних состояний, получим подпоследовательность некоторой\
    \ циклической перестановки  последовательности q_0, q_1, . . .,q_(n−1). Буква\
    \ a ∈ Σ сохраняет циклический порядок, если последовательность образов q_0.a,\
    \ q1.a, . . . , q_(n−1).a правильно ориентирована. Пример ориентируемого ДКА.\
    \ Пусть Q = {q_1, q_2, q_3}, Σ = {a, b}, переходы: q_1.a = q_2, q_2.a = q_3, q_3.a\
    \ = q_1, q_1.b = q_3, q_3.b = q_2, q_2.b, q_1.  Переходы по a сохраняют порядок\
    \ (q_1 → q_2 → q_3), переходы по b — его циклический сдвиг (q_1 → q_3 → q_2).\
    \ \n"
  author: Дмитрий Теньшов
  id: 206
  questions:
  - 'Что такое ориентируемый детерминированный конечный автомат?

    '
- answer: "Задача перечисления синхронизирующих слов детерминированного конечного\
    \ автомата (ДКА) A длины k является  #P-полной (#P - вычисление количества решений).\
    \  Данную задачу можно рассматривать как сведение задачи выполнимости булевых\
    \ формул к задаче перечисления синхронизирующих слов ДКА длины k.  Поскольку задача\
    \ выполнимости булевых формул #P-полна, получаем, что задача перечисления синхронизирующих\
    \ слов ДКА длины k #P-трудна. С другой стороны,  задача перечисления синхронизирующих\
    \ слов ДКА длины k лежит в классе #P. Получаем, что задача перечисления синхронизирующих\
    \ слов ДКА длины k #P-полна. \n"
  author: Дмитрий Теньшов
  id: 207
  questions:
  - 'Правда ли, что задача перечисления синхронизирующих слов детерминированного конечного
    автомата A заданной длины #P-полна?

    '
- answer: 'Минимум длин синхронизирующих слов синхронизируемого детерминированного
    конечного автомата (ДКА) A с множеством состояний Q над алфавитом Σ называется
    его порогом синхронизации.  Порог синхронизации синхронизируемого n-автомата с
    нулём не превышает n(n−1)/2, и эта оценка точна.

    '
  author: Дмитрий Теньшов
  id: 208
  questions:
  - 'Чему равна оценка порога синхронизации синхронизируемого детерминированного конечного
    n-автомата с нулём?

    '
- answer: 'Пусть дан ДКА с множеством состояний Q над алфавитом Σ. Скажем, что слово
    w ∈ Σ^* избегает состояние q ∈ Q, если q ∉ Q.w. Состояние, для которого существует
    избегающее слово, называется избегаемым.  Неизбегаемым в синхронизируемом ДКА
    может быть только такое состояние z, что z.a = z для каждой буквы a ∈ Σ. Будем
    называть такие состояния нулевыми, а ДКА,  в котором есть нулевое состояние –
    автоматом с нулём. Существует два типа нулевых состояний: нулевое состояние, у
    которого все переходы ведут в себя; нулевое состояние, которое не имеет переходов.

    '
  author: Дмитрий Теньшов
  id: 209
  questions:
  - 'Что такое детерминированный конечный автомат с нулём?

    '
- answer: 'Подстановка на конечном алфавите X – это отображение σ : X → X^+. σ : X
    → X^+ – подстановка постоянной длины, если длины слов xσ одинаковы для всех x
    ∈ X.  Говорят, что подстановка постоянной длины σ : X → X^+ удовлетворяет условию
    совпадения (coincidence condition), если существуют такие натуральные m и k,  что
    в m-й позиции слов xσ^k для всех x ∈ X стоит одна и та же буква.

    '
  author: Дмитрий Теньшов
  id: 210
  questions:
  - 'Когда говорят, что подстановка постоянной длины удовлетворяет условию совпадения?

    '
- answer: 'Порог избегаемости - это максимум длин кратчайших слов, избегающих состояния
    сильно связного синхронизируемого детерминированного конечного автомата (ДКА).  Порог
    избегаемости ДКА всегда меньше или равен порогу синхронизации, увеличенному на
    единицу.

    '
  author: Дмитрий Теньшов
  id: 211
  questions:
  - 'Что такое порог избегаемости в контексте синхронизируемых детерминируемых конечных
    автоматов?

    '
- answer: 'Порог избегаемости любого сильно связного синхронизируемого автомата с
    n состояниями не превышает 2n − 2.

    '
  author: Дмитрий Теньшов
  id: 212
  questions:
  - 'Чему равен порог избегаемости любого сильно связного синхронизируемого автомата?

    '
- answer: 'Пусть A = ⟨Q, Σ⟩ -  детерминированный конечный автомат (ДКА). Пара (p,
    q) различных состояний является взаимной блокировкой, если ∀w ∈ Σ^* p.w ≠ q.w,  то
    есть ни одно слово не переводит ДКА из состояний p и q в одно и то же состояние.
    Если ДКА A не является синхронизируемым,  то он должен иметь взаимные блокировки.

    '
  author: Дмитрий Теньшов
  id: 213
  questions:
  - 'Верно ли, что если детерминированный конечный автомат не синхронизируемый, то
    он точно имеет взаимные блокировки?

    '
- answer: 'Детерминированный конечный автомат (ДКА) называется автоматом с простыми
    идемпотентами, если каждая его буква либо действует как перестановка множества
    состояний, либо фиксирует все состояния (то есть если буква фиксирует состояние
    q, то при чтении этой буквы ДКА, находясь в состоянии q, остаётся в том же состоянии,
    а в остальных состояниях переходит в другое),  кроме одного.

    '
  author: Дмитрий Теньшов
  id: 214
  questions:
  - 'Что такое детерминированный конечный автомат с простыми идемпотентами?

    '
- answer: 'Установим взаимно однозначное соответствие между детерминированным конечным
    автоматов (ДКА) и подстановками постоянной длины. ДКА A с множеством состояний
    Q и множеством переходов δ с алфавитом Σ = {a_1, . . . , a_k} определяет подстановку
    постоянной длины k на множестве Q по следующему правилу: q ∈ Q отображается в
    слово (q.a_1)· · ·(q.a_k) ∈ Q^+.  Обратно, каждая подстановка σ : X → X^+ такая,
    что |xσ| = k для всех x ∈ X, определяет ДКА с множеством состояний X и k входными
    буквами a_1, . . . , a_k,  действующими на X по правилу: x.a_i – это символ в
    i-й позиции слова xσ. Несложно видеть, что при указанном взаимно однозначном соответствии
    подстановки,  удовлетворяющие условию совпадения, в точности соответствуют синхронизируемым
    автоматам. При этом номер итерации, на которой впервые появляется совпадение,  равен
    минимальной длине синхронизирующего слова для соответствующего ДКА.

    '
  author: Дмитрий Теньшов
  id: 215
  questions:
  - 'Можно ли сказать, что при определённом взаимно однозначным соответствии подстановки,
    удовлетворяющие условию совпадения, в точности соответствуют синхронизируемым
    автоматам?

    '
- answer: 'Любой контекстно-свободный язык нельзя представить с помощью регулярного
    выражения, если говорить только о  академичесих регулярных выражениях (то есть
    регулярные выражения, которые содержат только операции альтернативы, конкатенации,
    замыкания Клини). Но, если расширить регулярные выражения с помощью обратных  ссылок
    (механизм повторного использования группы захвата или слов группы захвата), то
    получим, что  с помощью механизма обратных ссылок можно представить любой контекстно
    свободный язык. Группа захвата -  часть регулярного выражения, обозначение - заключение
    в скобки. Обратные ссылки (англ. backreference) позволяют  повторно использовать
    части регулярных выражений. Для повторного использования слова группы используется  обозначение
    ∖n, где n — номер группы. Для повторного использования регулярного выражения группы
    используется  обозначение (?n), где n — номер группы. Пример: контекстно-свободный
    язык L = a^nb^n, где n положительное число -  может быть представлен при помощи
    обратных ссылок, как и любой другой контекстно-свободный язык. L = (a(?1)?b) -  запись
    языка L = a^nb^n с помощью механизма обратных ссылок. Следущий за ссылкой (?1)
    знак вопроса обозначает  использование группы 0 или 1 раз, то есть осуществление
    рекурсивного вызова или его окончание. (?1) ссылается на первую группу захвата
    — (a(?1)?b), что равносильно рекурсивной зависимости. На место (?1) будет  каждый
    раз подставляться первая группа захвата: (a(a(?1)?b)?b). Регулярные выражения
    с обратными ссылками имеют большую мощность по сравнению с академическими регулярными
    выражениями, поскольку с их помощью можно описать не только любой регулярный язык,
    но и любой контекстно-свободный язык, а также ряд языков, которые не являются
    контекстно-свободными.

    '
  author: Лисов Алексей
  id: 216
  questions:
  - 'Можно ли распознать любой контекстно-свободный язык с помощью регулярного выражения?

    '
- answer: ' Класс регулярных древесных языков замкнут относительно: 1) объединения
    2) пересечения 3) дополнения 4) f(L_1, ..., L_rank f) — множество всех деревьев,
    полученных присоединением к корню f по одному дереву из L_1, ..., L_rank f. rank
    - натуральное число, показывающее арность этого символа. Арность - количество
    аргументов / операндов функции. В даном случае показывает количество детей узла
    в дереве. 5) конкатенации K·a L. Конкатенация древесных языков K·a L, где rank
    a = 0, — это множество всех деревьев, полученных из какого-то дерева из древесного
    языка K заменой всех листьев a на поддеревья из L. 6) итерации Клини L^{*a}.

    L^{*a}= объединение L^{k,a} от k = 0 до бесконечности. Где L^{k,a} (rank a = 0)
    - множество деревьев, определяемое индукцией по k. Язык L^{0,a} состоит из одного
    дерева — листа a. Язык L{k+1,a} = L{k,a}·a L ∪ L^{k,a}.

    7) морфизмов

    '
  author: Лисов Алексей
  id: 217
  questions:
  - 'Относительно каких операций замкнуты регулярные древесные языки?

    '
- answer: ' Язык подмножества свободного моноида является контекстно-свободным тогда
    и только тогда, когда он является кроной какого-то регулярного древесного языка.
    Крона регулярного древесного языка - множество всех его листьев упорядоченное
    в соответствии с порядком их достижения при обходе с помощью поиска в глубину
    (deep first search). По сути это то же самое, что и сказать, что крона регулярного
    древесного языка - множество всех его листьев при обходе их слева направо.

    Деревья разбора контестно-свободных языков порождаются древесным автоматом, который
    строится по контекстно-свободной грамматике.

    '
  author: Лисов Алексей
  id: 218
  questions:
  - 'Как связаны контекстно-свободные языки и регулярные древесные языки?

    '
  - 'Как связаны кс-языки и регулярные древесные языки?

    '
  - 'Как связаны деревья разбора кс языков и регулярные древесные языки?

    '
  - 'Как связаны деревья разбора контекстно-свободных языков и регулярные древесные
    языки?

    '
- answer: 'Детерминированные нисходящие (Top-Bottom) древесные автоматы не обладают
    многими важными свойствами замыкания. Например, они не являются замкнутыми ни
    относительно операции объединения, ни относительно дополнения. '
  author: Лисов Алексей
  id: 219
  questions:
  - 'Замкнуты ли детерминированные нисходящие (Top-Bottom) древесные автоматы относительно
    объединения?

    '
  - 'Замкнуты ли детерминированные нисходящие (Top-Bottom) древесные автоматы относительно
    дополнения?

    '
- answer: ' В случае конечных автоматов и древесных конечных автоматов фактор-автомат
    по отношению эквивалентности по Нероде на самом деле является минимальным автоматом.

    '
  author: Пирко Владимир
  id: 220
  questions:
  - 'Чем на самом деле является фактор-автомат по отношению эквивалентности по Нероуду
    в случае конечных автоматов или древесных конечных автоматов?

    '
- answer: 'Древесные языки бывают четырех типов: детерминированные восходящие (Bottom-Up)
    древесные автоматы, недетерминированные восходящие (Bottom-Up) древесные автоматы,
    детерминированные нисходящие (Top-Bottom) древесные автоматы, недетерминированные
    нисходящие (Top-Bottom) древесные автоматы


    Недетерминированные древесные автоматы любого типа эквивалентны по выразительной
    силе детерминированным восходящим древесным автоматам.

    Детерминированные нисходящие древесные автоматы являются менее выразительными
    (с точки зрения возможности  описать ими древесный язык), чем остальные 3 записанных
    типа. Покажем на примере. Предположим, что мы пытаемся  построить детерминированный
    нисходящий древесный автомат, который распознает слова с нечетным количеством
    букв a. Предположим, что у нас есть такой автомат и для простоты будем рассматривать
    автоматы, которые являются бинарными деревьями. Тогда возьмем древесное слово,
    которое он будет распознавать и предположим, что в корне находится буква a. Тогда,
    чтобы слово было принято автоматом - нам необходимо, чтобы у левого и правого
    поддеревьев совпадала четность количества букв a (потому что одна a уже в корне,
    а любое нечетное число это 2*k + 1 для любого k). И нам необходимо как-то передавать
    эту информацию для корректного определения распознавания. В детерминированный
    нисходящем древесном автомате мы можем передавать информацию от корня ниже, поэтому
    мы могли бы,  например передать ниже информацию о том, что хотим иметь четное
    количество букв a в этом поддереве, но нам также подходит и вариант с нечетным
    количеством букв a. Более того, мы хотим поддерживать инвариант, что четность
    букв a в левом и правом поддереве одинаковая, а это значит, что мы должны уметь
    как-то передавать информацию из одного поддерева в другое. Но мы не обладаем возможностью
    передавать информацию между ними в детерминированных нисходящих древесных автоматах,
    а для того, чтобы древесное слово распознавалось детерминированным нисходящим
    древесным автоматом необходимо, чтобы все листья находились в множестве финальных
    состояний. Поэтому мы не можем построить детерминированный нисходящий древесный
    автомат, распознающий слова с нечетным количеством букв a.

    Напротив, в восходящем древесном автомате мы постоянно сливаем информацию о вершинах,
    пока поднимаемся от листов к корню. Поэтому в конечном итоге мы получаем ее в
    корне, так как при поднятии в корень мы сливаем информацию о его поддеревьях,
    то же самое можно сказать и о слоях ниже.

    Таким образом было показано, что детерминированный нисходящий автомат "слабее",
    чем остальные три типа, так как в нем нет возможности передачи информации между
    поддеревьями, что может быть важно при описании древесных языков.

    '
  author: Лисов Алексей
  id: 221
  questions:
  - 'Типы древесных автоматов. Какие из них эквивалентны?

    '
  - 'Какие типы древесных автоматов эквивалентны?

    '
- answer: ' Детерминированные контекстно-свободные языки замкнуты относительно: 1)
    Операции дополнения Это достаточно  легко показать, пусть у нас есть детерминированный
    контекстно-свободный язык L. Представим его в виде PDA  (pushdown automata), тогда
    для получения PDA для дополнения к L - просто сделаем финальные состояния исходного
    PDA  не финальными и наоборот.

    2) Пересечения с регулярным языком.

    3) Объединения с регулярными языками

    4) Обратных морфизмов

    Детерминированные контекстно-свободные языки НЕ замкнуты относительно:

    1) Пересечения, как и контекстно-свободные языки в общем случае.

    2) Объединения

    3) Морфизмов. Пример: Детерминированный язык S -> aSa | bSb | c, после применения
    морфизма h, который переводит символ "c" в "ε", а все остальное оставляет на месте
    - получим S -> aSa | bSb | epsilon, который детерминированным являться не будет.

    4) Обращения (реверсирования) Пример: язык (w^R c w .*) - детерминированный, в
    то время как .* w c w^R - недетерминированный. w в алфавите {a, b}

    '
  author: Лисов Алексей
  id: 222
  questions:
  - 'Замкнутость детерминированных контекстно-свободных языков (DCFL) относительно
    разных операций

    '
- answer: 'Лемма об обмене говорит о том, что для каждого контекстно-свободного языка
    L существует c большее 0, такое что для любых n >= m >= 2 для любого набора R
    слов языка L длины n существует Z = {z_1, ..., z_k}, входящее в R,  k >= |R|/(c*n^2)
    и разбиения z_i = w_i x_i y_i, такие что длины w_i x_i y_i не зависят от i, а
    также m/2 < |x_i| <= m и для любых i и j слово, полученное конкатенацией w_i,
    x_j, y_i принадлежит исходному языку L.

    Как и лемма о накачке, выполнение леммы об обмене является лишь необходимым условием
    для контекстно-свободности языка, то есть, если условие теоремы выполнено для
    какого-то языка L, то этого недостаточно для того, чтобы сказать, что язык L контекстно-свободен.

    Одно из применений леммы об обмене - показать, что язык повторяющихся строк (то
    есть строк вида xyyz с |y| > 0) над алфавитом из трех или более букв не является
    контекстно-свободным.

    '
  author: Лисов Алексей
  id: 223
  questions:
  - 'Лемма об обмене (Interchange lemma)

    '
- answer: 'Пусть L — язык над алфавитом Σ, задаваемый контекстно-свободной грамматикой.  Пусть
    D — подмножество алфавита Σ, которое содержит хотя бы два символа. Тогда для всякого
    подмножества языка L, которое составлено из всех слов вида xuyuz, где u принадлежит
    языку D^*, а x, y, z лежат в языке Σ^* - язык L  содержит строку вида xuyvz, где
    слова u и v лежат в языке D^* и u не  совпадает с v.

    '
  author: Лисов Алексей
  id: 224
  questions:
  - 'Лемма Соколовского

    '
- answer: "Для всякого LR-языка (детерминированного КС-языка) L из Σ^* существует\
    \ бесконечное множество M из Σ^*, для которого для всякой строки w ∈ Σ^* или\
    \ все строки из Mw лежат в L, или ни одна из них не лежит.\nMw — это множество\
    \ всех строк, которые эквивалентны строке w в рамках отношения эквивалентности\
    \  Майхилла–Нероуда, то есть строки, которые не могут быть различены автоматом,\
    \ который распознает язык L. Это  множество строк, которые имеют одинаковое поведение\
    \ с w относительно языка L.\nИными словами, существует бесконечный класс эквивалентности\
    \ Майхилла–Нероуда. \n"
  author: Лисов Алексей
  id: 225
  questions:
  - 'Лемма Шаллита. Применение леммы Шаллита для детерминированных КС-языков

    '
- answer: 'LR(0) контекстно-свободные языки - языки, для которых возможно построить позиционный автомат не содержащий конфликтов. 
    LR(0) КС языки в точности детерминированные языки обладающие безпрефиксностью.
    '
  author: Кочетков Денис
  id: 216
  questions:
  - 'LR(0) контекстно-свободные грамматики
  
    '
- answer: 'LR(n) n>0 языки - детерминированный языки, для которых возможно построить позиционный автомат с предпросмотром на n символов вперед, не содержащий конфликтов.
    LR(n), n>0 разбором возможно разобрать любой детерминированный КС язык.
    '
  author: Кочетков Денис
  id: 217
  questions:
    - 'LR(n) контекстно-свободные грамматики
    '
    - 'LR(n) контекстно-свободные языки

    '
- answer: 'Да. Класс языков LL(k) требует просмотра на k символов вперед для определения путей разбора слова.
    Таким образом если язык принадлежит классу LL(k), то он также принадлежит и классу LL(n), n>k, т.к. 
    n символов точно хватит для выбора альтернативы разбора.
    '
  author: Кочетков Денис
  id: 218
  questions:
    - 'Если контекстно свободный язык - LL(k), является ли он LL(n), при n больше k?

    '

# https://doi.org/10.1051/ita:2004004
- answer: 'Линейные конъюнктивные грамматики и автоматы Треллиса задают один и тот же класс языков.
    То есть, для любой линейной конъюнктивной грамматики может быть построен автомат Треллиса, разбирающий все слова из языка.
    '
  author: Кочетков Денис
  id: 219
  questions:
    - 'Связь линейных конъюнктивных языков и автоматов Треллиса

    '
- answer: 'Линейные конъюнктивные языки замкнуты относительно операций пересечения, объединения, дополнения, разворота и обратных морфизмов.
    Линейные конъюнктивные языки не замкнуты относительно конкатенации, замыкания Клини и морфизмов.
    
    В свою очередь, Линейные контекстно-свободные языки замкнуты относительно операций объединения и пересечения с регулярными языками, объединения с линейными языками, морфизмов и обратных морфизмов, обращения.
    Линейные контекстно-свободные языки не замкнуты относительно пересечения, конкатенации, замыкания Клини и взятия дополнения. 
    '
  author: Кочетков Денис
  id: 220
  questions:
    - 'Относительно каких операций замкнуты линейные контекстно-свободные и линейные конъюнктивные языки?
    '
- answer: 'Линейные конъюнктивные языки - языки заданные линейной конъюнктивной грамматикой.
    Линейная грамматика - грамматика, в которой каждое правило переписывания содержит не более 1 нетерминала в правой части.
    Линейные конъюнктивные языки могут описать любой VPL язык, но не любой КС и конъюнктивный языки, так как необходимо выполнение свойств линейности.
    Линейные конъюнктивные грамматики эквивалентны по выразительной силе автоматам Треллиса.
    '
  author: Кочетков Денис
  id: 221
  questions:
    - 'Линейные конъюнктивные языки
    
    '

#https://gist.github.com/stewkk/6c3c08ad1fdffd7e81c9985339c736c8
#https://www.cis.upenn.edu/~alur/Stoc04.pdf
- answer: 'Языки VPL(Visibly Pushdown Language) замкнуты относительно операций -
    Пересечения, объединения, конкатенации(При условии, что разбиения алфавитов на внутренние, вызывающие и возвращающие символы одинаковые), замыкания Клини, взятия дополнения, морфизмов, обратных морфизмов, и разворота.
    '
  author: Кочетков Денис
  id: 222
  questions:
    - 'Относительно каких операций замкнуты VPL(Visibly Pushdown Language)?

    '

- answer: 'Методы доказательства детерминированности КС языка
    1. Если известно, что язык LL(K) или LR(k), то он детерминирован
    2. Анализ дополнения КС языка - Если дополнение КС языка детерминировано, то и сам язык детерминированный
    3. Построение Детерминированного PDA(Pushdown Automata, стековый автомат), разбирающего язык.
    
    Методы доказательства недетерминированности КС языка
    1. Использование отрицания леммы о накачке для детерминированных языков. Далее приведено ОТРИЦАНИЕ леммы.
        Для любой длинны накачки p, существуют два слова w и w1 такие что имеют одинаковый префикс и разные суффиксы начинающиеся с одной и той же буквы.
        То есть w = xy и w1 = xz, |x| > p
        Если выполнено одно из условий
        1. не существует накачки только префикса(в привычном смысле)
        2. не существует разбиения x = x_1 x_2 x_3, y = y_1 y_2 y_3, z = z_1 z_2 z_3, такое что
        Cуществует i, x_1 x_2^i x_3 y_1 y_2^i y_3 не принадлежит языку или x_1 x_2^i x_3 z_1 z_2^i z_3 не принадлежит языку
     
        Тогда язык не детерминированный.
    
    2. Анализ дополнения. Если дополнение языка является недетерминированным, то и сам язык тоже.
    
    Перечислены некоторые, но не все методы анализа на детерминированность контекстно свободного языка.
    '
  author: Кочетков Денис
  id: 223
  questions:
    - 'Методы определения является ли КС-язык детерминированным

    '

- answer: 'ПСП(Правильные скобочные последовательности) задают последовательности с набором сбалансированных открывающих и закрывающих скобок.
    Префиксы Правильных скобочных последовательности - такие последовательности, в которых число открывающих скобок не меньше числа закрывающих, причем, каждая закрывающая скобка должна сбалансировать какую-либо открывающую
    Пусть Алфавит символов {a, b}, где a - открывающая скобка, b - закрывающая
    Тогда язык префиксов правильных скобочных последовательностей задается грамматикой
    ```
    S -> TS | ε
    T -> aTb | aT | ε
    ```
    Грамматика порождает произвольный список правильных скобочных последовательностей, в которых есть дополнительные открывающие скобки
    '
  author: Кочетков Денис
  id: 224
  questions:
    - 'Грамматика префиксов ПСП'
    - 'Грамматика префиксов Правильных скобочных последовательностей'
    - 'Грамматика префиксов языков Дика
    '

- answer: 'Да, может. Можно привести два языка четных палиндромов в алфавитах {a,b} и {b,c}.
    Языки палиндромов состоящих хотя бы из двух символов являются недетерминированными.
    Их пересечение даст слова удовлетворяющие регулярному выражению (bb)*.
    '
  author: Кочетков Денис
  id: 225
  questions:
    - 'Может ли пересечение двух КС-языков быть регулярным языком, если ни один из КС-языков не детерминирован?

    '
- answer: 'Линейные КС языки - подкласс контекстно-свободных языков и линейных конъюнктивных языков, порождаемый линейными грамматиками.
    Линейная грамматика - грамматика, в которой каждое правило переписывания содержит не более 1 нетерминала в правой части.
    Пример линейного языка - язык четных палиндромов, задаваемых грамматикой
    S -> aSa | bSb | ε
    
    '
  author: Кочетков Денис
  id: 226
  questions:
    - 'Линейные контекстно-свободные языки

    '

# https://doi.org/10.1016/j.tcs.2004.03.002
- answer: 'Лемма о сжатии 
    Если язык задан линейной конъюнктивной грамматикой из с одним нетерминалом, то 
    существует константа k >= 0, и любое слово из языка w, |w| > k, то существует разбиение 
    w = xyz, 0< |xy| <= k, и y принадлежит языку.
    
    При выполнении свойства не следует, что язык может быть задан линейной конъюнктивной грамматикой из одного нетерминала, так как лемма не является критерием.
    '
  author: Кочетков Денис
  id: 227
  questions:
    - 'Существование линейной конъюнктивной грамматики из одного нетерминала'
    - 'Лемма о сжатии
    '