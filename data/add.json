{
    "question": "В хорошо написанном регулярном выражении должны быть сбалансированы какие факторы?",
    "answer": "В хорошо написанном регулярном выражении должны быть сбалансированы несколько факторов: • Регулярное выражение должно совпадать там, где нужно, и нигде больше • Регулярное выражение должно быть понятным и управляемым • При использовании механизма НКА (недетерминированный конечный автомат) выражение должно быть эффективным (т. е. быстро приводить к совпадению или несовпадению, в зависимости от результата поиска)"
},
{
    "question": "Какие возможности механизм НКА может поддерживать, недоступные для ДКА? (в конетексте регулярных выражений и языков)",
    "answer": "Механизм недетерминированного конечного автомата (НКА) обладает рядом возможностей, недоступных для детерминированного конечного автомата (ДКА), что делает его более гибким и мощным инструментом для работы с регулярными выражениями: 1. Сохранение текста, совпадающего с подвыражениями: НКА поддерживает сохранение текста, заключённого в круглые скобки в регулярном выражении. Это позволяет использовать обратные ссылки и получать информацию о том, где именно в целевом тексте были найдены совпадения. 2. Позиционные и сложные проверки с нулевой длиной совпадения: НКА может выполнять позиционные проверки (например, проверки начала или конца строки) и другие сложные проверки, не требующие дополнительных символов для совпадения. 3. Минимальные квантификаторы и упорядоченный выбор: В отличие от ДКА, который обеспечивает поиск минимального совпадения в целом, НКА поддерживает локальные минимальные квантификаторы и упорядоченный выбор, что позволяет регулировать последовательность проверок и минимизировать длину совпадений на более локальном уровне. 4. Захватывающие квантификаторы и атомарная группировка: НКА поддерживает захватывающие квантификаторы и атомарную группировку, что позволяет эффективно контролировать совпадения и избегать ненужных проверок. 5. Обработка многоопределённости: НКА способен работать с многоопределёнными языками, в которых могут существовать несколько вариантов ввода и вывода. В отличие от этого, ДКА ограничен обработкой немногоопределённых языков, где допустим только один вход и один выход. 6. Обработка рекурсивных выражений: НКА может работать с рекурсивными регулярными выражениями, которые включают вложенные выражения. ДКА не поддерживает рекурсию, так как стремится обрабатывать символы по одному, последовательно."
},
{
    "question": "Три закона для коммутативности и ассоциативности регулярных выражений",
    "answer": "L + M = M + L — коммутативный закон для объединения утверждает, что два языка можно объединять в любом порядке. 2. (L + M) + N = L + (M + N) — это ассоциативный закон объединения, который говорит, что для объединения трёх языков можно сначала объединить как два первых, так и два последних из них. Вместе с коммутативным законом этот закон позволяет объединять любое количество языков в произвольном порядке, разбивая их на любые группы, и результат будет одним и тем же. Очевидно, что некоторая цепочка принадлежит объединению L1 ∪ L2 ∪ … ∪ Lk тогда и только тогда, когда она принадлежит одному или нескольким языкам Li. 3. (LM)N = L(MN) — ассоциативный закон конкатенации гласит, что для конкатенации трёх языков можно сначала соединить как два первых, так и два последних из них."
},
{
    "question": "Дистрибутивные законы для регулярных выражений.",
    "answer": "Для регулярных выражений существует закон дистрибутивности, но, поскольку операция конкатенации некоммутативна, то он формулируется в виде следующих двух законов: • L(M + N) = LM + LN. Этот закон называется левосторонним дистрибутивным за коном конкатенации относительно объединения. • (M + N)L = ML + NL. Этот закон называется правосторонним дистрибутивным законом конкатенации относительно объединения."
},
{
    "question": "Законы связанные с оператором итерации (в контексте регулярных выражений и языков)",
    "answer": "Существует ряд законов, связанных с операцией итерации и её разновидностями + и ? в стиле UNIX. Законы с пояснением, почему они справедливы: (L*)* = L*. Этот закон утверждает, что при повторной итерации язык уже итерированного выражения не меняется. Язык выражения (L*)* содержит все цепочки, образованные конкатенацией цепочек языка L*. Последние же цепочки построены из цепочек языка L. Таким образом, цепочки языка (L*)* также являются конкатенациями цепочек из L и, следовательно, принадлежат языку L*. ∅* = ε. Итерация языка ∅ состоит из одной-единственной цепочки ε. ε* = ε. Легко проверить, что единственной цепочкой, которую можно образовать конкатенацией любого количества пустых цепочек, будет всё та же пустая цепочка. L⁺ = LL* = L*L. Напомним, что L⁺ по определению равно L + LL + LLL + …. Поскольку L* = ε + L + LL + LLL + …, то LL* = Lε + LL + LLL + LLLL + … Если учесть, что Lε = L, то очевидно, что бесконечные разложения для LL* и для L⁺ совпадают. Это доказывает, что L⁺ = LL*. Доказательство того, что L⁺ = L*L, аналогично. L* = L⁺ + ε. Это легко доказать, поскольку в разложении L⁺ присутствуют те же члены, что и в разложении L*, за исключением цепочки ε. Заметим, что если язык L содержит цепочку ε, то слагаемое `+ε` лишнее, т.е. в этом случае L⁺ = L*. L? = ε + L. В действительности это правило является определением оператора `?`."
},
{
    "question": "Преобразование НКА в ДКА",
    "answer": "Преобразование НКА в ДКА может занимать экспоненциальное время относительно количества состояний НКА. Вычисление ε-замыкания для n состояний занимает O(n³), так как нужно исследовать до n² дуг. Это можно сделать с помощью алгоритма Уоршалла. После вычисления ε-замыкания можно перейти к синтезу ДКА с помощью конструк ции подмножеств. Основное влияние на расход времени оказывает количество состояний ДКА, которое может равняться 2n. Для каждого состояния можно вычислить переходы завремя O(n3), используя ε-замыкание и таблицу переходов НКА для каждого входного символа. Предположим, нужно вычислить δ({q1, q2, …, qk}, a) для ДКА. Из каждого со стояния qi можно достичь не более n состояний вдоль путей с меткой ε, и каждое из этих состояний может иметь не более, чем n дуг с меткой a. Создав массив, проиндексиро ванный состояниями, можно вычислить объединение не более n множеств, состоящих из не более, чем n состояний, за время, пропорциональное n2. Таким способом для каждого состояния qi можно вычислить множество состояний, достижимых из qi вдоль пути с меткой a (возможно, включая дуги, отмеченные ε). По скольку k ≤ n, то существует не более n таких состояний qi, и для каждого из них вычисление достижимых состояний занимает время O(n2). Таким образом, общее время вы числения достижимых состояний равно O(n3). Для объединения множеств достижимых состояний потребуется только O(n2) дополнительного времени, следовательно, вычисле ние одного перехода ДКА занимает время O(n3). Заметим, что количество входных символов считается постоянным и не зависит от n.Таким образом, как в этой, так и в других оценках времени работы количество входных символов не рассматривается. Размер входного алфавита влияет только на постоянный коэффициент, скрытый в обозначении “О большого”. Итак, время преобразования НКА в ДКА, включая ситуацию, когда НКА содержит ε переходы, равно O((n^3)(2^n)). Конечно, на практике обычно число состояний, которые строятся, намного меньше 2n. Иногда их всего лишь n. Поэтому можно установить оценку времени ра боты равной O(n^3s), где s — это число состояний, которые в действительности есть у ДКА"
},
{
    "question": "Проверка истинности алгебраических тождеств (в контексте регулярных языков и выражений)",
    "answer": "Чтобы проверить эквивалент- ность регулярных выражений с переменными в качестве аргументов, необходимо подставить вместо этих переменных различные константы и проверить, будут ли совпадать языки, полученные в результате."
},
{
    "question": "Доказательство леммы о накачке для регулярных языков (Пусть L - регулярный язык)",
    "answer": "Пусть L — регулярный язык. Тогда L = L(A) для некоторого ДКА A. Пусть A имеет n состояний. Рассмотрим произвольную цепочку w длиной не менее n, скажем, w=a1a2...am, где m≥n и каждый ai есть входной символ. Для i= 0, 1, 2, ...,n  определим состояние pi как δ (q0, a1a2...ai), где δ — функция переходов автомата A, а q0 — его начальное состояние. Заметим, что p0 = q0 Рассмотрим n + 1 состояний pi при i = 0, 1, 2, ..., n. Поскольку автомат A имеет n раз- личных состояний, то по “принципу голубятни” найдутся два разных целых числа i и j (0 ≤ i < j ≤ n), при которых pi = pj. Теперь разобьем цепочку w на xyz. 1. x = a1a2...ai. 2. y = ai+1ai+2...aj. 3. z = aj+1aj+2...am. Таким образом, x приводит в состояние pi, y — из pi обратно в pi (так как pi = pj), а z — это остаток цепочки w. Взаимосвязи между цепочками и состояниями показаны на рис. 4.1. Заметим, что цепочка x может быть пустой при i = 0, а z — при j = n = m. Однако цепочка y не может быть пустой, поскольку i строго меньше j. Теперь посмотрим, что происходит, когда на вход автомата A поступает цепочка x(y^k)z для любого k ≥ 0. При k = 0 автомат переходит из начального состояния q0 (которое есть также p0) в pi, прочитав x. Поскольку pi = pj, то z переводит A из pi в допускающее со- стояние (см. рис. 4.1). Если k > 0, то по x автомат A переходит из q0 в pi, затем, читая yk, k раз циклически про- ходит через pi, и, наконец, по z переходит в допускающее состояние. Таким образом, для любого k ≥ 0 цепочка x(y^k)z также допускается автоматом A, т.е. принадлежит языку L."
},
{
    "question": "Что делать, если языки имеют разные алфавиты? (в контексте регулярных языков и выражений)",
    "answer": "При объединении или пересечении двух языков L и M может оказаться, что они определены в разных алфавитах. Например, возможен случай, когда L1 ⊆ {a, b}, а L2 ⊆ {b, c, d}. Однако, если язык L состоит из цепочек символов алфавита Σ, то L можно также рассматривать как язык в любом конечном алфавите, включающем Σ (надмножестве Σ). Например, можно представить указанные выше языки L1 и L2 как языки в алфавите {a, b, c, d}. То, что ни одна цепочка языка L1 не содержит символов c или d, несущественно, как и то, что ни одна цепочка языка L2 не содержит a. Аналогично, рассматривая дополнение языка L, который является подмножеством множества Σ1* для некоторого алфавита Σ1, можно взять дополнение относительно некоторого алфавита Σ2, включающего Σ1 (надмножества Σ1). В этом случае дополнением L будет Σ2* – L, т.е. дополнение языка L относительно алфавита Σ2 включает (среди прочих) все цепочки из Σ2*, которые содержат хотя бы один символ алфавита Σ2, не принадлежащий Σ1. Если взять дополнение L относительно Σ1, то ни одна цепочка, содержащая символы из Σ2 – Σ1, не попадет в L . Таким образом, чтобы избежать неточностей, нужно указывать алфавит, относительно которого берется дополнение. Часто, однако, бывает очевидно, какой алфавит подразумевается в конкретном случае. Например, если язык L определен некоторым автоматом, то в описании этого автомата указывается и алфавит. Итак, во многих ситуациях можно говорить о “дополнении”, не указывая алфавит."
},
{
    "question": "Теорема (Майхилл-Нероуд) для регулярных языков",
    "answer": "Теорема (Майхилл-Нероуд) звучит так: язык 𝐿 ⊆ Σ* является регулярным т. и т.т., когда Σ*/≈_𝐿 – конечное множество. Доказательство. Если Σ*/≈𝐿 конечно, то существует канонический ДКА 𝑀_𝐿, построенный в доказательстве предыдущей теоремы и распознающий язык 𝐿, т.е. язык 𝐿 ⊆ Σ* регулярен. Если 𝐿 – регулярный язык, то он распознаётся некоторым ДКА 𝑀, а значит |Σ*/≈_𝐿| ≤ |Σ*/∼_𝑀 | ≤ |𝑄_𝑀|, откуда Σ*/≈_𝐿 конечно. Непосредственно из доказательства теоремы Майхилла-Нероуда следует, что канонический ДКА 𝑀𝐿 для регулярного языка 𝐿 имеет наименьшее возможное число состояний среди ДКА, распознающих язык 𝐿. Однако построение канонического ДКА для 𝐿 нельзя назвать конструктивным ввиду сложности определения отношения ≈𝐿. Опишем алгоритм, который по произвольному ДКА 𝑀 находит ДКА 𝑀′, распознающий тот же самый язык и имеющий наименьшее возможное число состояний (алгоритм минимизации)."
},
{
    "question": "Что называется конфигурацией ДКА 𝑀 = (𝑄, Σ, 𝑠, 𝐹, 𝛿)",
    "answer": "Конфигурацией ДКА 𝑀 = (𝑄, Σ, 𝑠, 𝐹, 𝛿) называется произвольная пара(𝑞, 𝑤), где 𝑞 ∈ 𝑄, 𝑤 ∈ Σ*."
},
{
    "question": "Как задается Бинарное отношение ≈𝐿 задаётся на множестве Σ*?",
    "answer": "Бинарное отношение ≈_𝐿 задаётся на множестве Σ* следующим образом: ∀𝑥, 𝑦 ∈ Σ* 𝑥 ≈_𝐿 𝑦 ⇔ ∀𝑧 ∈ Σ* 𝑥𝑧 ∈ 𝐿 ⇔ 𝑦𝑧 ∈ 𝐿 Заметим, что ≈𝐿 является отношением эквивалентности на Σ*. Т.е. можно определить систему классов эквивалентности (фактор-множество) Σ*/≈_𝐿 следующим образом ∀𝑥 ∈ Σ*  [𝑥]≈_𝐿 = {𝑦 ∈ Σ*| 𝑥 ≈𝐿 𝑦} Далее покажем, что фактор-множество конечно т. и т. т., когда 𝐿 – регулярный язык. Пусть 𝐿 ⊆ Σ* – некоторый регулярный язык и пусть 𝑀 = (𝑄, Σ, 𝑠, 𝐹, 𝛿) – ДКА, такой что 𝐿 = 𝐿(𝑀). На множестве слов определим бинарное отношение ∼_𝑀 следующим образом: ∀𝑥, 𝑦 ∈ Σ*  𝑥 ∼_𝑀 𝑦 ⇔ (𝑠, 𝑥) ⊢*_𝑀  (𝑞, 𝑒) ∧ (𝑠, 𝑦) ⊢*_𝑀 (𝑞, 𝑒) Т.к. ∼_𝑀 является отношением эквивалентности на Σ*, то можно говорить о классах эквивалентности [𝑥]∼_𝑀 и фактор-множестве Σ*/∼_𝑀 ."
},
{
    "question": "Теорема о совпадении классов регулярных и автоматных языков",
    "answer": "Для языка 𝐿 ⊆ Σ* следующие условия эквивалентны: 1. 𝐿 = 𝐿(𝛼) для некоторого регулярного выражения 𝛼 алфавита Σ; 2. 𝐿 = 𝐿(𝑀) для некоторого ДКА 𝑀. Т.о., классы регулярных и автоматных языков совпадают."
},
{
    "question": "Пусть 𝛼 – регулярное выражение алфавита Σ. Как Язык 𝐿(𝛼) ⊆ Σ* определяется по регулярному выражению 𝛼 индукцией по сложности 𝛼?",
    "answer": "1. 𝐿(∅) = ∅; 2. 𝐿(𝑎) = {𝑎}, 𝑎 ∈ Σ; 3. 𝐿 ((𝛼 ∪ 𝛽)) = 𝐿(𝛼) ∪ 𝐿(𝛽); 4. 𝐿 ((𝛼 ∘ 𝛽)) = 𝐿(𝛼) ∘ 𝐿(𝛽); 5. 𝐿(𝛼*) = 𝐿(𝛼)*."
},
{
    "question": "Лемма о разрастании для регулярных языков ",
    "answer": "Если L — регулярный язык, то существует натуральная константа k_L (зависящая от L), такая, что для любой цепочки x принадлежит L, длина которой не меньше k_L, x допускает представление в виде x=uvw, где v!=lambda и |v|<= k_L, причем для любого n>=0 цепочка x_n=uv^nw принадлежит L. Эта лемма (см. теорему 7.10) утверждает, что любой регулярный язык допускает представление всех своих достаточно длинных цепочек в виде соединения трех цепочек, причем средняя цепочка из этих трех не пуста, ограничена по длине, и ее `накачка` — повторение любое число раз — или выбрасывание не выводит за пределы языка (т.е. дает цепочки, принадлежащие данному регулярному языку)."
},


