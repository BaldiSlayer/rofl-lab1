[
  {"question": "Что такое ТФЯ?", "answer": "теория формальных языков"},
  {"question": "Что такое ДКА?", "answer": "детерминированный конечный автомат"},
  {
      "question": "Рекурсивные языки.",
      "answer": "Язык L называется рекурсивным, если L = L(M) для некоторой машины Тьюринга M, удовлетворяющей следующим условиям. 1. Если w принадлежит L, то M попадает в допускающее состояние (и, следовательно, останавливается). 2. Если w не принадлежит L, то M в конце концов останавливается, хотя и не попадает в допускающее состояние. МТ этого типа соответствует интуитивному понятию “алгоритма” — правильно определенной последовательности шагов, которая всегда заканчивается и приводит к некоторому ответу. Если мы рассматриваем язык L как “проблему”, то проблема L называется разрешимой, если она является рекурсивным языком. В противном случае проблема называется неразрешимой."
  },
  {
      "question": "Рекурсивно-перечислимые языки. Примеры языков, которые являются рекурсивно-перечислимыми, но не рекурсивными.",
      "answer": "Язык L является рекурсивно-перечислимым (РП-языком), если L = L(M) для некоторой машины Тьюринга M"
  },
  {
      "question": "Что такое язык диагонализации L_d",
      "answer": "Язык диагонализации Ld — это множество всех цепочек wi, не принадлежащих L(Mi)."
  },
  {
      "question": "Является ли язык Ld рекурсивно-перечислимым",
      "answer": "Язык Ld не является рекурсивно-перечислимым, т.е. не существует машины Тьюринга, которая допускала бы Ld.Доказательство. Допустим, что Ld = L(M) для некоторой МТ M. Так как Ld — язык надалфавитом {0, 1}, M должна содержаться в построенной нами последовательности машинТьюринга, поскольку эта последовательность содержит все МТ с входным алфавитом {0, 1}. Следовательно, в ней есть, по крайней мере, один код машины M, скажем, i, т.е. M = Mi. Выясним теперь, принадлежит ли wi языку Ld.Если wi принадлежит Ld, то Mi допускает wi Но тогда (по определению Ld) wi не принадлежит Ld, так как Ld содержит лишь такие wj для которых Mj не допускает wj Точно так же, если wi не принадлежит Ld, то Mi не допускает wi. Но тогда (по определению Ld) wi принадлежит Ld. Поскольку wi не может одновременно и принадлежать, и не принадлежать Ld, приходим к противоречию с нашим предположением о том, что M существует. Таким образом, Ld не является рекурсивно-перечислимым языком."
  },
  {
      "question": "Почему языки 'рекурсивные'?",
      "answer": "Современные программисты знакомы с понятием рекурсивной функции. Остается непонятным, что общего между рекурсивными функциями и машинами Тьюринга, которые всегда останавливаются. Еще хуже, что нерекурсивными, или неразрешимыми, называются языки, которые не распознаются никаким алгоритмом, хотя под “нерекурсивными” мы привыкли понимать вычисления настолько простые, что они не требуют обращений к рекурсивным функциям. Термин “рекурсивный” как синоним слова “разрешимый” возник в период развития математики, предшествовавший появлению компьютеров. В качестве понятия вычисления обычно использовались формализмы, основанные на рекурсии (но не итерации или цикле). В этих системах понятий (не рассматриваемых здесь) было нечто от вычислений в таких языках функционального программирования, как LISP или ML. В этом смысле выражение “проблема рекурсивна” означало, что она “проста настолько, что можно записать рекурсивную функцию, которая всегда приводит к ее решению за конечное число шагов”. И в наши дни применительно к машинам Тьюринга этот термин имеет в точности тот же смысл. Термин “рекурсивно-перечислимый” — из того же семейства понятий. С помощью некоторой функции элементы языка можно выписать в некотором порядке, т.е. “перечислить” их. Языки, элементы которых можно перечислить в некотором порядке, — это именно те языки, которые допускаются некоторой МТ (возможно, работающей бесконечно на недопустимых входах)."
  },
  {
      "question": "Почему все рекурсивные языки являются рекурсивно-перечислимыми, но не все рекурсивно-перечислимые языки являются рекурсивными.",
      "answer": "Чтобы доказать что язык является РП, но не рекурсивным, часто используется дополнение этого языка. Покажем, что рекурсивные языки замкнуты относительно дополнения. Поэтому, если язык L является РП, а его дополнение L` — нет, то L не может быть рекурсивным. Если бы L был рекурсивным, то L` также был бы рекурсивным, а следовательно, и РП. Докажем это важное свойство замкнутости рекурсивных языков. Теорема: Если L — рекурсивный язык, то язык L` также рекурсивен. Доказательство. Пусть L = L(M) для некоторой всегда останавливающейся МТ M. Построим МТ M , у которой L` = L( M ), т.е. M ведет себя так же, как и M; изменения касаются лишь допускающих состояний. 1. Допускающие состояния M становятся недопускающими состояниями M , не имеющими переходов, т.е. в этих состояниях M останавливается, не допуская. 2. M имеет новое допускающее состояние r, из которого нет переходов. 3. Для каждой комбинации из недопускающего состояния и ленточного символа M, в которой M не имеет перехода (т.е. останавливается, не допуская), добавляется переход в допускающее состояние r.  Поскольку M всегда останавливается, то всегда останавливается и M . Кроме того, M допускает множество именно тех цепочек, которые не допускаются M, т.е. L` ."
  },
  {
      "question": "Почему универсальный язык L_u является РП, но не рекурсивным.",
      "answer": "Язык Lu является РП. Допустим, что Lu рекурсивен. Тогда по теореме 9.3 L` u (дополнение Lu) — также рекурсивный язык. Но если существует МТ M, допускающая L` u, то, используя описанный ниже метод, можно построить МТ, допускающую Ld. Поскольку нам известно, что Ld не является РП, приходим к противоречию с предположением, что язык Lu является рекурсивным. Предположим, что L(M) = L` u. можно преобразовать МТ M в МТ M′, которая допускает Ld с помощью следующих действий1. M′ преобразует входную цепочку w в w111w. В качестве упражнения читатель может написать программу для выполнения этого шага на одной ленте. Однако легче это сделать, используя для копии w вторую ленту, и затем преобразовать двухленточную МТ в одноленточную. 2. M′ имитирует M на новом входе. Если w есть wi в нашем перечислении, то M′ определяет, допускает ли Mi вход wi. Поскольку M допускает L` u, то она допускает тогда и только тогда, когда Mi не допускает wi, т.е. когда wi принадлежит Ld. Таким образом, M′ допускает w тогда и только тогда, когда w принадлежит Ld. Поскольку по теореме 9.2 машины M′ не существует, приходим к выводу, что язык Lu не является рекурсивным."
  },
  {
      "question": "Является ли язык Lne РП/рекурсивным?",
      "answer": "Lne – непустой язык состоит из кодов всех машин Тьюринга, которые допускают хотя бы одну цепочку.   Он рекурсивно-перечислим, но не рекурсивным"
  },
  {
      "question": "Является ли язык Le РП/рекурсивным?",
      "answer": " Le – пустой язык состоит из кодов всех МТ, языки которых пусты. Он не рекурсивно-перечислим."
  },
  {
      "question": "Теорема Райса",
      "answer": "Всякое нетривиальное свойство РП-языков неразрешимо."
  },
  {
      "question": "Существует ли вход, при обработке которого МТ совершает более пяти переходов?",
      "answer": "Алгоритм решения становится очевидным,если заметить, что, когда МТ делает пять переходов, она обозревает не более девяти клеток вокруг начальной позиции головки. Поэтому можно проимитировать пять переходов МТ на любом из конечного числа входов, длина которых не более девяти. Если все эти имитации не достигают останова, то делается вывод, что на любом входе данная МТ совершает более пяти переходов"
  },
  {
      "question": "Что такое проблема соответствий Поста.",
      "answer": "Экземпляр проблемы соответствий Поста (ПСП) состоит из двух списков равной длины в некотором алфавите Σ. Как правило, мы будем называть их списками A и B, и писать A = w1, w2, …, wk и B = x1, x2, …, xk при некотором целом k. Для каждого i пара (wi, xi) называется парой соответствующих цепочек. Мы говорим, что экземпляр ПСП имеет решение, если существует последовательность из одного или нескольких целых чисел i1, i2, …, im, которая, если считать эти числа индексами цепочек и выбрать соответствующие цепочки из списков A и B, дает одну и ту же цепочку, т.е. wi1 wi2 …wim = xi1 xi2 …xim. В таком случае последовательность i1, i2, …, im называется решающей последовательностью, или просто решением, данного экземпляра ПСП"
  },
  {
      "question": "Что такое модифицированная проблема соответствий Поста. ",
      "answer": "Модифицированной проблемой соответствий Поста, или МПСП. В модифицированной ПСП на решение накладывается дополнительное требование, чтобы первой парой в решении была пара первых элементов списков A и B. Более формально, экземпляр МПСП состоит из двух списков A = w1, w2, …, wk и B = x1, x2, …, xk, и решением является последовательность из 0 или нескольких целых чисел i1, i2, …, im, при которой w1wi1wi2…wim = x1xi1xi2…xim. Отметим, что цепочки обязательно начинаются парой (w1, x1), хотя индекс 1 даже не указан в качестве начального элемента решения. Кроме того, в отличие от ПСП, решение которой содержит хотя бы один элемент, решением МПСП может быть и пустая последовательность (когда w1 = x1). Однако такие экземпляры не представляют никакого интереса и далее не рассматриваются."
  },
  {
      "question": "Разрешима ли ПСП/ проблема соответствий поста",
      "answer": "Проблема соответствий Поста неразрешима."
  },
  {
      "question": "Разрешим ли вопрос о неоднозначности КС-грамматики",
      "answer": "Вопрос о неоднозначности КС-грамматики неразрешим"
  },
  {
      "question": "Пусть G1 и G2 — КС-грамматики, а R — регулярное выражение. Тогда какие проблемы неразрешимы?",
      "answer": "Пусть G1 и G2 — КС-грамматики, а R — регулярное выражение. Тогда неразрешимы следующие проблемы: а) 'L(G1) I L(G2) = ∅ ?' б) 'L(G1) = L(G2) ?' в) 'L(G1) = L(R) ?'' г) верно ли, что L(G1) = T* для некоторого алфавита T ? д) 'L(G1) ⊆ L(G2) ?' е) 'L(R) ⊆ L(G1) ?'"
  },
  {
      "question": "Что такое переход машины Тьюринга?",
      "answer": "Переход машины Тьюринга — это функция, зависящая от состояния конечного управления и обозреваемого символа. За один переход машина Тьюринга должна выполнить следующие действия: изменить состояние, записать ленточный символ в обозреваемую клетку, сдвинуть головку влево или вправо."
  },
  {
      "question": "Какие языки допускаются при помощи машины Тьюринга?",
      "answer": "Языки, допустимые с помощью машины Тьюринга, называются рекурсивно перечислимыми, или РП-языками."
  },
  {
      "question": "Опишите прием «память в состоянии» машины Тьюринга.",
      "answer": "Память в состоянии - конечное управление можно использовать не только для представления позиции в «Программе» машины Тьюринга, но и для хранения конечного объема данных."
  },
  {
      "question": "Опишите прием «Подпрограммы» машины Тьюринга.",
      "answer": "Подпрограмма машины Тьюринга представляет собой множество состояний, выполняющее некоторый полезный процесс. Это множество включает в себя стартовое состояние и еще одно состояние, которое не имеет переходов и служит состоянием «возврата» для передачи управления какому-либо множеству состояний, вызвавшему данную подпрограмму. «Вызов» подпрограммы возникает везде, где есть переход в ее начальное состояние."
  },
  {
      "question": "Можно ли запомнить позицию ленточной головки в позиции управления у машины Тьюринга?",
      "answer": "Хотя позиции конечны в каждый момент времени, всё множество позиций может быть и бесконечным. Если состояние должно представлять любую позицию головки, то в состоянии должен быть компонент данных, имеющий любое целое в качестве значения. Из-за этого компонента множество состояний должно быть бесконечным, даже если только конечное число состояний используется в любой конечный момент времени. Определение же машин Тьюринга требует, чтобы множество состояний было конечным. Таким образом, запомнить позицию ленточной головки в конечном управлении нельзя."
  },
  {
      "question": "Что такое «счетчиковая машина»?",
      "answer": "«Счетчиковые машины» — это класс машин, обладающие возможностью запоминать конечное число целых чисел («счетчиков») и совершать различные переходы в зависимости от того, какие из счетчиков равны 0 (если таковые вообще есть). Счетчиковая машина может только прибавить 1 к счетчику или вычесть 1 из него, но отличить значения двух различных ненулевых счетчиков она не способна."
  },
  {
      "question": "Какой язык допускается счетчиковой машиной?",
      "answer": "Каждый язык, допускаемый счетчиковой машиной, рекурсивно перечислим. Причина в том, что счетчиковые машины являются частным случаем магазинных, а магазинные — частным случаем многоленточных машин Тьюринга, которые по теореме допускают только рекурсивно перечислимые языки."
  },
  {
      "question": "Допускается ли любой рекурсивно перечислимый язык двухсчетчиковой машиной?",
      "answer": "Для имитации машины Тьюринга и, следовательно, для допускания любого рекурсивно перечислимого языка, достаточно двух счетчиков. Для обоснования этого утверждения вначале доказывается, что достаточно трех счетчиков, а затем три счетчика имитируются с помощью двух."
  },
  {
      "question": "Что такое универсальная машина Тьюринга?",
      "answer": "Универсальной машиной Тьюринга называют машину Тьюринга, которая может заменить собой любую машину Тьюринга. Получив на вход программу и входные данные, она вычисляет ответ, который вычислила бы по входным данным машина Тьюринга, чья программа была дана на вход."
  },
  {
      "question": "Какое время необходимо многоленточной машины Тьюринга для имитации переходов компьютера?",
      "answer": "Выполнение n шагов работы компьютера можно проимитировать на одноленточной машине Тьюринга с использованием не более O(n^3) шагов."
  },
  {
      "question": "Что можно сказать о мощностях разных машин Тьюринга?",
      "answer": "Все виды машин Тьюринга, независимо от различий в их конструкции или правилах работы, обладают одинаковой вычислительной мощностью, то есть способны вычислить одни и те же классы функций. Это свойство называется тезисом Чёрча-Тьюринга. Оно гласит, что любая вычислимая функция может быть вычислена машиной Тьюринга. Различия между видами машин Тьюринга (например, между детерминированными и недетерминированными машинами, машинами с одним или несколькими лентами) могут повлиять на эффективность вычислений (время или пространство), но не на саму вычислительную мощность."
  },
  {
      "question": "Если проблема P1 неразрешима и ее можно свести к проблеме P2, то является ли проблема P2 неразрешимой?",
      "answer": "Если P1 можно свести к P2 и если P1 неразрешима, то и P2 неразрешима."
  },
  {
      "question": "Что такое рандомизированная машина Тьюринга?",
      "answer": "Рандомизированная машина Тьюринга — это вариант многоклеточной машины Тьюринга. Первая лента, как обычно для многоленточных машин, содержит вход. Вторая лента также начинается непустыми клетками. В принципе, вся она содержит символы 0 и 1, выбранные с вероятностью 1/2. Вторая лента называется случайной лентой. Третья и последующие, если используются, вначале пусты и при необходимости выступают как рабочие."
  },
  {
      "question": "Как формально определяется машина Тьюринга?",
      "answer": "Машина Тьюринга описывается семеркой компонентов: конечное множество состояний конечного управления; конечное множество входных символов; множество ленточных символов; функция переходов; начальное состояние, в котором управление находится в начале; пустой символ, или пробел, который не является входным; множество заключительных, или допускающих, состояний"
  },
  {
      "question": "Какие существуют приемы интерпретации ленты и конечного управления машины Тьюринга?",
      "answer": "Существует три приема интерпретации ленты и конечного управления машины Тьюринга: память в состоянии, многодорожечные ленты, подпрограммы."
  },
  {
      "question": "Опишите прием «Многодорожечные ленты» в машине Тьюринга.",
      "answer": "При использовании приема «Многодорожечные ленты» рассматривается лента машины Тьюринга, образованная несколькими дорожками. Каждая дорожка может хранить один символ (в одной клетке), и алфавит машины Тьюринга состоит из кортежей, с одним компонентом для каждой «дорожки»."
  },
  {
      "question": "Существуют ли не рекурсивно перечислимые языки, допускаемые многоленточными машинами Тьюринга?",
      "answer": "Каждый язык, допускаемый многоленточной машиной Тьюринга, рекурсивно перечислим."
  },
  {
      "question": "Какое время необходимо одноленточной машине Тьюринга для имитации перехода многоленточной машины Тьюринга?",
      "answer": "Время, необходимое одноленточной машине Тьюринга для имитации n переходов многоленточной машины Тьюринга, есть O(n^2))."
  },
  {
      "question": "Что такое «мультистековая (многомагазинная) машина»?",
      "answer": "Мультистековая (многомагазинная) машина представляет собой детерминированный МП-автомат с несколькими магазинами. Он получает свои входные данные, как и МП-автомат, из некоторого их источника, а не с ленты или из магазина, как машина Тьюринга. Мультистековая машина имеет конечное управление, то есть конечное множество состояний, и конечный магазинный алфавит, используемый для всех магазинов. Переход мультистековой машины основывается на состоянии, входном символе и верхних символах всех магазинов."
  },
  {
      "question": "Как называется язык, который допускается односчетчиковой машиной?",
      "answer": "Каждый язык, допускаемый односчетчиковой машиной, является КС-языком. Контекстно-свободный (КС) язык  — это язык, задаваемый контекстно-свободной грамматикой. Контекстно-свободной грамматикой  называется грамматика, у которой в левых частях всех правил стоят только одиночные нетерминалы."
  },
  {
      "question": "Можно ли имитировать машину Тьюринга на компьютере?",
      "answer": "Имитация машины Тьюринга на компьютере в принципе возможна, если допустить, что для имитации значащей части ленты существует потенциально бесконечный запас сменных запоминающих устройств вроде диска. Поскольку физические ресурсы, необходимые для создания дисков, конечны, данный довод сомнителен. Однако, поскольку пределы памяти Вселенной неизвестны или, без сомнения, обширны, предположение о бесконечности ресурсов (как для ленты машины Тьюринга) является практически реалистичным и в целом допустимо."
  },
  {
      "question": "Какое время необходимо одноленточной машине Тьюринга для имитации переходов компьютера?",
      "answer": "Машина Тьюринга может имитировать n шагов компьютера за O(n^6) своих шагов."
  },
  {
      "question": "Почему язык, допускающийся в недетерминированных машинах Тьюринга, также допускается и обычной детерминированной машиной Тьюринга?",
      "answer": "Несмотря на кажущуюся большую мощность недетерминированных машин в связи с тем, что они выполняют несколько возможных вычислений сразу (требуя только, чтобы хоть одно из них заканчивалось в допускающем состоянии), любой язык, допускающийся недетерминированной машиной Тьюринга, также допускается и обычной детерминированной машиной Тьюринга, поскольку она может моделировать любой недетерминированный переход, делая многократные копии состояния, если встречается неоднозначность."
  },
  {
      "question": "Как машина Тьюринга имитирует реальный компьютер?",
      "answer": "Машина Тьюринга может имитировать память и управление реального компьютера путем использования одной ленты для записи всех элементов памяти и их содержимого — регистров, основной памяти, дисков и других запоминающих устройств. Таким образом, можно быть уверенным, что все, не выполнимое машиной Тьюринга, не может быть сделано и компьютером."
  },
  {
      "question": "Если проблема P1 не рекурсивно-перечисляема и ее можно свести к проблеме P2, то является ли проблема P2 не рекурсивно-перечисляемой?",
      "answer": "Если P1 можно свести к P2 и если P1 не рекурсивно-перечисляема, то и P2 не рекурсивно-перечисляема."
  },
  {
      "question": "Какая проблема может возникнуть при допуске языка в рандомизированную машину Тьюринга?",
      "answer": "Имея дело с рандомизированными машинами Тьюринга, нужно быть более аккуратным с тем, что значит допускание входа такой машиной; становится возможным, что машина Тьюринга вообще не допускает никакого языка. Проблема в том, что при анализе действий рандомизированной машины Тьюринга со входом приходится рассматривать все возможные случайные последовательности на второй ленте. Вполне возможно, что машина Тьюринга допускает при одних случайных последовательностях, но отвергает при других; в действительности, если рандомизированная машина Тьюринга должна делать что-то более эффективно, чем детерминированная машина Тьюринга, то существенно, чтобы различные последовательности на рандомизированной ленте приводили к различному поведению."
  },
  {
      "question": "Определение фундированного множества",
      "answer": "Определение 1: Частично упорядоченное множество (A, ≤) называется фундированным, если в любом непустом подмножестве A есть минимальный элемент.  Определение 2: Частично упорядоченное множество (A, ≤) называется фундированным, если в нём нет бесконечных убывающих цепей, то есть в A нельзя выбрать бесконечную последовательность элементов a0, a1, a2, …, такую, что a0 > a1 > a2 > … > an > … Определение 3: Частично упорядоченное множество (A, ≤) называется фундированным, если для него выполняется принцип индукции: для любого свойства P(x) выполнено условие: [∀a ((∀a’ < a P(a’)) → P(a))] → (∀a P(a)). Три определения фундированного множества эквивалентны друг другу."
  },
  {
      "question": "Определение частично упорядоченного множество",
      "answer": "Множество A с заданным на нем частичным порядком R называется частично упорядоченным множеством и обозначается (A;R)"
  },
  {
      "question": "Что называется трансфинитной индукцией?",
      "answer": "Трансфинитная индукция — метод доказательства, обобщающий математическую индукцию на случай несчетного числа значений параметра. Трансфинитная индукция основана на следующем утверждении: пусть M — вполне упорядоченное множество, P(x) — некоторое утверждение для x из M. Если для любого x из M, из того, что P(y) истинно для всех y < x, следует, что верно P(x), и если P(x) верно для минимального элемента множества M, то утверждение P(x) верно для любого x из M."
  },
  {
      "question": "Что такое свободный моноид над множеством?",
      "answer": "Свободным моноидом M над множеством S (обозначается как MS) называется моноид над множеством S∗ — набором всевозможных последовательностей (или списков) конечной длины (в том числе и нулевой), образованных из элементов множества S — с ассоциативной операцией конкатенации ++ этих последовательностей."
  },
  {
      "question": "Какие существуют операции над языками в теории формальных языков?",
      "answer": "Теоретико-множественные операции: L ∪ M — объединение, L ∩ M — пересечение, L ∖ M — разность,  L̅ = Σ∗ ∖ L — дополнение. Конкатенация: LM = {αβ | α ∈ L, β ∈ M}. Конкатенация с обратным языком: LR⁻¹ = {w | ∃y ∈ R: wy ∈ L}; конкатенация с обратным словом: Ly⁻¹ = L{y}⁻¹, y ∈ Σ∗. Степень языка: L⁰ = {ε}, k = 0; Lᵏ = LLᵏ⁻¹, k > 0. Замыкание Клини: L∗ = ⋃i=0∞ Lⁱ. Гомоморфизм."
  },
  {
      "question": "Теорема Цермело",
      "answer": "Теорема (Цермело): На любом множестве A можно ввести такой порядок ≤, что множество (A, ≤) будет вполне упорядоченным."
  },
  {
      "question": "Теорема Цермело",
      "answer": "Теорема (Цермело): На любом множестве A можно ввести такой порядок ≤, что множество (A, ≤) будет вполне упорядоченным."
  },
  {
      "question": "В хорошо написанном регулярном выражении должны быть сбалансированы какие факторы?",
      "answer": "В хорошо написанном регулярном выражении должны быть сбалансированы несколько факторов: • Регулярное выражение должно совпадать там, где нужно, и нигде больше • Регулярное выражение должно быть понятным и управляемым • При использовании механизма НКА (недетерминированный конечный автомат) выражение должно быть эффективным (т. е. быстро приводить к совпадению или несовпадению, в зависимости от результата поиска)"
  },
  {
      "question": "Какие возможности механизм НКА может поддерживать, недоступные для ДКА? (в конетексте регулярных выражений и языков)",
      "answer": "Механизм недетерминированного конечного автомата (НКА) обладает рядом возможностей, недоступных для детерминированного конечного автомата (ДКА), что делает его более гибким и мощным инструментом для работы с регулярными выражениями: 1. Сохранение текста, совпадающего с подвыражениями: НКА поддерживает сохранение текста, заключённого в круглые скобки в регулярном выражении. Это позволяет использовать обратные ссылки и получать информацию о том, где именно в целевом тексте были найдены совпадения. 2. Позиционные и сложные проверки с нулевой длиной совпадения: НКА может выполнять позиционные проверки (например, проверки начала или конца строки) и другие сложные проверки, не требующие дополнительных символов для совпадения. 3. Минимальные квантификаторы и упорядоченный выбор: В отличие от ДКА, который обеспечивает поиск минимального совпадения в целом, НКА поддерживает локальные минимальные квантификаторы и упорядоченный выбор, что позволяет регулировать последовательность проверок и минимизировать длину совпадений на более локальном уровне. 4. Захватывающие квантификаторы и атомарная группировка: НКА поддерживает захватывающие квантификаторы и атомарную группировку, что позволяет эффективно контролировать совпадения и избегать ненужных проверок. 5. Обработка многоопределённости: НКА способен работать с многоопределёнными языками, в которых могут существовать несколько вариантов ввода и вывода. В отличие от этого, ДКА ограничен обработкой немногоопределённых языков, где допустим только один вход и один выход. 6. Обработка рекурсивных выражений: НКА может работать с рекурсивными регулярными выражениями, которые включают вложенные выражения. ДКА не поддерживает рекурсию, так как стремится обрабатывать символы по одному, последовательно."
  },
  {
      "question": "Три закона для коммутативности и ассоциативности регулярных выражений",
      "answer": "L + M = M + L — коммутативный закон для объединения утверждает, что два языка можно объединять в любом порядке. 2. (L + M) + N = L + (M + N) — это ассоциативный закон объединения, который говорит, что для объединения трёх языков можно сначала объединить как два первых, так и два последних из них. Вместе с коммутативным законом этот закон позволяет объединять любое количество языков в произвольном порядке, разбивая их на любые группы, и результат будет одним и тем же. Очевидно, что некоторая цепочка принадлежит объединению L1 ∪ L2 ∪ … ∪ Lk тогда и только тогда, когда она принадлежит одному или нескольким языкам Li. 3. (LM)N = L(MN) — ассоциативный закон конкатенации гласит, что для конкатенации трёх языков можно сначала соединить как два первых, так и два последних из них."
  },
  {
      "question": "Дистрибутивные законы для регулярных выражений.",
      "answer": "Для регулярных выражений существует закон дистрибутивности, но, поскольку операция конкатенации некоммутативна, то он формулируется в виде следующих двух законов: • L(M + N) = LM + LN. Этот закон называется левосторонним дистрибутивным за коном конкатенации относительно объединения. • (M + N)L = ML + NL. Этот закон называется правосторонним дистрибутивным законом конкатенации относительно объединения."
  },
  {
      "question": "Законы связанные с оператором итерации (в контексте регулярных выражений и языков)",
      "answer": "Существует ряд законов, связанных с операцией итерации и её разновидностями + и ? в стиле UNIX. Законы с пояснением, почему они справедливы: (L*)* = L*. Этот закон утверждает, что при повторной итерации язык уже итерированного выражения не меняется. Язык выражения (L*)* содержит все цепочки, образованные конкатенацией цепочек языка L*. Последние же цепочки построены из цепочек языка L. Таким образом, цепочки языка (L*)* также являются конкатенациями цепочек из L и, следовательно, принадлежат языку L*. ∅* = ε. Итерация языка ∅ состоит из одной-единственной цепочки ε. ε* = ε. Легко проверить, что единственной цепочкой, которую можно образовать конкатенацией любого количества пустых цепочек, будет всё та же пустая цепочка. L⁺ = LL* = L*L. Напомним, что L⁺ по определению равно L + LL + LLL + …. Поскольку L* = ε + L + LL + LLL + …, то LL* = Lε + LL + LLL + LLLL + … Если учесть, что Lε = L, то очевидно, что бесконечные разложения для LL* и для L⁺ совпадают. Это доказывает, что L⁺ = LL*. Доказательство того, что L⁺ = L*L, аналогично. L* = L⁺ + ε. Это легко доказать, поскольку в разложении L⁺ присутствуют те же члены, что и в разложении L*, за исключением цепочки ε. Заметим, что если язык L содержит цепочку ε, то слагаемое `+ε` лишнее, т.е. в этом случае L⁺ = L*. L? = ε + L. В действительности это правило является определением оператора `?`."
  },
  {
      "question": "Преобразование НКА в ДКА",
      "answer": "Преобразование НКА в ДКА может занимать экспоненциальное время относительно количества состояний НКА. Вычисление ε-замыкания для n состояний занимает O(n³), так как нужно исследовать до n² дуг. Это можно сделать с помощью алгоритма Уоршалла. После вычисления ε-замыкания можно перейти к синтезу ДКА с помощью конструк ции подмножеств. Основное влияние на расход времени оказывает количество состояний ДКА, которое может равняться 2n. Для каждого состояния можно вычислить переходы завремя O(n3), используя ε-замыкание и таблицу переходов НКА для каждого входного символа. Предположим, нужно вычислить δ({q1, q2, …, qk}, a) для ДКА. Из каждого со стояния qi можно достичь не более n состояний вдоль путей с меткой ε, и каждое из этих состояний может иметь не более, чем n дуг с меткой a. Создав массив, проиндексиро ванный состояниями, можно вычислить объединение не более n множеств, состоящих из не более, чем n состояний, за время, пропорциональное n2. Таким способом для каждого состояния qi можно вычислить множество состояний, достижимых из qi вдоль пути с меткой a (возможно, включая дуги, отмеченные ε). По скольку k ≤ n, то существует не более n таких состояний qi, и для каждого из них вычисление достижимых состояний занимает время O(n2). Таким образом, общее время вы числения достижимых состояний равно O(n3). Для объединения множеств достижимых состояний потребуется только O(n2) дополнительного времени, следовательно, вычисле ние одного перехода ДКА занимает время O(n3). Заметим, что количество входных символов считается постоянным и не зависит от n.Таким образом, как в этой, так и в других оценках времени работы количество входных символов не рассматривается. Размер входного алфавита влияет только на постоянный коэффициент, скрытый в обозначении “О большого”. Итак, время преобразования НКА в ДКА, включая ситуацию, когда НКА содержит ε переходы, равно O((n^3)(2^n)). Конечно, на практике обычно число состояний, которые строятся, намного меньше 2n. Иногда их всего лишь n. Поэтому можно установить оценку времени ра боты равной O(n^3s), где s — это число состояний, которые в действительности есть у ДКА"
  },
  {
      "question": "Проверка истинности алгебраических тождеств (в контексте регулярных языков и выражений)",
      "answer": "Чтобы проверить эквивалент- ность регулярных выражений с переменными в качестве аргументов, необходимо подставить вместо этих переменных различные константы и проверить, будут ли совпадать языки, полученные в результате."
  },
  {
      "question": "Доказательство леммы о накачке для регулярных языков (Пусть L - регулярный язык)",
      "answer": "Пусть L — регулярный язык. Тогда L = L(A) для некоторого ДКА A. Пусть A имеет n состояний. Рассмотрим произвольную цепочку w длиной не менее n, скажем, w=a1a2...am, где m≥n и каждый ai есть входной символ. Для i= 0, 1, 2, ...,n  определим состояние pi как δ (q0, a1a2...ai), где δ — функция переходов автомата A, а q0 — его начальное состояние. Заметим, что p0 = q0 Рассмотрим n + 1 состояний pi при i = 0, 1, 2, ..., n. Поскольку автомат A имеет n раз- личных состояний, то по “принципу голубятни” найдутся два разных целых числа i и j (0 ≤ i < j ≤ n), при которых pi = pj. Теперь разобьем цепочку w на xyz. 1. x = a1a2...ai. 2. y = ai+1ai+2...aj. 3. z = aj+1aj+2...am. Таким образом, x приводит в состояние pi, y — из pi обратно в pi (так как pi = pj), а z — это остаток цепочки w. Взаимосвязи между цепочками и состояниями показаны на рис. 4.1. Заметим, что цепочка x может быть пустой при i = 0, а z — при j = n = m. Однако цепочка y не может быть пустой, поскольку i строго меньше j. Теперь посмотрим, что происходит, когда на вход автомата A поступает цепочка x(y^k)z для любого k ≥ 0. При k = 0 автомат переходит из начального состояния q0 (которое есть также p0) в pi, прочитав x. Поскольку pi = pj, то z переводит A из pi в допускающее со- стояние (см. рис. 4.1). Если k > 0, то по x автомат A переходит из q0 в pi, затем, читая yk, k раз циклически про- ходит через pi, и, наконец, по z переходит в допускающее состояние. Таким образом, для любого k ≥ 0 цепочка x(y^k)z также допускается автоматом A, т.е. принадлежит языку L."
  },
  {
      "question": "Что делать, если языки имеют разные алфавиты? (в контексте регулярных языков и выражений)",
      "answer": "При объединении или пересечении двух языков L и M может оказаться, что они определены в разных алфавитах. Например, возможен случай, когда L1 ⊆ {a, b}, а L2 ⊆ {b, c, d}. Однако, если язык L состоит из цепочек символов алфавита Σ, то L можно также рассматривать как язык в любом конечном алфавите, включающем Σ (надмножестве Σ). Например, можно представить указанные выше языки L1 и L2 как языки в алфавите {a, b, c, d}. То, что ни одна цепочка языка L1 не содержит символов c или d, несущественно, как и то, что ни одна цепочка языка L2 не содержит a. Аналогично, рассматривая дополнение языка L, который является подмножеством множества Σ1* для некоторого алфавита Σ1, можно взять дополнение относительно некоторого алфавита Σ2, включающего Σ1 (надмножества Σ1). В этом случае дополнением L будет Σ2* – L, т.е. дополнение языка L относительно алфавита Σ2 включает (среди прочих) все цепочки из Σ2*, которые содержат хотя бы один символ алфавита Σ2, не принадлежащий Σ1. Если взять дополнение L относительно Σ1, то ни одна цепочка, содержащая символы из Σ2 – Σ1, не попадет в L . Таким образом, чтобы избежать неточностей, нужно указывать алфавит, относительно которого берется дополнение. Часто, однако, бывает очевидно, какой алфавит подразумевается в конкретном случае. Например, если язык L определен некоторым автоматом, то в описании этого автомата указывается и алфавит. Итак, во многих ситуациях можно говорить о “дополнении”, не указывая алфавит."
  },
  {
      "question": "Теорема (Майхилл-Нероуд) для регулярных языков",
      "answer": "Теорема (Майхилл-Нероуд) звучит так: язык 𝐿 ⊆ Σ* является регулярным т. и т.т., когда Σ*/≈_𝐿 – конечное множество. Доказательство. Если Σ*/≈𝐿 конечно, то существует канонический ДКА 𝑀_𝐿, построенный в доказательстве предыдущей теоремы и распознающий язык 𝐿, т.е. язык 𝐿 ⊆ Σ* регулярен. Если 𝐿 – регулярный язык, то он распознаётся некоторым ДКА 𝑀, а значит |Σ*/≈_𝐿| ≤ |Σ*/∼_𝑀 | ≤ |𝑄_𝑀|, откуда Σ*/≈_𝐿 конечно. Непосредственно из доказательства теоремы Майхилла-Нероуда следует, что канонический ДКА 𝑀𝐿 для регулярного языка 𝐿 имеет наименьшее возможное число состояний среди ДКА, распознающих язык 𝐿. Однако построение канонического ДКА для 𝐿 нельзя назвать конструктивным ввиду сложности определения отношения ≈𝐿. Опишем алгоритм, который по произвольному ДКА 𝑀 находит ДКА 𝑀′, распознающий тот же самый язык и имеющий наименьшее возможное число состояний (алгоритм минимизации)."
  },
  {
      "question": "Что называется конфигурацией ДКА 𝑀 = (𝑄, Σ, 𝑠, 𝐹, 𝛿)",
      "answer": "Конфигурацией ДКА 𝑀 = (𝑄, Σ, 𝑠, 𝐹, 𝛿) называется произвольная пара(𝑞, 𝑤), где 𝑞 ∈ 𝑄, 𝑤 ∈ Σ*."
  },
  {
      "question": "Как задается Бинарное отношение ≈𝐿 задаётся на множестве Σ*?",
      "answer": "Бинарное отношение ≈_𝐿 задаётся на множестве Σ* следующим образом: ∀𝑥, 𝑦 ∈ Σ* 𝑥 ≈_𝐿 𝑦 ⇔ ∀𝑧 ∈ Σ* 𝑥𝑧 ∈ 𝐿 ⇔ 𝑦𝑧 ∈ 𝐿 Заметим, что ≈𝐿 является отношением эквивалентности на Σ*. Т.е. можно определить систему классов эквивалентности (фактор-множество) Σ*/≈_𝐿 следующим образом ∀𝑥 ∈ Σ*  [𝑥]≈_𝐿 = {𝑦 ∈ Σ*| 𝑥 ≈𝐿 𝑦} Далее покажем, что фактор-множество конечно т. и т. т., когда 𝐿 – регулярный язык. Пусть 𝐿 ⊆ Σ* – некоторый регулярный язык и пусть 𝑀 = (𝑄, Σ, 𝑠, 𝐹, 𝛿) – ДКА, такой что 𝐿 = 𝐿(𝑀). На множестве слов определим бинарное отношение ∼_𝑀 следующим образом: ∀𝑥, 𝑦 ∈ Σ*  𝑥 ∼_𝑀 𝑦 ⇔ (𝑠, 𝑥) ⊢*_𝑀  (𝑞, 𝑒) ∧ (𝑠, 𝑦) ⊢*_𝑀 (𝑞, 𝑒) Т.к. ∼_𝑀 является отношением эквивалентности на Σ*, то можно говорить о классах эквивалентности [𝑥]∼_𝑀 и фактор-множестве Σ*/∼_𝑀 ."
  },
  {
      "question": "Теорема о совпадении классов регулярных и автоматных языков",
      "answer": "Для языка 𝐿 ⊆ Σ* следующие условия эквивалентны: 1. 𝐿 = 𝐿(𝛼) для некоторого регулярного выражения 𝛼 алфавита Σ; 2. 𝐿 = 𝐿(𝑀) для некоторого ДКА 𝑀. Т.о., классы регулярных и автоматных языков совпадают."
  },
  {
      "question": "Пусть 𝛼 – регулярное выражение алфавита Σ. Как Язык 𝐿(𝛼) ⊆ Σ* определяется по регулярному выражению 𝛼 индукцией по сложности 𝛼?",
      "answer": "1. 𝐿(∅) = ∅; 2. 𝐿(𝑎) = {𝑎}, 𝑎 ∈ Σ; 3. 𝐿 ((𝛼 ∪ 𝛽)) = 𝐿(𝛼) ∪ 𝐿(𝛽); 4. 𝐿 ((𝛼 ∘ 𝛽)) = 𝐿(𝛼) ∘ 𝐿(𝛽); 5. 𝐿(𝛼*) = 𝐿(𝛼)*."
  },
  {
      "question": "Лемма о разрастании для регулярных языков",
      "answer": "Если L — регулярный язык, то существует натуральная константа k_L (зависящая от L), такая, что для любой цепочки x принадлежит L, длина которой не меньше k_L, x допускает представление в виде x=uvw, где v!=lambda и |v|<= k_L, причем для любого n>=0 цепочка x_n=uv^nw принадлежит L. Эта лемма (см. теорему 7.10) утверждает, что любой регулярный язык допускает представление всех своих достаточно длинных цепочек в виде соединения трех цепочек, причем средняя цепочка из этих трех не пуста, ограничена по длине, и ее `накачка` — повторение любое число раз — или выбрасывание не выводит за пределы языка (т.е. дает цепочки, принадлежащие данному регулярному языку)."
  },
  {
      "question": "Что называется нейтральным элементом операции в регулярных выражениях?",
      "answer": "Единичным (нейтральным) элементом (единицей) операции называется элемент, для которого верно следующее утверждение: если данная операция применяется к единичному элементу и некоторому другому элементу, то результат равен другому элементу."
  },
  {
      "question": "Что называется нулевым элементом (аннулятором) операции в регулярных выражениях?",
      "answer": "Нулевым элементом (нулем, аннулятором) операции называется элемент, для которого истинно следующее: результатом применения данной операции к нулевому и любому другому элементу является нулевой элемент."
  },
  {
      "question": "В каком случае два регулярных выражения с переменными являются эквивалентными?",
      "answer": "Два выражения с переменными являются эквивалентными, если при подстановке любых языков вместо переменных оба выражения представляют один и тот же язык."
  },
  {
      "question": "Когда операция называется идемпотентной?",
      "answer": "Операция называется идемпотентной, если результат применения этой операции к двум одинаковым значениям как операндам равен этому значению."
  },
  {
      "question": "Закон идемпотентности операции объединения",
      "answer": "Закон идемпотентности операции объединения утверждает, что объединение двух одинаковых выражений можно заменить одним таким выражением."
  },
  {
      "question": "Что такое обращение цепочки в регулярных языках",
      "answer": "Обращением цепочки (a_1)(a_2)...(a_n) называется цепочка, записанная в обратном порядке, т.е. (a_n)(a_n-1)...(a_1). Обращение w обозначается w^R. Таким образом, 0010^R есть 0100, а ε^R = ε."
  },
  {
      "question": "Что такое обращение языка L в регулярных языках",
      "answer": "Обращение языка L, обозначаемое L^R, состоит из всех цепочек, обратных цепочкам языка L. Например, если L = {001, 10, 111}, то L^R = {100, 01, 111}."
  },
  {
      "question": "Что такое Гомоморфизм цепочек в регулярных языках",
      "answer": "Гомоморфизм цепочек — это такая функция на множестве цепочек, которая подставляет определенную цепочку вместо каждого символа данной цепочки."
  },
  {
      "question": "Как рекурсивно определяется регулярное выражение",
      "answer": "Регулярное выражение над алфавитом Σ = {c_1, c_2, …, c_k} — способ порождения языка над Σ. Определяется рекурсивно следующим образом: Для любого i слово c_i является регулярным выражением, задающим язык из одного слова ci. ε является регулярным выражением, задающим язык из одной пустой строки, а ∅ — пустой язык. Если a_1 и a_2 являются регулярными выражениями, задающими языки L_1 и L_2 соответственно, то (a_1)|(a_2) — регулярное выражение, задающее L_1 $\bigcup$ L_2. Если a_1 и a_2 являются регулярными выражениями, задающими языки L_1 и L_2 соответственно, то (a_1)(a_2) — регулярное выражение, задающее L_1L_2. Если a_1 является регулярным выражением, задающим язык L_1, то (a_1)* — регулярное выражение, задающее (L_1)*."
  },
  {
      "question": "Что такое замыкание Клини и где оно используется в регулярных выражениях?",
      "answer": "Итерация (“звездочка”, или замыкание Клини) языка L обозначается L* и представляет собой множество всех тех цепочек, которые можно образовать путем конкатенации любого количества цепочек из L. При этом допускаются повторения, т.е. одна и та же цепочка из L может быть выбрана для конкатенации более одного раза. Например, если L = {0, 1}, то L* — это все цепочки, состоящие из нулей и единиц. Если L = {0, 11}, то в L* входят цепочки из нулей и единиц, содержащие четное количество единиц, например, цепочки 011, 11110 или ε, и не входят цепочки 01011 или 101. Более формально язык L* можно представить как бесконечное объединение L^i, где L^0 = ε, L^1 = L и Li для i>1 равен LL...L(конкатенация i копий L)."
  },
  {
      "question": "Лемма о накачке для регулярных языков",
      "answer": "Пусть L — регулярный язык. Существует константа n (зависящая от L), для которой каждую цепочку w из языка L, удовлетворяющую неравенству |w| >= n, можно разбить на три цепочки w = xyz так, что выполняются следующие условия. 1. y != ε 2. |xy| <= n. 3. Для любого k >= 0 цепочка x(y^k)z также принадлежит L. Это значит, что всегда можно найти такую цепочку y недалеко от начала цепочки w, которую можно “накачать”. Таким образом, если цепочку y повторить любое число раз или удалить (при k = 0), то результирующая цепочка все равно будет принадлежать языку L."
  },
  {
      "question": "Относительно каких операций замкнуты регулярные языки?",
      "answer": "регулярные языки замкнуты относительно следующих операций: 1. Объединение 2. Пересечение 3. Дополнение 4. Разность. 5. Обращение. 6. Итерация (звездочка). 7. Конкатенация. 8. Гомоморфизм (подстановка цепочек вместо символов языка). 9. Обратный гомоморфизм."
  },
  {
      "question": "В каком случае два регулярных языка совпадают?",
      "answer": "Два регулярных языка совпадают, если любое слово или содержится в обоих языках, или не содержится ни в одном из них."
  },
  {
      "question": "Законы регулярных выражений, связанные с единичным элементом и нулевым элементом",
      "answer": "Для регулярных выражений существует три закона, связанных с этими понятиями. • ∅ + L = L + ∅ = L. Этот закон утверждает, что ∅ является единицей объединения. • εL = Lε = L. Этот закон гласит, что ε является единицей конкатенации. • ∅L = L∅ = ∅. Этот закон утверждает, что ∅ является нулевым элементом конкатенации."
  },
  {
      "question": "Связь регулярных выражений и автоматов по Хопкрофту",
      "answer": "Регулярные выражения описывают регулярные языки — класс языков, которые могут быть распознаны детерминированными или недетерминированными конечными автоматами (ДКА и НКА). В основе использования регулярных выражений лежит идея, что любой язык, который можно описать с помощью регулярных выражений, может быть распознан конечным автоматом."
  },
  {
      "question": "Как использовать regex выражения в Python?",
      "answer": "В Python есть модуль re, который предоставляет средства для работы с регулярными выражениями. Например, функции match(), search(), findall()"
  },
  {
      "question": "Как использовать regex выражения в Java?",
      "answer": "Java включает пакет java.util.regex, который поддерживает основные и продвинутые функции регулярных выражений, такие как группировка, кванторы и классы символов"
  },
  {
      "question": "Как использовать regex выражения в JavaScript?",
      "answer": "Встроенная поддержка регулярных выражений через объекты RegExp позволяет использовать регулярные выражения в строковых операциях, таких как match(), replace(), split()."
  },
  {
      "question": "Как использовать regex выражения в C#",
      "answer": "C# предоставляет класс Regex из пространства имен System.Text.RegularExpressions, который поддерживает работу с регулярными выражениями и возможности обработки текста."
  },
  {
      "question": "Какие основные компоненты регулярных выражений?",
      "answer": "Символы (простые символы (буквы, цифры) просто соответствуют самим себе), Мета-символы (специальные символы, которые имеют особое значение), Квантификаторы (указывают количество повторений), Группировка (скобки () используются для группировки выражений), Экранирование (использование обратного слэша ) "
  },
  {
      "question": "Какие бывают квантификаторы в регулярных выражениях?",
      "answer": " * это 0 или более повторений предыдущего символа, + это 1 или более повторений, ? это 0 или 1 повторение, {n} это точное количество повторений"
  },
  {
      "question": "Что такое экранирование в регулярных выражениях?",
      "answer": "Символы, такие как ., *, +, имеют специальное значение, но их можно использовать как обычные символы, если экранировать с помощью обратного слэша "
  },
  {
      "question": "Что такое метасимволы?",
      "answer": ". — любой одиночный символ, ^ — начало строки, $ — конец строки, [] — набор символов, | — логическое ИЛИ "
  },
  {
      "question": "Как называются цепочки, к которым приводят порождения из стартового символа контекстно-свободной грамматики?",
      "answer": "Порождения из стартового символа грамматики приводят к цепочкам, которые называются 'выводимыми цепочками' ('sentential form'). Пусть G = (V, T, P, S) — контекстно-свободная грамматика, где V — множество переменных, T — терминалов, P — множество продукций, S — стартовый символ. Тогда любая цепочка α из (V U T)*, для которой S*⇒α, называется выводимой цепочкой. Если S* lm ⇒ α, то α является левовыводимой цепочкой, а если S* rm ⇒ α, то — правовыводимой. Язык L(G) образуют выводимые цепочки из T*, состоящие исключительно из терминалов."
  },
  {
      "question": "Какие основные свойства дерева разбора для контекстно-свободной грамматики?",
      "answer": "G = (V, T, P, S). Деревья разбора для G — это деревья со следующими свойствами: каждый внутренний узел отмечен переменной из V; каждый лист отмечен либо переменной, либо терминалом, либо ε. При этом, если лист отмечен ε, он должен быть единственным сыном своего родителя; если внутренний узел отмечен A, и его сыновья отмечены слева направо X1, X2, …, Xk, соответственно, то A → X1,X2 ⋅⋅⋅ Xk является продукцией в P. X может быть ε лишь в одном случае — если он отмечает единственного сына, и A → ε — продукция грамматики G."
  },
  {
      "question": "Может ли цепочка 𝜔, порожденная контекстно-свободной грамматикой Γ=⟨Σ,N,S,P⟩, иметь два разных дерева разбора, если у нее только одно левое порождение из P? Σ — алфавит терминальных символов, 𝑁 — множество нетерминальных символов, S — стартовый символ, P — множество правил продукций.",
      "answer": "Цепочка 𝜔 имеет два разных дерева разбора тогда и только тогда, когда ω имеет два разных левых порождения из 𝑃."
  },
  {
      "question": "Пусть G=(V,T,P,S) — контекстно-свободная грамматика, где V — множество переменных, T — терминалов, P — множество продукций, S — стартовый символ. Если рекурсивный вывод утверждает, что терминальная цепочка w принадлежит языку переменной 𝐴, что можно сказать о дереве разбора, связанной с этой переменной?",
      "answer": "Пусть G=(V,T,P,S) — контекстно-свободная грамматика, где V — множество переменных, T — терминалов, P — множество продукций, S — стартовый символ. Если рекурсивный вывод утверждает, что терминальная цепочка w принадлежит языку переменной A, то существует дерево разбора с корнем A и кроной w."
  },
  {
      "question": "Может ли терминальная цепочка принадлежать языку контекстно-свободной грамматики, если она не является кроной какого-либо дерева разбора для этой грамматики?",
      "answer": "Терминальная цепочка принадлежит языку грамматики тогда и только тогда, когда она является кроной, по крайней мере, одного дерева разбора. Таким образом, существование левых порождений, правых порождений и деревьев разбора является равносильным условием того, что все они определяют в точности цепочки языка КС-грамматики."
  },
  {
      "question": "Что такое нормальная форма Хомского?",
      "answer": "Грамматикой в нормальной форме Хомского (англ. Chomsky normal form) называется контекстно-свободная грамматика, в которой могут содержаться правила только следующего вида: A→BC; A→a; S→ε, где a — терминал, A,B,C — нетерминалы, S — стартовая вершина, ε — пустая строка, стартовая вершина не содержится в правых частях правил."
  },
  {
      "question": "Если контекстно-свободная грамматика 𝐺1 строится из грамматики G путем удаления цепных продукций, верно ли что 𝐿(𝐺1) = 𝐿(𝐺), где L - контекстно-свободный язык?",
      "answer": "Если контекстно-свободная грамматика 𝐺1 строится из грамматики G путем удаления цепных продукций, то 𝐿(𝐺1) = 𝐿(𝐺), где L - контекстно-свободный язык."
  },
  {
      "question": "Если L - контекстно-свободный язык, а R - регулярный язык, то что можно сказать про их пересечение?",
      "answer": "Если L - контекстно-свободный язык, а R - регулярный язык, то их пересечение является контекстно-свободным языком."
  },
  {
      "question": "Если L - контекстно-свободный язык и h - гомоморфизм, то является ли обратный гомоморфизм h(L)^-1 также контекстно-свободным языком?",
      "answer": "Если L - контекстно-свободный язык и h - гомоморфизм, то обратный гомоморфизм h(L)^-1 также является контекстно-свободным языком."
  },
  {
      "question": "Относительно каких операций замкнуты контекстно-свободные языки?",
      "answer": "Контекстно-свободные языки замкнуты относительно подстановки, объединения, конкатенации, обращения и обратного гомоморфизма. Контекстно-свободные языки не замкнуты относительно пересечения и дополнения, но пересечение контекстно-свободного языка с регулярным всегда является контекстно-свободным языком."
  },
  {
      "question": "Как эффективно проверить принадлежность цепочки w контекстно-свободному языку L?",
      "answer": "Для этого можно использовать CYK-алгоритм (алгоритм Кока-Янгера-Касами), представляющий собой эффективный метод проверки принадлежности цепочки к контекстно-свободному языку. Он начинается с грамматики в нормальной форме Хомского (НФХ) и на вход получает цепочку 𝑤=𝑎1𝑎2…𝑎𝑛 из терминалов. За время O(n^3) алгоритм строит таблицу, которая говорит, принадлежит ли w языку L. При вычислении этого времени сама по себе грамматика рассматривается фиксированной, и ее размер вносит лишь константный сомножитель в оценку времени, измеряемого в терминах длины цепочки, проверяемой на принадлежность L."
  },
  {
      "question": "Какое время требуется для поиска всех порождающих символов в контекстно-свободной грамматике G?",
      "answer": "Пусть G имеет длину n. Тогда у нее может быть порядка n переменных, и каждый проход индуктивного обнаружения порождающих переменных может занимать O(n) времени для проверки всех продукций G. Если на каждом проходе обнаруживается только одна новая порождающая переменная, то может понадобиться O(n) проходов. Таким образом, простая реализация проверки на порождающие символы требует O(n^2) времени, т.е. является квадратичной."
  },
  {
      "question": "Какая грамматика называется неукорачивающей?",
      "answer": "Порождающая грамматика называется неукорачивающей, если для каждого правила (α → β) ∈ P выполняется неравенство |α| <= |β|."
  },
  {
      "question": "Какое множество называется вполне упорядоченным?",
      "answer": "Вполне упорядоченными называются фундированные линейно упорядоченные множества"
  },
  {
      "question": "Что называется начальным отрезком вполне упорядоченного множества?",
      "answer": "Начальным отрезком вполне упорядоченного множества A называется такое множество B, что из x ∈ B и y <= x следует y ∈ B. Собственным начальным отрезком называется начальный отрезок, не равный самому множеству."
  },
  {
      "question": "Какой элемент называется предшественником?",
      "answer": "Элемент a называется (непосредственным) предшественником b, если a < b и не существует такого c, что a < c и c < b"
  },
  {
      "question": "Какой элемент называется последователем",
      "answer": "Элемент a называется (непосредственным) последователем b, если a > b и не существует такого c, что a > c и c > b"
  },
  {
      "question": "Если A и B - два вполне упорядоченных множества, изоморфны ли они оба начальному отрезку друг друга?",
      "answer": "Пусть A и B — два вполне упорядоченных множества. Тогда либо A изоморфно некоторому начальному отрезку множества B, либо B изоморфно некоторому начальному отрезку множества A"
  },
  {
      "question": "Изоморфно ли вполне упорядоченное множество своему начальному отрезку?",
      "answer": "Никакое вполне упорядоченное множество не изоморфно своему начальному отрезку (не совпадающему со всем множеством)"
  },
  {
      "question": "Лемма Цорна",
      "answer": "Пусть Z — частично упорядоченное множество, в котором всякая цепь имеет верхнюю границу. Тогда в этом множестве есть максимальный элемент, и, более того, для любого элемента a ∈ Z существует элемент b > a, являющийся максимальным в Z. (Цепь — это подмножество, любые два элемента которого сравнимы. Верхняя граница цепи — элемент, больший или равный любого элемента цепи)"
  },
  {
      "question": "Если x — произвольный элемент вполне упорядоченного множества A, то чем являются множества [0, x) (все элементы множества A, меньшие x) и [0, x] (элементы множества A, меньшие или равные x)?",
      "answer": " Множества [0, x) и [0, x] являются начальными отрезками."
  },
  {
      "question": "Как происходит сравнение порядков типов вполне упорядоченных множеств?",
      "answer": "Если A изоморфно начальному отрезку множества B, не совпадающему со всем B, то говорят, что порядковый тип множества A меньше порядкового типа множества B. Если множества A и B изоморфны, то говорят, что у них одинаковые порядковые типы. Наконец, если B изоморфно начальному отрезку множества A, то говорят, что порядковый тип множества A больше порядкового типа множества B."
  },
  {
      "question": "Верно ли, что из любых двух вполне упорядоченных множеств одно равномощно подмножеству другого?",
      "answer": "Из любых двух множеств (вполне упорядоченных) одно равномощно подмножеству другого."
  },
  {
      "question": "Если некоторая NP-полная проблема P1 принадлежит P (полиномиальный класс), то верно ли, что P = NP (полиномиальный класс равен недетерминированному полиномиальному)?",
      "answer": "Если некоторая NP-полная проблема P1 принадлежит P, то P = NP."
  },
  {
      "question": "NP-полна ли проблема выполнимости?",
      "answer": "Проблема выполнимости NP-полна (теорема Кука)"
  },
  {
      "question": "Какая система называется генератором лексического анализатора?",
      "answer": "UNIX-команда lex и ее GNU-версия flex получают на вход список регулярных выражений в стиле UNIX, за каждым из которых в фигурных скобках следует код, указывающий, что должен делать лексический анализатор, если найдет экземпляр этой лексемы. Такая система называется генератором лексического анализатора, поскольку на ее вход поступает высокоуровневое описание лексического анализатора и по этому описанию она создает функцию, которая представляет собой работающий лексический анализатор."
  },
  {
      "question": "Лемма о накачке для регулярных языков",
      "answer": "Пусть L — регулярный язык. Существует константа n (зависящая от L), для которой каждую цепочку w из языка L, удовлетворяющую неравенству |w| ≥ n, можно разбить на три цепочки w = xyz так, что выполняются следующие условия. 1. y≠ε. 2. |xy| ≤ n. 3. Для любого k ≥ 0 цепочка x(y^k)z также принадлежит L. Это значит, что всегда можно найти такую цепочку y недалеко от начала цепочки w, которую можно “накачать”. Таким образом, если цепочку y повторить любое число раз или удалить (при k = 0), то результирующая цепочка все равно будет принадлежать языку L."
  },
  {
      "question": "Как различные языки программирования (например, Python, Java, JavaScript) реализуют поддержку обратных ссылок и захватывающих групп в регулярных выражениях, и как это может влиять на производительность?",
      "answer": "В Python и Java поддержка обратных ссылок реализована с помощью конструкций типа %5C1, %5C2, что позволяет ссылаться на ранее захваченные группы. В JavaScript обратные ссылки отсутствуют, что делает некоторые сложные паттерны недоступными. Это различие может влиять на производительность, поскольку Java и Python могут потребовать больше памяти и времени на выполнение при использовании сложных шаблонов с большим количеством захватывающих групп, тогда как JavaScript будет менее затратным, но и менее гибким."
  },
  {
      "question": "Как особенности локализации и интернационализации влияют на использование регулярных выражений в современных языках программирования?",
      "answer": "Локализация и интернационализация могут значительно усложнить использование регулярных выражений, поскольку многие языки и их регулярные библиотеки не учитывают различные правила разбиения слов, различные алфавиты и символы (например, Unicode). Это приводит к необходимости использования более сложных шаблонов и дополнительной логики для корректного сопоставления строк, что может увеличивать сложность и время выполнения. Языки, такие как Python и Java, предоставляют специальные библиотеки для работы с Unicode, что помогает упростить эту задачу, но все равно требует внимательного проектирования регулярных выражений."
  },
  {
      "question": "Как можно оптимизировать сложные регулярные выражения для обработки больших объемов данных в конкретных проектах на Java или C#? Приведите примеры.",
      "answer": "В Java или C# можно использовать компиляцию регулярных выражений в заранее скомпилированные шаблоны с помощью Pattern.compile() (Java) или Regex.Compile() (C#). Это снижает время на повторные компиляции. Также важно избегать жадных квантификаторов и применять конкретные классы символов для уменьшения количества возможных совпадений."
  },
  {
      "question": "Как подходить к тестированию регулярных выражений? Какие методологии и инструменты использовать для обеспечения их корректности?",
      "answer": "Надо использовать подход TDD (разработка через тестирование). Сначала создавать тестовые случаи для ожидаемых входных данных, а затем разрабатывать регулярное выражение. Инструменты, такие как Regex101, помогают визуализировать совпадения и отладить выражения."
  },
  {
      "question": "Как регулярные выражения интегрируются с асинхронным программированием в таких языках, как JavaScript? Как это влияет на производительность?",
      "answer": "В асинхронных функциях использование регулярных выражений может быть трудным, так как операции с ними могут блокировать поток. Однако, использование методов match() или replace() в промисах помогает сохранить асинхронность, особенно при обработке больших объемов данных."
  },
  {
      "question": "Опиши процесс принятия решения о том, когда использовать регулярные выражения, а когда — альтернативные методы разбора",
      "answer": "Если задача простая (например, валидация форматов), выбираю регулярные выражения. Для сложных структур (например, HTML) использую парсеры, чтобы избежать ошибок."
  },
  {
      "question": "Что такое гомоморфизм цепочек?",
      "answer": "Гомоморфизм цепочек — это такая функция на множестве цепочек, которая подставляет определенную цепочку вместо каждого символа данной цепочки. Пример: функция h, определенная как h(0) = ab и h(1) = ε, является гомоморфизмом. В любой цепочке из символов 0 и 1 h заменяет все нули цепочкой ab, а все единицы — пустой цепочкой. Например, применяя h к цепочке 0011, получим abab."
  },
  {
      "question": "Расскажи про преобразование НКА в ДКА",
      "answer": "Одной из ключевых задач в теории автоматов является преобразование НКА в эквивалентный ДКА. Этот процесс называется алгоритмом подмножества: создаются состояния для ДКА, которые представляют собой множество состояний НКА; переходы определяются на основе всех возможных переходов в НКА для каждого входного символа."
  },
  {
      "question": "Опиши плюсы и минусы НКА и ДКА",
      "answer": "ДКА гораздо эффективнее в работе с входными данными и проста в реализации, но НКА проще в реализации и имеет меньшее количество состояний, если задача требует использование сложных паттернов"
  },
  {
      "question": "Как использовать regex в многопоточном контексте?",
      "answer": "Разделите большой текстовый файл или данные на несколько частей, и каждая часть обрабатывается в своем потоке. Например, в Java можно использовать ForkJoinPool для распараллеливания задач. Далее используйте потокобезопасные библиотеки, как re в Python. Создавайте отдельные экземпляры классов для работы с регулярными выражениями в каждом потоке - это предотвращает возможные проблемы с состоянием."
  },
  {
      "question": "Как можно вычислить частичные производные Антимирова?",
      "answer": "Частичные производные Антимирова — это метод, который используется в классической теории автоматов для преобразования регулярных выражений в конечные автоматы. \n\\(\\alpha_{c}(R)\\) \\text{- это регулярное выражение R' такое, что если} w \\(\\in \\mathcal{L}(R')\\), то  \\(w \\in \\mathcal{L}(R)\\). Обратное не обязательно выполняется. Вычислить частичные производные можно по следующему рекурсивному алгоритму: \n\\(\\alpha_{c}(c) = \\{\\epsilon\\}\\) \n\\(\\alpha_{c}(c') = \\{\\emptyset\\}\\) \n\\(\n\\alpha_{c}(\\epsilon) = \\{ \\emptyset \\}\n\\) \n\\(\n\\alpha_{c}(r_{1}r_{2}) =\n\\begin{cases}\n\\begin{array}{rcl}\n    \\{rr_{2} | r \\in \\alpha_{c}(r_{1}) \\cup \\alpha_{c}(r_{2}) \\text{, если } \\epsilon \\in \\mathcal{L}(r_{1}) \\} \n    \\{rr_{2} | r \\in \\alpha_{c}(r_{1})\\text{ иначе}\\}\n\\end{array}\n\\end{cases}\n\\) \n\\(\\alpha_{c}(\\perp) = \\{\\emptyset\\}\\) \n\\(\\alpha_{c}(r_{1} | r_{2}) =\\alpha_{c}(r_{1}) \\cup \\alpha_{c}(r_{2})\\) \n\\(\\alpha_{c}(r*) = \\{r'r* | r' \\in \\alpha_{c}(r) \\}\\) \nАвтомат Антимирова аналогичен автомату Брзозовски, но состояния представляют собой элементы \\(\\alpha_{w}\\), а не \\(\\delta_{w}\\). Упрощать по ACI состояния не требуется - их множество и так конечно. \nНапример, положим \\(R_{1} = (ab|b)\\)*\\(ba\\). \nТогда получаем: \n\\(\\alpha_{a}(R_{1}) = \\{b(ab|b)\\)*\\(ba\\}\\) \n\\(\\alpha_{b}(R_{1}) = \\{(ab|b)\\)*\\(ba,a)\\}\\) \n\\(\\alpha_{b}(R_{2}) = \\{(ab|b)\\)*\\(ba\\}\\) \n\\(\\alpha_{a}(R_{3}) = \\{\\epsilon\\}\\) \nСоответствующий автомат имеет состояния \\(R_{i}\\)\nи один недетерминированный переход."
  },
  {
      "question": "Какие условия необходимы для бисимуляции двух НКА?",
      "answer": "Чтобы определить отношение бисимуляции на конечных автоматах, к отношению бисимуляции на LTS нужно добавить ограничения на бисимуляцию начальных и конечных состояний. Более точно, для бисимуляции НКА $A_{1}$ и $A_{2}$ необходимы следующие условия: \n1) каждому состоянию $A_{1}$ бисимилярно состояние $A_{2}$ и наоборот \n2) стартовому состоянию $A_{1}$ бисимилярно стартовое состояние $A_{2}$ \n2) каждому финальному состоянию $A_{1}$ бисимилярно финальное состояние $A_{2}$ и наоборот \nБисимилярные НКА распознают равные языки.\nСостояния $q_{i}$ и $q_{j}$ в НКА А бисимирлярны ($q_{i} \\sim_{A} q_{j}$), если они связаны LTS-бисимуляцией и имеют одинаковую финальность в А.\nБисимуляцию НКА можно переформулировать как отношение бисимуляции состояний НКА такое, что стартовые состояния бисимилярны.\nОтношение $\\sim_{A}$ имеет важное свойство: бисимилярные состояния в автомате можно объединить без изменения его семантики. Это преобразование часто позволяет существенно упростить НКА."
  },
  {
      "question": "Являются ли финальные состояния и состояния-ловушки бисимилярными?",
      "answer": "Состояния $q_{i}$ и $q_{j}$ в НКА А бисимирлярны ($q_{i} \\sim_{A} q_{j}$), если они связаны LTS-бисимуляцией и имеют одинаковую финальность в А.\nВсе состояния-ловушки в любом полном автомате (т.е. с явно присутствующими переходами по всем буквам алфавита) бисимилярны друг другу. Все финальные состояния без переходов из них (кроме как в ловушки) также бисимилярны."
  },
  {
      "question": "Что такое трансформационный моноид?",
      "answer": "Трансформационный моноид $M_{A}$ для ДКА А - это моноид функций $F_{\\epsilon}$ таких, что $F_{\\epsilon}(q_{i}) = q_{j}$ тогда и только тогда, когда $q_{i}$ -> $q_{j}$ по $\\epsilon$ в А. Иначе можно сказать, что трансформационный моноид $M_{A}$ определяется множеством классов эквивалентности \\{w | w $\\in \\sum+$\\} таким, что $w_{i} = w_{j}$ тогда и только тогда, когда $F_{w_{i}} = F_{w_{j}}$."
  },
  {
      "question": "Какие свойства есть у трансформационного моноида?",
      "answer": "Для трансформационного моноида $M_{A}$ верны эти свойства:\n1) $M_{A}$ определяется фактормножеством классов эквивалентности и правилами переписывания, задающими эквивалентность. $\\epsilon$ обычно не включается в множество $w_{i}$.\n2) Поскольку множество $F_{w_{i}}$ в случае ДКА конечно, то $M_{A}$ содержит конечное число классов эквивалентности (верно и обратное: каждый такой моноид определяет ДКА).\n3) Трансмоноид строится для ДКА без ловушек; переход в ловушку обозначается в таблице переходов прочерком.\n4) Для единообразия записи трансформаций и перестановок в алгебре, в таблице переходов пишут только номера состояний А."
  },
  {
      "question": "Как строится трансформационный моноид?",
      "answer": "Определяем соответсвие между буквами и множествами переходов по ним и будем расширять этот список новыми словами в лексикографическом порядке. Если очередное слово задает такую же трансформацию, как и уже рассмотренное, порождаем соответствующее правило переписывания."
  },
  {
      "question": "Что такое синтаксический моноид?",
      "answer": "Определим отношение синтаксической конгруэнтности слов: \n$w_{i} \\sim_{L} w_{j} \n \\Leftrightarrow$ для любых x, y $(xw_{i}y \\in L \\Leftrightarrow xw_{j}y \\in L)$ \nСинтаксический моноид M(L) - это множество его классов эквивалентности относительно $\\sim_{L}$. То есть такая полугруппа с единицей над w $\\in \\sum$*, что  $w_{i} = w_{j} \\Leftrightarrow w_{i} \\sim_{L} w_{j}$ (равенство здесь понимается в алгебраическом смысле: как возможность преобразовать $w_{i}$ и $w_{j}$ к одному и тому же слову)\nЛемма. Синтаксический моноид регулярного языка L совпадает с трансф. моноидом минимального ДКА, его распознающего.\nСинтаксический моноид - атрибут языка, а трансф. моноид - атрибут конкретного языка."
  },
  {
      "question": "О чем говорит теорема Майхилла-Нероуда?",
      "answer": "Теорема Майхилла-Нероуда.(Критерий регулярности языка)\nЯзык L регулярен тогда и только тогда, когда множество классов эквивалентности по $\\equiv_{L}$ конечно.\nДоказательство:\n$\\Rightarrow$: Пусть L регулярен. Тогда он порождается некоторым DFA A с конечным числом состояний N. Значит, множество $\\{q_{i} | q_{0} \\rightarrow$ по w  $q_{i}\\}$ конечно, а для каждых двух $w_{1}, w_{2}$ таких, что $q_{0} \\rightarrow$ по $ w_{1}$ $q_{i}$ и $q_{0} \\rightarrow$ по $w_{2}$ $q_{i}$ выполняется $w_{1}\\equiv_{L}w_{2}$.\n$\\Leftarrow$: Пусть все слова в $\\sum$* принадлежат N классам эквивалентности $A_{1}...A_{n}$ по $\\equiv_{L}$. Построим по ним DFA A, распознающий L.\nКлассы $A_{i}$ сопоставим состояниям:\n1) Начальным объявим класс эквивалентности $A_{0}$ такой, что $\\epsilon \\in A_{0}$.\n2) Конечными объявим такие $A_{j}$, что для любого w $\\in A_{j}(w \\in L)$.\n3) Если w $\\in A_{i}, wa_{k} \\in A_{j}$, тогда добавляем в $\\delta$ правило ($A_{i}, a_{k},A_{j}$)."
  },
  {
      "question": "Как минимизировать ДКА?",
      "answer": "Минимизация ДКА.\n1) Построим таблицу всех двухэлементных множеств $\\{q_{i}, q_{j}\\} q_{i}, q_{j} \\in Q$.\n2) Пометим все множества $\\{q_{i}, q_{j}\\}$ такие, что одно из $q_{i}, q_{j}$ из F, а второе нет.\n3) Пометим все множества $\\{q_{i}, q_{j}\\}$ такие, что $\\exists a(q_{i} \\rightarrow$ по а $q_{1}' \\And q_{j} \\rightarrow$ по а $q_{2}' \\And \\{q_{1}',q_{2}'\\}$ - помеченная пара).\n4) Продолжаем шаг 3, пока не будет появляться новых помеченых пар.\nПары оставшиеся непомеченными, можно объединить."
  },
  {
      "question": "Как доказать минимальность автомата?",
      "answer": "Доказательство минимальности автомата.\nДля этого необходимо построить таблицу классов эквивалентности. Если в этой таблице все строчки различны, значит выбранные $w_{i}$ действительно лежат в различных классах эквивалентности, и DFA, распознающий язык L, не может иметь меньше len($w_{i}$) состояний. \nПри доказательстве минимаьности DFA достаточно подобрать [$\\log_{2}(n)$]+1 различающих суффиксов $z_{i}$, где n - число состояний автомата."
  },
  {
      "question": "Какие свойства есть у множества функций переходов ДКА?",
      "answer": "Свойства множества функций переходов ДКА:\n1) Существует единичная функция $F_{\\epsilon}$ такая, что $F_{\\epsilon} \\circ F_{\\xi} = F_{\\xi} \\circ F_{\\epsilon}=F_{\\xi}$\n2) Композиция ассоциативна.\nТаким образом, функции переходов по словам из $\\sum$* в ДКА А образуют моноид относительно композиции."
  },
  {
      "question": "Означает ли бисимуляция состояний равенство НКА?",
      "answer": "В равных НКА состояния бисимилярны,однако только условия существования бисимуляции и биекции бисимилярных состояний недостаточно, чтобы гарантировать равенство."
  },
  {
      "question": "Учитыват ли трансформационный моноид финальность состояний?",
      "answer": "Трансформационный моноид строится в контексте LTS(Labelled Transition Systems), то есть без учета финальности состояний. Поэтому из ДКА, по которому строится трансформационный моноид, предварительно удаляются все ловушки, иначе в нем могут появиться правила переписывания не имеющие никакого отношения к языку ДКА."
  },
  {
      "question": "Опиши структурную индукцию и приведи пример ее использования",
      "answer": "В теории автоматов используется несколько рекурсивно определяемых понятий, относительно которых будет необходимо доказывать те или иные утверждения. Важными примерами таких понятий являются деревья и выражения. Подобно индукции, все рекурсивные определения включают базис, где определяется одна или несколько элементарных структур, и индуктивный шаг, с помощью которого более сложные структуры определяются через структуры, определенные ранее. Пример: Рассмотрим рекурсивное определение дерева.\nБазис. Одиночный узел есть дерево, и этот узел является корнем дерева.\nИндукция. Если T1, T2, ..., Tk — деревья, то можно построить новое дерево следую-\nщим образом.\n1. Возьмем в качестве корня новый узел N.\n2. Возьмем по одному экземпляру деревьев T1, T2 ,..., Tk.\n3. Добавим ребра, соединяющие корень N, с корнями каждого из деревьев T1, T2, ..., Tk."
  },
  {
      "question": "Что такое нётерова индукция?",
      "answer": "Нётерова индукция — это обобщение трансфинитной индукции, которое заключается в следующем.\n\nПусть \\langle X, R \\rangle — фундированное множество, P(x) — некоторое утверждение об элементах множества X, и пусть мы хотим показать, что P(x) верно для всех x \\in X. Для этого достаточно показать, что если x \\in X, и P(y) верно для всех таких y \\in X, что y R x, то P(x) также верно. Другими словами:\n\n\n\\forall x \\in X \\left( \\left( \\forall y \\in X (y R x \\to P(y)) \\right) \\to P(x) \\right) \\to \\forall x \\in X (P(x)).\n"
  },
  {
      "question": "Что называется частичным порядком на множестве M?",
      "answer": "Отношением порядка, или частичным порядком, на множестве  M  называется бинарное отношение  \\varphi  на  M  (определяемое некоторым множеством  R_{\\varphi} \\subset M \\times M ), удовлетворяющее следующим условиям:\n\n\t•\tРефлексивность:  \\forall a \\ (a \\varphi a) \n\t•\tТранзитивность:  \\forall a, b, c \\ ((a \\varphi b) \\land (b \\varphi c) \\Rightarrow a \\varphi c) \n\t•\tАнтисимметричность:  \\forall a, b \\ ((a \\varphi b) \\land (b \\varphi a) \\Rightarrow a = b) \n\nМножество  M , на котором задано отношение частичного порядка, называется частично упорядоченным. Если быть совсем точным, то частично упорядоченным множеством называется пара  \\langle M, \\varphi \\rangle , где  M  — множество, а  \\varphi  — отношение частичного порядка на  M .\n\nРазмерность частично упорядоченного множества  \\langle M, \\varphi \\rangle  равна максимальной численности совокупности линейных порядков  <_i \\ (i \\in I) . В основе этого определения находится свойство продолжаемости частичного порядка до линейного."
  },
  {
      "question": "Какие существуют специальные типы частично упорядоченных множеств?",
      "answer": "Тривиально упорядоченные множества, линейно упорядоченные множества, вполне упорядоченные множества, полное частично упорядоченное множество."
  },
  {
      "question": "Как можно рассматривать частично упорядоченное множество в теории категорий?",
      "answer": "Каждое частично упорядоченное множество (и каждый предпорядок) можно рассматривать как категорию, в которой каждое множество морфизмов Hom(A, B) состоит не более чем из одного элемента. Например, эту категорию можно определить так: Hom(A, B) = {(A, B)}, если A ≤ B (и пустое множество в противном случае); правило композиции морфизмов: (y, z) ∘ (x, y) = (x, z). Каждая категория-предпорядок эквивалентна частично упорядоченному множеству.\n\nФунктор из категории-частично упорядоченного множества (то есть диаграмма, категория индексов которой является частично упорядоченным множеством) — это коммутативная диаграмма."
  },
  {
      "question": "Опиши совместную индукцию",
      "answer": "Совместная индукция — это метод, который используется, когда невозможно доказать по индукции отдельное утверждение. Вместо этого необходимо доказать одновременно целую группу утверждений S_1(n), S_2(n), …, S_k(n) с помощью индукции по n. В теории автоматов такая ситуация возникает достаточно часто. Например, существует общая ситуация, когда действие автомата описывается группой утверждений, по одному для каждого состояния. В этих утверждениях говорится, какие последовательности входных сигналов приводят автомат в каждое из его состояний.\n\nСтрого говоря, доказательство группы утверждений не отличается от доказательства их конъюнкции (логическое «И») — всех этих утверждений одновременно. Например, группу утверждений S_1(n), S_2(n), …, S_k(n) можно заменить одним утверждением S_1(n) \\land S_2(n) \\land … \\land S_k(n). Однако, если необходимо доказывать несколько действительно независимых утверждений, то проще рассматривать их отдельно, доказывая для каждого свой базис и индуктивный шаг. Такой тип доказательства называется совместной индукцией."
  },
  {
      "question": "Напиши теорему о трансфинитной рекурсии",
      "answer": "Фиксируем некоторый ординал α. Пусть h : X^{<α} → X. Тогда существует и единственная f : α → X такая, что для любого β ∈ α, f(β) = h(f \\restriction β)."
  },
  {
      "question": "Какие 4 компонента образуют контекстно-свободную грамматику?",
      "answer": "Контекстно-свободную грамматику образуют 1. Алфавит (Σ): Набор терминальных символов, из которых формируются строки языка. Эти символы не подлежат дальнейшей замене. 2. Нетерминальные символы (синтаксические категории) (N): Символы, которые могут быть заменены другими символами или последовательностями символов. Каждый нетерминальный символ представляет язык, т.е. множество цепочек. 3. Начальный символ (S): Один из нетерминальных символов, который используется в качестве точки начала для генерации строк языка. Другие переменные представляют дополнительные классы цепочек, которые помогают определить язык, заданный стартовым символом. Обычно обозначается буквой S, но может быть любым другим нетерминальным символом. 4. Правила продукции (P): Набор правил, определяющих, как нетерминальные символы могут быть заменены на терминальные или другие нетерминальные символы. Каждое правило имеет вид A → α, где A — нетерминальный символ, а α — конечная цепочка, состоящая из терминалов и переменных, возможно, пустая. Она называется телом продукции и представляет способ образования цепочек языка, обозначаемого переменной в голове. По этому способу мы оставляем терминалы неизменными и вместо каждой переменной в теле подставляем любую цепочку, про которую известно, что она принадлежит языку этой переменной."
  },
  {
      "question": "Является ли множество цепочек сбалансированных скобок регулярным языком?",
      "answer": "Нет, множество цепочек сбалансированных скобок не является регулярным языком. Чтобы строка со скобками была сбалансированной, количество открывающих и закрывающих скобок должно совпадать, и в любой префикс строки количество закрывающих скобок не должно превышать количество открывающих. Конечные автоматы не могут отслеживать количество открывающих и закрывающих скобок на произвольной глубине вложенности. Это связано с тем, что они имеют фиксированное количество состояний и не могут «помнить» количество открытых скобок, если оно превышает это количество состояний. Доказательство с помощью леммы о накачке: Если бы L(G), где G - грамматика, порождающая все цепочки сбалансированных скобок, был регулярным, то для него по лемме о накачке для регулярных языков существовала бы константа п. Рассмотрим сбалансированную цепочку w = «(»^n«)»^n, т.е. n левых скобок, за которыми следуют n правых. Если разбить W =xyz в соответствии с леммой, то у состоит только из левых скобок, и цепочка х содержит больше правых скобок, чем левых. Эта цепочка несбалансированна, т.е. получено противоречие с предположением, что язык сбалансированных скобок регулярен. Таким образом, множество цепочек сбалансированных скобок является контекстно-свободным языком (который может быть описан с помощью контекстно-свободных грамматик), но не является регулярным языком."
  },
  {
      "question": "Как получить контекстно-свободную грамматику без бесполезных символов?",
      "answer": "Пусть G = (V, I, P, S) - КС-грамматика, и G порождает хотя бы одну цепочку. Пусть G1 = (V1, T1, P1, S1) - грамматика, полученная с помощью следующих двух шагов. 1. Вначале удаляются непорождающие символы и все продукции, содержащие один или несколько таких символов. Пусть G2 = (V2, I2, Р2, S2) - полученная в результате грамматика. Заметим, что S должен быть порождающим, так как по предположению L(G) содержит хотя бы одну цепочку, поэтому S не удаляется. 2. Затем удаляются все символы, недостижимые в G1. Тогда G1, не имеет бесполезных символов, и L(G1) = L(G)."
  },
  {
      "question": "Что такое цепная пара в контекстно-свободных языках?",
      "answer": "Цепная пара - это пара (А, В), для которой А → В получается с использованием лишь цепных продукций."
  },
  {
      "question": "Какой смысл нормальной формы Хомского?",
      "answer": "Польза нормальной формы Хомского в следующих аспектах: - Неукорачивающие применения правил; - Нет пустых переходов - правила либо финальные, либо удлиняющие; - Контролируемый рост длины сентенциальной формы от количества шагов разбора; - Перевод грамматики в CNF позволяет легче анализировать свойства её языка и проводить разбор слов."
  },
  {
      "question": "Что такое крона дерева разбора грамматики?",
      "answer": "Крона дерева разбора (англ. leaves of the parse tree) - множество терминальных символов, упорядоченное в соответствии с номерами их достижения при обходе дерева в глубину из корня. Крона дерева разбора представляет из себя слово языка, которое выводит это дерево."
  },
  {
      "question": "Что такое однозначная грамматика?",
      "answer": "Грамматика называется однозначной (англ. unambiguous grammar), если у каждого слова имеется не более одного дерева разбора в этой грамматике."
  },
  {
      "question": "Что такое нормальная форма Куроды?",
      "answer": "Грамматика представлена в нормальной форме Куроды (англ. Kuroda normal form), если каждое правило имеет одну из четырех форм: 1. AB→CD; 2. A→BC; 3. A→B; 4. A→a или A→ε. Здесь A,B,C,D — нетерминалы, a a — терминал."
  },
  {
      "question": "Что такое нормальная форма пенттотена?",
      "answer": "Грамматика представлена в нормальной форме Пенттонена (англ. Penttonen normal form), если каждое правило имеет одну из трех форм: 1. AB→AC; 2. A→BC; 3. A→a или A→ε; Здесь A,B,C,D — нетерминалы, a a — терминал. Также грамматику Пенттонена называют односторонней нормальной формой (англ. one-sided normal form). Она является частным случаем нормальной формы Куроды: когда A=C в первом правиле определения. Для каждой контестно-зависимой грамматики существует слабо эквивалентная ей грамматика в форме Пенттонена."
  },
  {
      "question": "Когда контекстно-свободная грамматика не содержит бесполезных нетерминалов?",
      "answer": "Грамматика Γ не содержит бесполезных нетерминалов тогда и только тогда, когда грамматика Γ не содержит ни недостижимых нетерминалов, ни непорождающих."
  },
  {
      "question": "В чем практическая польза нормальной формы Грейбах?",
      "answer": "Использование нормальной формы Грейбах позволяет доказать, что для каждого контекстно-свободного языка (не содержащего ε) существует автомат с магазинной памятью без переходов по ε, а также позволяет использовать метод рекурсивного спуска, сложность которого является линейной, несмотря на возвраты."
  },
  {
      "question": "Опиши иерархию грамматик Хомского",
      "answer": "Класс 0: К нулевому классу относятся все формальные грамматики. Элементы этого класса называются неограниченными грамматиками (англ. unrestricted grammars), поскольку на них не накладывается никаких ограничений. Они задают все языки, которые могут быть распознаны машиной Тьюринга. Эти языки также известны как рекурсивно перечислимые (англ. recursively enumerable). Класс 1: Первый класс представлен неукорачивающими и контекстно-зависимыми грамматиками. Языки, заданные этими грамматиками, распознаются с помощью линейно ограниченного автомата (англ. linear bounded automaton) (недетерминированная машина Тьюринга, чья лента ограничена константой, зависящей от длины входа.) Известно, что неукорачивающие грамматики эквивалентны контекстно-зависимым. Класс 2: Второй класс составляют контекстно-свободные грамматики, которые задают контекстно-свободные языки. Эти языки распознаются с помощью автоматов с магазинной памятью. Класс 3: К третьему типу относятся автоматные или регулярные грамматики (англ. regular grammars) — самые простые из формальных грамматик, которые задают регулярные языки. Они являются контекстно-свободными, но с ограниченными возможностями."
  },
  {
      "question": "Что такое существенно неоднозначный контекстно-свободный язык?",
      "answer": "Контекстно-свободный язык L называется существенно неоднозначным, если все его грамматики неоднозначны. Если хотя бы одна грамматика языка L однозначна, то L является однозначным языком."
  },
  {
      "question": "Что такое полезный символ в грамматике G = (V, T, P, S)?",
      "answer": "Символ X называется полезным в грамматике G = (V, T, P, S), если существует некоторое порождение вида S *⇒ αXβ *⇒ w, где w ∈ T*. Отметим, что X может быть как переменной, так и терминалом, а выводимая цепочка αXβ — первой или последней в порождении. Если символ X не является полезным, то называется бесполезным. Очевидно, что исключение бесполезных символов из грамматики не изменяет порождаемого языка, поэтому все бесполезные символы можно обнаружить и удалить."
  },
  {
      "question": "Пусть G = (V, T, P, S) — КС-грамматика. Опиши алгоритм нахождения всех ε-порождающих символов G",
      "answer": "Все ε-порождающие символы G можно найти с помощью следующего алгоритма. Базис. Если A → ε — продукция в G, то A — ε-порождающая. Индукция. Если в G есть продукция B → C1C2…Ck, где каждый символ Ci является ε-порождающим, то B — ε-порождающая. Отметим, что для того, чтобы Ci был ε-порождающим, он должен быть переменной, поэтому нам нужно рассматривать продукции, тела которых содержат только переменные."
  },
  {
      "question": "Список наиболее значительных неразрешимых вопросов о контекстно-свободных грамматиках и языках",
      "answer": "1. Неоднозначна ли данная КС-грамматика G? 2. Является ли данный КС-язык существенно неоднозначным? 3. Пусто ли пересечение двух КС-языков? 4. Равны ли два данных КС-языка? 5. Равен ли Σ* данный КС-язык, где Σ — алфавит этого языка? Отметим, что вопрос 1 о неоднозначности отличается от остальных тем, что это вопрос о грамматике, а не о языке. Все остальные вопросы предполагают, что язык представлен грамматикой или МП-автоматом, но это все равно вопросы о языке (или языках). Например, в противоположность вопросу 1 вопрос 2 требует по данной грамматике G (или МП-автомату) определить, существует ли некоторая эквивалентная ей однозначная грамматика G′. Если G сама по себе однозначна, то ответом, безусловно, будет “да”, но если G неоднозначна, то для языка грамматики G может существовать другая грамматика G′, которая однозначна."
  },
  {
      "question": "Замкнуты ли контекстно-свободные языки относительно операции 'пересечение с регулярным языком’?",
      "answer": "Если L — КС-язык, а R — регулярный язык, то L ∩ R является КС-языком. Доказательство: Построим МП-автомат для пересечения регулярного языка и КС-языка. Пусть регулярный язык задан своим ДКА, а КС-язык — своим МП-автоматом c допуском по допускающему состоянию. Построим прямое произведение этих автоматов так же, как строилось прямое произведение для двух ДКА. Более формально, пусть R — регулярный язык, заданный своим ДКА ⟨Σ,Q1,s1,T1,δ1⟩, и L — КС-язык, заданный своим МП-автоматом: ⟨Σ,Γ,Q2,s2,T2,z0,δ2⟩. Тогда прямым произведением назовем следующий автомат: Q={⟨q1,q2⟩∣q1∈Q1,q2∈Q2}. Иначе говоря, состояние в новом автомате — пара из состояния первого автомата и состояния второго автомата. s=⟨s1,s2⟩ Стековый алфавит Γ остается неизменным. T={⟨t1,t2⟩∣t1∈T1,t2∈T2}. Допускающие состояния нового автомата — пары состояний, где оба состояния были допускающими в своем автомате. δ(⟨q1,q2⟩,c,d)=⟨δ1(q1,c),δ2(q2,c,d)⟩. При этом на стек кладется то, что положил бы изначальный МП-автомат при совершении перехода из состояния q2, видя на ленте символ c и символ d на вершине стека. Этот автомат использует в качестве состояний пары из двух состояний каждого автомата, а за операции со стеком отвечает только МП-автомат. Слово допускается этим автоматом ⟺ слово допускается и ДКА и МП-автоматом, то есть язык данного автомата совпадает с R∩L."
  },
  {
      "question": "Какие теоремы есть про проблему выводимости слов в теории формальных языков",
      "answer": "Существует алгоритм, позволяющий по произвольной контекстно-свободной грамматике G узнать, верно ли, что ε ∈ L(G). Существует алгоритм, позволяющий по произвольной контекстно-свободной грамматике G и по сло-ву w узнать, верно ли, что w ∈ L(G)."
  },
  {
      "question": "Когда проблема пустоты языка разрешима в теории формальных языков",
      "answer": "Существует алгоритм, позволяющий по произвольной контекстно-свободной грамматике G узнать, верно ли, что L(G) = ∅."
  },
  {
      "question": "О чём проблема бесконечности языка в теории формальных языков",
      "answer": "Она связана с вопросом о том, можно ли за полиномиальное время определить, является ли язык формального символа бесконечным или конечным.."
  },
  {
      "question": "когда разрешима проблема равентства автоматных языков в теории формальных языков",
      "answer": "Существует алгоритм, позволяющий по произвольным двум праволинейным грамматикам G1 и G2 узнать, верно ли, что L(G1) ⊆ L(G2). Существует алгоритм, позволяющий по произвольным двум праволинейным грамматикам G1 и G2 узнать, верно ли, что L(G1) = L(G2)."
  },
  {
      "question": "Что такое неукорачивающая грамматика в теории формальных языков",
      "answer": "Порождающая грамматика называется неукорачивающей, если для каждого правила (α → β) ∈ P выполняется неравенство |α| >= |β|."
  },
  {
      "question": "Каждая ли контекстная грамматика является неукорачивающей и наоборот в теории формальных языков",
      "answer": "Каждая контекстная грамматика является неукорачивающей. Каждая неукорачивающая грамматика эквивалентна некоторой контекстной грамматике."
  },
  {
      "question": "Какой критерий при котором язык L, не содержащий пустого слова, порождается некоторой неукорачивающей грамматикой в теории формальных языков",
      "answer": "Язык L, не содержащий пустого слова, порождается некоторой неукорачивающей грамматикой тогда и только тогда, когда существует линейно ограниченный автомат (в общем случае недетерминированный), который допускает язык L."
  },
  {
      "question": "Является ли класс языков, порождаемых неукорачивающими грамматиками, замкнутым относительно каких-то операций в теории формальных языков",
      "answer": "Класс языков, порождаемых неукорачивающими грамматиками, замкнут относительно операций объединения, пересечения и дополнения."
  },
  {
      "question": "Что такое ловушка и зачем она нужна?",
      "answer": "Ловушка - это не конечное состояние с переходами лишь в себя. Она нужна для корректного задания ДКА, но иногда может не описываться."
  },
  {
      "question": "Сколько начальных и конечных состояний может быть у автомата Томпсона?",
      "answer": "У автомата Томпсона единственное начальное состояние и единственное конечное состояние."
  },
  {
      "question": "Как получить линеаризованное регулярное выражение? Приведи пример.",
      "answer": "Если регулярное выражение r содержит n вхождений букв алфавита E, то линеаризованное выражение Linearize(r) получается из r при помощи приписывания i-ой по счёту букве, входящей в r, индекса i. Пример: (ab|b)aa => (a₁b₂|b₃)a₄a₅."
  },
  {
      "question": "Есть ли эпсилон-переходы у автомата Глушкова?",
      "answer": "Автомат Глушкова не содержит эпсилон-переходов."
  },
  {
      "question": "Каким в общем случае является автомат Глушкова?",
      "answer": "В общем случае автомат Глушкова является недетерминированным."
  },
  {
      "question": "Как нужно удалять эпсилон-переходы, чтобы сохранить недетерминированность?",
      "answer": "Если удалять переходы без изменения числа состояний, то это может сохранить недетерминированность переходов."
  },
  {
      "question": "Как на практике применяются производные Бзрозовски?",
      "answer": "Множество a⁻¹U = {w|aw ∈ U} называется производными Бзрозовски множества U, относительно a. Если ε ∈ a⁻¹U => a распознаётся выражением U. На практике, с помощью последовательного взятия производных можно свести задачу w ∈ L(R) к задаче ε ∈ w⁻¹R, на этом построен способ преобразования RE к автомату."
  },
  {
      "question": "Как связаны синтаксический и трансформационный моноиды?",
      "answer": "Синтаксический моноид регулярного языка L совпадает с трансформационным моноидом минимального ДКА, его распознающего. Причём, синтаксический моноид - атрибут языка, а трансформационный моноид - атрибут конкретного ДКА."
  },
  {
      "question": "Что можно сказать про количество производных регулярного языка?",
      "answer": "Количество производных (как языков) регулярного языка конечно."
  },
  {
      "question": "Меняет ли реверсирование структуру минимального автомата?",
      "answer": "Реверсирование меняет структуру минимального автомата, это связано с асимметричностью определения классов эквивалентности."
  },
  {
      "question": "Критерий синхронизации ДКА связанный с классами эквивалентности",
      "answer": "ДКА синхронизируется <=> классы эквивалентности его трансформационного моноида содержат класс, который переводит все состояния в одно"
  },
  {
      "question": "Когда протокол в модели угрозы Долева-Яо ненадёжен?",
      "answer": "Протокол P ненадёжен в модели Долева-Яо <=> ε ∈ L(A(P))"
  },
    {
    "question": "Что происходит с языком LL-грамматики после удаления всех пустых правил?",
    "answer": "При обычном удалении всех пустых правил грамматика может перестать быть LL-грамматикой, что связано с тем, что LL-анализатор теряет способность однозначно выбирать правила на основе первых ( k ) символов входной строки. Пример в лекции показывает, что после удаления пустых правил LL(1)-грамматика для языка ( a^*d{bc, b, c, \\varepsilon} ) перестаёт быть LL-грамматикой ни для какого ( k ). Однако, существует специальное построение (теорема Курки-Суонио), которое позволяет удалить пустые правила, сохранив свойства LL-грамматики, но при этом увеличивает ( k ) на единицу, то есть исходная LL(k)-грамматика преобразуется в LL(k+1)-грамматику."
  },
  {
    "question": "Какой подход используется для сохранения LL(k)-свойства при удалении пустых правил?",
    "answer": "Для сохранения LL(k)-свойства используется метод, предложенный в теореме Курки-Суонио (1969) и Розенкранцем и Стирнсом (1970). В этом методе создаётся новая LL(k+1)-грамматика, которая задаёт тот же язык без пустых строк, что и исходная LL(k)-грамматика, но без пустых правил. Основная идея заключается в том, чтобы изменить правила таким образом, что выбор между альтернативными продукциями основывается на первых ( k+1 ) символах строки, что позволяет сохранить детерминированность анализа даже при удалении пустых правил."
  },
  {
    "question": "Каким образом нормальный вид Грейбах решает проблемы левой рекурсии в LL-грамматиках?",
    "answer": "Нормальный вид Грейбах исключает левую рекурсию, поскольку все правила в этом виде имеют вид ( A \\to a\\alpha ), где ( a \\in \\Sigma ) — терминальный символ, а ( \\alpha \\in (\\Sigma \\cup N)^* ) — строка из терминальных и нетерминальных символов. Поскольку правила начинаются с терминального символа, это предотвращает возникновение левой рекурсии, так как нетерминальные символы не могут быть использованы в начале продукции. В LL-грамматиках левая рекурсия запрещена, потому что она приводит к зацикливанию синтаксического анализатора, который не может сделать выбор между правилами, когда все они имеют одинаковый начальный символ (в случае левой рекурсии — нетерминал)."
  },
  {
    "question": "Какая связь между LL-грамматиками и регулярными языками?",
    "answer": "LL-грамматики не обязательно описывают только регулярные языки, они способны описывать более сложные контекстно-свободные языки. Однако, есть важное ограничение: некоторые языки, которые являются контекстно-свободными, не могут быть описаны LL-грамматиками. Например, язык ( {a^n b^n | n > 0} ) не может быть описан LL(k)-грамматикой ни для какого ( k ), что объясняется в примерах 3–5. LL-грамматики требуют, чтобы анализатор мог однозначно выбирать правила, основываясь на первых ( k ) символах входной строки, а это ограничивает их выразительную мощность по сравнению с более общими контекстно-свободными грамматиками."
  },
  {
    "question": "Почему левая рекурсия в LL-грамматиках запрещена?",
    "answer": "Левая рекурсия в LL-грамматиках запрещена, потому что если есть последовательность правил A1 → A2α1, A2 → A3α2, ..., Am → A0αm, то у всех нетерминальных символов A1, ..., Am будет одно и то же множество Firstk, и потому синтаксический анализатор должен будет применять эти правила по кругу, наращивая стек и не читая входных символов."
  },
  {
    "question": "Что такое язык распознаваемый НКА?",
    "answer": "Язык, распознаваемый недетерминированным конечным автоматом (НКА) – это все такие слова, по которым существует хотя бы один путь из стартовой вершины в терминальную."
  },
  {
    "question": "Дан регулярный язык, найти кратчайшее слово, принадлежащее ему, алгоритм",
    "answer": "Мы знаем, что регулярный язык может быть задан с помощью конечного автомата. Так как автомат конечен, то мы можем его обойти (пройти через все состояния). Нам нужно найти самое короткое слово, по сути эта задача сводится к тому, что нам необходимо найти самый короткий путь от стартовой вершины до какой-либо терминальной. По определению это можно сделать с помощью bfs.bfs - алгоритм, находящий все кратчайшие пути от заданной вершины. Запускаем bfs и выходим из него, когда пришли в терминальное состояние, после этого делаем восстановление ответа, для того чтобы явно найти путь, по которому шли. Это можно сделать используя дополнительную структуру данных (например массив prev), для того, чтобы для каждого состояния v хранить состояние u, из которого мы в него пришли. Мы можем пройти от найденной вершины по массиву prev, пока не придем в начальное состояние."
  },
  {
    "question": "Алгоритм подсчета количества слов длины l в регулярном языке L",
    "answer": "Это можно сделать с помощью динамического программирования. a_(q,i) – количество слов длины i, переводящих A из q0 в q. Чтобы пересчитать эту величину, нужно просуммировать значения ДП из предыдущего по длине слоя для всех состояний, из которых есть ребро в q."
  },
  {
    "question": "Какими являются языки недетерминированных автоматов с магазинной памятью?",
    "answer": "Языки недетерминированных автоматов с магазинной памятью являются контекстно свободными"
  },
  {
    "question": "Теорема Клини",
    "answer": "Теорема Клини гласит о том, что множество языков, принимаемых детерминированным конечным автоматом совпадает с множеством языком, принимаемых академическим регулярным выражением."
  },
  {
    "question": "Чем на самом деле является магазинная память у автомата с магазинной памятью?",
    "answer": "Магазинная память у автомата с магазинной памятью является стеком."
  },
  {
    "question": "Как алгоритмически можно найти эпсилон замыкание для каждой из вершин автомата?",
    "answer": "ε-замыкание состояния q – это множество состояний, достижимых из q только по ε-переходам. Соотсветственно эпсилон замыкание для каждой из вершин автомата можно предподсчитать с помощью dfs для каждой вершины."
  },
  {
    "question": "Дай определение произведения двух автоматов",
    "answer": "Прямым произведением двух ДКА A1=⟨Σ1,Q1,s1,T1,δ1⟩ и A2=⟨Σ2,Q2,s2,T2,δ2⟩ называется ДКА A=⟨Σ,Q,s,T,δ⟩, где: 1) Σ = Σ1∪Σ2, то есть он работает над пересечением алфавитов двух данных автоматов 2) Q = Q1×Q2, множество пар состояниий включает в себя состояния обоих автоматов 3) s =⟨s1,s2), стартуем с символов в обоих автоматах 4) T=T1×T2, терминальные состояния включают в себя терминальные состояния обоих автоматов 5) δ(⟨q1,q2⟩,c)=⟨δ1(q1,c),δ2(q2,c)⟩, то есть переходим по символу в обоих автоматах"
  },
  {
    "question": "Является ли регулярным язык Дика (множество правильных скобочных структур вместе с пустой структурой, образующее язык над алфавитом {a,b}.)",
    "answer": "Язык Дика не является регулярным. Предположим, что он регулярный, тогда по лемме о накачке существует n с вышеописанными свойствами. Возьмём последовательность из n открывающих, а затем n закрывающих скобок. Для неё существуют соответствующие x,y,z из Леммы. Но так как |xy| <= n, то y состоит только из открывающих скобок, причём по условию Леммы y не пустая. А значит при i = 2 в строке xy^iz получится больше открывающих скобок, чем закрывающих, то есть это будет не ПСП. Получили противоречие."
  },
  {
    "question": "Как из недетерминированного конечного автомата A сделать pushdown automat B?",
    "answer": "Для этого нужно заменить переход из q в p по символу x на такой же переход, только добавить z_0/z_0, где z_0 это дно стека. Из этого следует, что регулярные языки являются подмножеством МП-автоматных языков."
  },
  {
    "question": "Какой язык называется префиксным?",
    "answer": "Язык L называется префиксным, если для любого w не равного v из L не верно, что w – префикс v."
  },
  {
    "question": "Что можно сказать о языке L, который принимается детерминированным конечным автоматом с магазинной памятью по пустому стеку",
    "answer": "Это значит, что язык L принимается детерминированным конечным автоматом с магазинной памятью по терминальному состоянию, а также язык L – префиксный"
  },
  {
    "question": "Каковы особенности TRS?",
    "answer": "1. Недетерминированные. \n2. Нет ограничений на порядок применения правил. \n3. Не обязательно конфлюэнтны. \n4. Могут порождать бесконечные цепочки"
  },
  {
    "question": "Какой вывод о TRS, если не получается применить порядок Кнута-Бендикса или подобрать числовую функцию?",
    "answer": "Нельзя точно признать TRS незавершаемой. Требуется применить иные способы, например:\n1)Проверить корректность TRS самостоятельно, например, с помощью метода индукции по длине термов.\n2. Разбить TRS на несколько независимых подсистем, каждая из которых может быть обработана отдельно."
  },
  {
    "question": "Определение ФуМА.",
    "answer": "Фундированная монотонная алгебра (ФуМА) надмножеством функциональных символов F — это фундированное множество ⟨A, >⟩ такое, что для каждого функционального символа f ∈ F существует функция F_A : A^n → A, строго монотонная по каждому из аргументов."
  },
  {
    "question": "Совместимость TRS с ФуМА",
    "answer": "TRS {l_i → r_i} совместна с ФуМА A ⇔ для всех i и для всехσ выполняется условие [l_i, σ] > [r_i, σ]."
  },
  {
    "question": "Стандартные способы определения фундированной монотонной алгебры:",
    "answer": "- Лексикографический порядок на множестве имён F + отношение подтерма;\n- Построение монотонно возрастающей (по каждому аргументу) числовой функции, соответствующей f_A.\nОба случая подразумевают, что в построенной модели целое больше части, т.е. всегда выполняется f(t) > t."
  },
  {
    "question": "Терминалы и нетерминалы",
    "answer": "Если TRS определена над алфавитом Σ, а нас интересует порождаемый ею язык в Σ′⊂ Σ, то элементы Σ′ обычноназываются терминалами, а элементы Σ\\Σ′ — нетерминалами.В этом случае значащие (порождающие) нетерминалы обязательно должны встречаться хотя бы в одной левой части правила переписывания (иначе такой нетерминал не сможет быть переписан в слово над Σ′).Терминалы также могут встречаться в левых частях правил (это не так только для некоторых классов систем переписывания термов)."
  },
  {
    "question": "Основная теорема TRS завершаемости",
    "answer": "\\{ \\frac{d }{dx}(t_1 + t_2)  \\to \\frac{d }{dx}t_1 + \\frac{d }{dx}t_2 \\} завершается, если ФуМА N над \\{\\mathbb{N}, >\\}: +N(u,v) = u + v + 1; \\frac{d }{dx}N(u) = 2*u"
  }, 
  {
    "question": "Основные понятие TRS",
    "answer": "Redex - это подтерм T_0, который можно объединить с некоторым \\Phi_i с помощью <\\theta_1,\\theta_2>\n Редукция заменяет T_0 \\theta_1 В T на \\psi_i \\theta_2$ \n Терм T находится в нормальной форме, если T не содержит редекса. \n Нормализация — приведение к нормальной форме: T ↠ T′"
  }
]
