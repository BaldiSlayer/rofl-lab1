[
  {
    "question": "Что такое ТФЯ?",
    "answer": "теория формальных языков"
  },
  {
    "question": "Что такое ДКА?",
    "answer": "детерминированный конечный автомат"
  },
  {
    "question": "Рекурсивные языки.",
    "answer": "Язык L называется рекурсивным, если L = L(M) для некоторой машины Тьюринга M, удовлетворяющей следующим условиям. 1. Если w принадлежит L, то M попадает в допускающее состояние (и, следовательно, останавливается). 2. Если w не принадлежит L, то M в конце концов останавливается, хотя и не попадает в допускающее состояние. МТ этого типа соответствует интуитивному понятию “алгоритма” — правильно определенной последовательности шагов, которая всегда заканчивается и приводит к некоторому ответу. Если мы рассматриваем язык L как “проблему”, то проблема L называется разрешимой, если она является рекурсивным языком. В противном случае проблема называется неразрешимой."
  },
  {
    "question": "Рекурсивно-перечислимые языки. Примеры языков, которые являются рекурсивно-перечислимыми, но не рекурсивными.",
    "answer": "Язык L является рекурсивно-перечислимым (РП-языком), если L = L(M) для некоторой машины Тьюринга M"
  },
  {
    "question": "Что такое язык диагонализации L_d",
    "answer": "Язык диагонализации Ld — это множество всех цепочек wi, не принадлежащих L(Mi)."
  },
  {
    "question": "Является ли язык Ld рекурсивно-перечислимым",
    "answer": "Язык Ld не является рекурсивно-перечислимым, т.е. не существует машины Тьюринга, которая допускала бы Ld.Доказательство. Допустим, что Ld = L(M) для некоторой МТ M. Так как Ld — язык надалфавитом {0, 1}, M должна содержаться в построенной нами последовательности машинТьюринга, поскольку эта последовательность содержит все МТ с входным алфавитом {0, 1}. Следовательно, в ней есть, по крайней мере, один код машины M, скажем, i, т.е. M = Mi. Выясним теперь, принадлежит ли wi языку Ld.Если wi принадлежит Ld, то Mi допускает wi Но тогда (по определению Ld) wi не принадлежит Ld, так как Ld содержит лишь такие wj для которых Mj не допускает wj Точно так же, если wi не принадлежит Ld, то Mi не допускает wi. Но тогда (по определению Ld) wi принадлежит Ld. Поскольку wi не может одновременно и принадлежать, и не принадлежать Ld, приходим к противоречию с нашим предположением о том, что M существует. Таким образом, Ld не является рекурсивно-перечислимым языком."
  },
  {
    "question": "Почему языки 'рекурсивные'?",
    "answer": "Современные программисты знакомы с понятием рекурсивной функции. Остается непонятным, что общего между рекурсивными функциями и машинами Тьюринга, которые всегда останавливаются. Еще хуже, что нерекурсивными, или неразрешимыми, называются языки, которые не распознаются никаким алгоритмом, хотя под “нерекурсивными” мы привыкли понимать вычисления настолько простые, что они не требуют обращений к рекурсивным функциям. Термин “рекурсивный” как синоним слова “разрешимый” возник в период развития математики, предшествовавший появлению компьютеров. В качестве понятия вычисления обычно использовались формализмы, основанные на рекурсии (но не итерации или цикле). В этих системах понятий (не рассматриваемых здесь) было нечто от вычислений в таких языках функционального программирования, как LISP или ML. В этом смысле выражение “проблема рекурсивна” означало, что она “проста настолько, что можно записать рекурсивную функцию, которая всегда приводит к ее решению за конечное число шагов”. И в наши дни применительно к машинам Тьюринга этот термин имеет в точности тот же смысл. Термин “рекурсивно-перечислимый” — из того же семейства понятий. С помощью некоторой функции элементы языка можно выписать в некотором порядке, т.е. “перечислить” их. Языки, элементы которых можно перечислить в некотором порядке, — это именно те языки, которые допускаются некоторой МТ (возможно, работающей бесконечно на недопустимых входах)."
  },
  {
    "question": "Почему все рекурсивные языки являются рекурсивно-перечислимыми, но не все рекурсивно-перечислимые языки являются рекурсивными.",
    "answer": "Чтобы доказать что язык является РП, но не рекурсивным, часто используется дополнение этого языка. Покажем, что рекурсивные языки замкнуты относительно дополнения. Поэтому, если язык L является РП, а его дополнение L` — нет, то L не может быть рекурсивным. Если бы L был рекурсивным, то L` также был бы рекурсивным, а следовательно, и РП. Докажем это важное свойство замкнутости рекурсивных языков. Теорема: Если L — рекурсивный язык, то язык L` также рекурсивен. Доказательство. Пусть L = L(M) для некоторой всегда останавливающейся МТ M. Построим МТ M , у которой L` = L( M ), т.е. M ведет себя так же, как и M; изменения касаются лишь допускающих состояний. 1. Допускающие состояния M становятся недопускающими состояниями M , не имеющими переходов, т.е. в этих состояниях M останавливается, не допуская. 2. M имеет новое допускающее состояние r, из которого нет переходов. 3. Для каждой комбинации из недопускающего состояния и ленточного символа M, в которой M не имеет перехода (т.е. останавливается, не допуская), добавляется переход в допускающее состояние r.  Поскольку M всегда останавливается, то всегда останавливается и M . Кроме того, M допускает множество именно тех цепочек, которые не допускаются M, т.е. L` ."
  },
  {
    "question": "Почему универсальный язык L_u является РП, но не рекурсивным.",
    "answer": "Язык Lu является РП. Допустим, что Lu рекурсивен. Тогда по теореме 9.3 L` u (дополнение Lu) — также рекурсивный язык. Но если существует МТ M, допускающая L` u, то, используя описанный ниже метод, можно построить МТ, допускающую Ld. Поскольку нам известно, что Ld не является РП, приходим к противоречию с предположением, что язык Lu является рекурсивным. Предположим, что L(M) = L` u. можно преобразовать МТ M в МТ M′, которая допускает Ld с помощью следующих действий1. M′ преобразует входную цепочку w в w111w. В качестве упражнения читатель может написать программу для выполнения этого шага на одной ленте. Однако легче это сделать, используя для копии w вторую ленту, и затем преобразовать двухленточную МТ в одноленточную. 2. M′ имитирует M на новом входе. Если w есть wi в нашем перечислении, то M′ определяет, допускает ли Mi вход wi. Поскольку M допускает L` u, то она допускает тогда и только тогда, когда Mi не допускает wi, т.е. когда wi принадлежит Ld. Таким образом, M′ допускает w тогда и только тогда, когда w принадлежит Ld. Поскольку по теореме 9.2 машины M′ не существует, приходим к выводу, что язык Lu не является рекурсивным."
  },
  {
    "question": "Является ли язык Lne РП/рекурсивным?",
    "answer": "Lne – непустой язык состоит из кодов всех машин Тьюринга, которые допускают хотя бы одну цепочку.   Он рекурсивно-перечислим, но не рекурсивным"
  },
  {
    "question": "Является ли язык Le РП/рекурсивным?",
    "answer": " Le – пустой язык состоит из кодов всех МТ, языки которых пусты. Он не рекурсивно-перечислим."
  },
  {
    "question": "Теорема Райса",
    "answer": "Всякое нетривиальное свойство РП-языков неразрешимо."
  },
  {
    "question": "Существует ли вход, при обработке которого МТ совершает более пяти переходов?",
    "answer": "Алгоритм решения становится очевидным,если заметить, что, когда МТ делает пять переходов, она обозревает не более девяти клеток вокруг начальной позиции головки. Поэтому можно проимитировать пять переходов МТ на любом из конечного числа входов, длина которых не более девяти. Если все эти имитации не достигают останова, то делается вывод, что на любом входе данная МТ совершает более пяти переходов"
  },
  {
    "question": "Что такое проблема соответствий Поста.",
    "answer": "Экземпляр проблемы соответствий Поста (ПСП) состоит из двух списков равной длины в некотором алфавите Σ. Как правило, мы будем называть их списками A и B, и писать A = w1, w2, …, wk и B = x1, x2, …, xk при некотором целом k. Для каждого i пара (wi, xi) называется парой соответствующих цепочек. Мы говорим, что экземпляр ПСП имеет решение, если существует последовательность из одного или нескольких целых чисел i1, i2, …, im, которая, если считать эти числа индексами цепочек и выбрать соответствующие цепочки из списков A и B, дает одну и ту же цепочку, т.е. wi1 wi2 …wim = xi1 xi2 …xim. В таком случае последовательность i1, i2, …, im называется решающей последовательностью, или просто решением, данного экземпляра ПСП"
  },
  {
    "question": "Что такое модифицированная проблема соответствий Поста. ",
    "answer": "Модифицированной проблемой соответствий Поста, или МПСП. В модифицированной ПСП на решение накладывается дополнительное требование, чтобы первой парой в решении была пара первых элементов списков A и B. Более формально, экземпляр МПСП состоит из двух списков A = w1, w2, …, wk и B = x1, x2, …, xk, и решением является последовательность из 0 или нескольких целых чисел i1, i2, …, im, при которой w1wi1wi2…wim = x1xi1xi2…xim. Отметим, что цепочки обязательно начинаются парой (w1, x1), хотя индекс 1 даже не указан в качестве начального элемента решения. Кроме того, в отличие от ПСП, решение которой содержит хотя бы один элемент, решением МПСП может быть и пустая последовательность (когда w1 = x1). Однако такие экземпляры не представляют никакого интереса и далее не рассматриваются."
  },
  {
    "question": "Разрешима ли ПСП/ проблема соответствий поста",
    "answer": "Проблема соответствий Поста неразрешима."
  },
  {
    "question": "Разрешим ли вопрос о неоднозначности КС-грамматики",
    "answer": "Вопрос о неоднозначности КС-грамматики неразрешим"
  },
  {
    "question": "Пусть G1 и G2 — КС-грамматики, а R — регулярное выражение. Тогда какие проблемы неразрешимы?",
    "answer": "Пусть G1 и G2 — КС-грамматики, а R — регулярное выражение. Тогда неразрешимы следующие проблемы: а) 'L(G1) I L(G2) = ∅ ?' б) 'L(G1) = L(G2) ?' в) 'L(G1) = L(R) ?'' г) верно ли, что L(G1) = T* для некоторого алфавита T ? д) 'L(G1) ⊆ L(G2) ?' е) 'L(R) ⊆ L(G1) ?'"
  },
  {
      "question": "Что такое переход машины Тьюринга?",
      "answer": "Переход машины Тьюринга — это функция, зависящая от состояния конечного управления и обозреваемого символа. За один переход машина Тьюринга должна выполнить следующие действия: изменить состояние, записать ленточный символ в обозреваемую клетку, сдвинуть головку влево или вправо."
  },
  {
      "question": "Какие языки допускаются при помощи машины Тьюринга?",
      "answer": "Языки, допустимые с помощью машины Тьюринга, называются рекурсивно перечислимыми, или РП-языками."
  },
  {
      "question": "Опишите прием «память в состоянии» машины Тьюринга.",
      "answer": "Память в состоянии - конечное управление можно использовать не только для представления позиции в «Программе» машины Тьюринга, но и для хранения конечного объема данных."
  },
  {
      "question": "Опишите прием «Подпрограммы» машины Тьюринга.",
      "answer": "Подпрограмма машины Тьюринга представляет собой множество состояний, выполняющее некоторый полезный процесс. Это множество включает в себя стартовое состояние и еще одно состояние, которое не имеет переходов и служит состоянием «возврата» для передачи управления какому-либо множеству состояний, вызвавшему данную подпрограмму. «Вызов» подпрограммы возникает везде, где есть переход в ее начальное состояние."
  },
  {
      "question": "Можно ли запомнить позицию ленточной головки в позиции управления у машины Тьюринга?",
      "answer": "Хотя позиции конечны в каждый момент времени, всё множество позиций может быть и бесконечным. Если состояние должно представлять любую позицию головки, то в состоянии должен быть компонент данных, имеющий любое целое в качестве значения. Из-за этого компонента множество состояний должно быть бесконечным, даже если только конечное число состояний используется в любой конечный момент времени. Определение же машин Тьюринга требует, чтобы множество состояний было конечным. Таким образом, запомнить позицию ленточной головки в конечном управлении нельзя."
  },
  {
      "question": "Что такое «счетчиковая машина»?",
      "answer": "«Счетчиковые машины» — это класс машин, обладающие возможностью запоминать конечное число целых чисел («счетчиков») и совершать различные переходы в зависимости от того, какие из счетчиков равны 0 (если таковые вообще есть). Счетчиковая машина может только прибавить 1 к счетчику или вычесть 1 из него, но отличить значения двух различных ненулевых счетчиков она не способна."
  },
  {
      "question": "Какой язык допускается счетчиковой машиной?",
      "answer": "Каждый язык, допускаемый счетчиковой машиной, рекурсивно перечислим. Причина в том, что счетчиковые машины являются частным случаем магазинных, а магазинные — частным случаем многоленточных машин Тьюринга, которые по теореме допускают только рекурсивно перечислимые языки."
  },
  {
      "question": "Допускается ли любой рекурсивно перечислимый язык двухсчетчиковой машиной?",
      "answer": "Для имитации машины Тьюринга и, следовательно, для допускания любого рекурсивно перечислимого языка, достаточно двух счетчиков. Для обоснования этого утверждения вначале доказывается, что достаточно трех счетчиков, а затем три счетчика имитируются с помощью двух."
  },
  {
      "question": "Что такое универсальная машина Тьюринга?",
      "answer": "Универсальной машиной Тьюринга называют машину Тьюринга, которая может заменить собой любую машину Тьюринга. Получив на вход программу и входные данные, она вычисляет ответ, который вычислила бы по входным данным машина Тьюринга, чья программа была дана на вход."
  },
  {
      "question": "Какое время необходимо многоленточной машины Тьюринга для имитации переходов компьютера?",
      "answer": "Выполнение n шагов работы компьютера можно проимитировать на одноленточной машине Тьюринга с использованием не более O(n^3) шагов."
  },
  {
      "question": "Что можно сказать о мощностях разных машин Тьюринга?",
      "answer": "Все виды машин Тьюринга, независимо от различий в их конструкции или правилах работы, обладают одинаковой вычислительной мощностью, то есть способны вычислить одни и те же классы функций. Это свойство называется тезисом Чёрча-Тьюринга. Оно гласит, что любая вычислимая функция может быть вычислена машиной Тьюринга. Различия между видами машин Тьюринга (например, между детерминированными и недетерминированными машинами, машинами с одним или несколькими лентами) могут повлиять на эффективность вычислений (время или пространство), но не на саму вычислительную мощность."
  },
  {
      "question": "Если проблема P1 неразрешима и ее можно свести к проблеме P2, то является ли проблема P2 неразрешимой?",
      "answer": "Если P1 можно свести к P2 и если P1 неразрешима, то и P2 неразрешима."
  },
  {
      "question": "Что такое рандомизированная машина Тьюринга?",
      "answer": "Рандомизированная машина Тьюринга — это вариант многоклеточной машины Тьюринга. Первая лента, как обычно для многоленточных машин, содержит вход. Вторая лента также начинается непустыми клетками. В принципе, вся она содержит символы 0 и 1, выбранные с вероятностью 1/2. Вторая лента называется случайной лентой. Третья и последующие, если используются, вначале пусты и при необходимости выступают как рабочие."
  },
  {
      "question": "Как формально определяется машина Тьюринга?",
      "answer": "Машина Тьюринга описывается семеркой компонентов: конечное множество состояний конечного управления; конечное множество входных символов; множество ленточных символов; функция переходов; начальное состояние, в котором управление находится в начале; пустой символ, или пробел, который не является входным; множество заключительных, или допускающих, состояний"
  },
  {
      "question": "Какие существуют приемы интерпретации ленты и конечного управления машины Тьюринга?",
      "answer": "Существует три приема интерпретации ленты и конечного управления машины Тьюринга: память в состоянии, многодорожечные ленты, подпрограммы."
  },
  {
      "question": "Опишите прием «Многодорожечные ленты» в машине Тьюринга.",
      "answer": "При использовании приема «Многодорожечные ленты» рассматривается лента машины Тьюринга, образованная несколькими дорожками. Каждая дорожка может хранить один символ (в одной клетке), и алфавит машины Тьюринга состоит из кортежей, с одним компонентом для каждой «дорожки»."
  },
  {
      "question": "Существуют ли не рекурсивно перечислимые языки, допускаемые многоленточными машинами Тьюринга?",
      "answer": "Каждый язык, допускаемый многоленточной машиной Тьюринга, рекурсивно перечислим."
  },
  {
      "question": "Какое время необходимо одноленточной машине Тьюринга для имитации перехода многоленточной машины Тьюринга?",
      "answer": "Время, необходимое одноленточной машине Тьюринга для имитации n переходов многоленточной машины Тьюринга, есть O(n^2))."
  },
  {
      "question": "Что такое «мультистековая (многомагазинная) машина»?",
      "answer": "Мультистековая (многомагазинная) машина представляет собой детерминированный МП-автомат с несколькими магазинами. Он получает свои входные данные, как и МП-автомат, из некоторого их источника, а не с ленты или из магазина, как машина Тьюринга. Мультистековая машина имеет конечное управление, то есть конечное множество состояний, и конечный магазинный алфавит, используемый для всех магазинов. Переход мультистековой машины основывается на состоянии, входном символе и верхних символах всех магазинов."
  },
  {
      "question": "Как называется язык, который допускается односчетчиковой машиной?",
      "answer": "Каждый язык, допускаемый односчетчиковой машиной, является КС-языком. Контекстно-свободный (КС) язык  — это язык, задаваемый контекстно-свободной грамматикой. Контекстно-свободной грамматикой  называется грамматика, у которой в левых частях всех правил стоят только одиночные нетерминалы."
  },
  {
      "question": "Можно ли имитировать машину Тьюринга на компьютере?",
      "answer": "Имитация машины Тьюринга на компьютере в принципе возможна, если допустить, что для имитации значащей части ленты существует потенциально бесконечный запас сменных запоминающих устройств вроде диска. Поскольку физические ресурсы, необходимые для создания дисков, конечны, данный довод сомнителен. Однако, поскольку пределы памяти Вселенной неизвестны или, без сомнения, обширны, предположение о бесконечности ресурсов (как для ленты машины Тьюринга) является практически реалистичным и в целом допустимо."
  },
  {
      "question": "Какое время необходимо одноленточной машине Тьюринга для имитации переходов компьютера?",
      "answer": "Машина Тьюринга может имитировать n шагов компьютера за O(n^6) своих шагов."
  },
  {
      "question": "Почему язык, допускающийся в недетерминированных машинах Тьюринга, также допускается и обычной детерминированной машиной Тьюринга?",
      "answer": "Несмотря на кажущуюся большую мощность недетерминированных машин в связи с тем, что они выполняют несколько возможных вычислений сразу (требуя только, чтобы хоть одно из них заканчивалось в допускающем состоянии), любой язык, допускающийся недетерминированной машиной Тьюринга, также допускается и обычной детерминированной машиной Тьюринга, поскольку она может моделировать любой недетерминированный переход, делая многократные копии состояния, если встречается неоднозначность."
  },
  {
      "question": "Как машина Тьюринга имитирует реальный компьютер?",
      "answer": "Машина Тьюринга может имитировать память и управление реального компьютера путем использования одной ленты для записи всех элементов памяти и их содержимого — регистров, основной памяти, дисков и других запоминающих устройств. Таким образом, можно быть уверенным, что все, не выполнимое машиной Тьюринга, не может быть сделано и компьютером."
  },
  {
      "question": "Если проблема P1 не рекурсивно-перечисляема и ее можно свести к проблеме P2, то является ли проблема P2 не рекурсивно-перечисляемой?",
      "answer": "Если P1 можно свести к P2 и если P1 не рекурсивно-перечисляема, то и P2 не рекурсивно-перечисляема."
  },
  {
      "question": "Какая проблема может возникнуть при допуске языка в рандомизированную машину Тьюринга?",
      "answer": "Имея дело с рандомизированными машинами Тьюринга, нужно быть более аккуратным с тем, что значит допускание входа такой машиной; становится возможным, что машина Тьюринга вообще не допускает никакого языка. Проблема в том, что при анализе действий рандомизированной машины Тьюринга со входом приходится рассматривать все возможные случайные последовательности на второй ленте. Вполне возможно, что машина Тьюринга допускает при одних случайных последовательностях, но отвергает при других; в действительности, если рандомизированная машина Тьюринга должна делать что-то более эффективно, чем детерминированная машина Тьюринга, то существенно, чтобы различные последовательности на рандомизированной ленте приводили к различному поведению."
  },
  {
    "question": "Определение фундированного множества",
    "answer": "Определение 1: Частично упорядоченное множество (A, ≤) называется фундированным, если в любом непустом подмножестве A есть минимальный элемент.  Определение 2: Частично упорядоченное множество (A, ≤) называется фундированным, если в нём нет бесконечных убывающих цепей, то есть в A нельзя выбрать бесконечную последовательность элементов a0, a1, a2, …, такую, что a0 > a1 > a2 > … > an > … Определение 3: Частично упорядоченное множество (A, ≤) называется фундированным, если для него выполняется принцип индукции: для любого свойства P(x) выполнено условие: [∀a ((∀a’ < a P(a’)) → P(a))] → (∀a P(a)). Три определения фундированного множества эквивалентны друг другу."
  },
  {
    "question": "Определение частично упорядоченного множество",
    "answer": "Множество A с заданным на нем частичным порядком R называется частично упорядоченным множеством и обозначается (A;R)"
  },
  {
    "question": "Что называется трансфинитной индукцией?",
    "answer": "Трансфинитная индукция — метод доказательства, обобщающий математическую индукцию на случай несчетного числа значений параметра. Трансфинитная индукция основана на следующем утверждении: пусть M — вполне упорядоченное множество, P(x) — некоторое утверждение для x из M. Если для любого x из M, из того, что P(y) истинно для всех y < x, следует, что верно P(x), и если P(x) верно для минимального элемента множества M, то утверждение P(x) верно для любого x из M."
  },
  {
    "question": "Что такое свободный моноид над множеством?",
    "answer": "Свободным моноидом M над множеством S (обозначается как MS) называется моноид над множеством S∗ — набором всевозможных последовательностей (или списков) конечной длины (в том числе и нулевой), образованных из элементов множества S — с ассоциативной операцией конкатенации ++ этих последовательностей."
  },
  {
    "question": "Какие существуют операции над языками в теории формальных языков?",
    "answer": "Теоретико-множественные операции: L ∪ M — объединение, L ∩ M — пересечение, L ∖ M — разность,  L̅ = Σ∗ ∖ L — дополнение. Конкатенация: LM = {αβ | α ∈ L, β ∈ M}. Конкатенация с обратным языком: LR⁻¹ = {w | ∃y ∈ R: wy ∈ L}; конкатенация с обратным словом: Ly⁻¹ = L{y}⁻¹, y ∈ Σ∗. Степень языка: L⁰ = {ε}, k = 0; Lᵏ = LLᵏ⁻¹, k > 0. Замыкание Клини: L∗ = ⋃i=0∞ Lⁱ. Гомоморфизм."
  },
  {
    "question": "Теорема Цермело",
    "answer": "Теорема (Цермело): На любом множестве A можно ввести такой порядок ≤, что множество (A, ≤) будет вполне упорядоченным."
  },
  {
    "question": "Теорема Цермело",
    "answer": "Теорема (Цермело): На любом множестве A можно ввести такой порядок ≤, что множество (A, ≤) будет вполне упорядоченным."
  },
  {
    "question": "В хорошо написанном регулярном выражении должны быть сбалансированы какие факторы?",
    "answer": "В хорошо написанном регулярном выражении должны быть сбалансированы несколько факторов: • Регулярное выражение должно совпадать там, где нужно, и нигде больше • Регулярное выражение должно быть понятным и управляемым • При использовании механизма НКА (недетерминированный конечный автомат) выражение должно быть эффективным (т. е. быстро приводить к совпадению или несовпадению, в зависимости от результата поиска)"
  },
  {
      "question": "Какие возможности механизм НКА может поддерживать, недоступные для ДКА? (в конетексте регулярных выражений и языков)",
      "answer": "Механизм недетерминированного конечного автомата (НКА) обладает рядом возможностей, недоступных для детерминированного конечного автомата (ДКА), что делает его более гибким и мощным инструментом для работы с регулярными выражениями: 1. Сохранение текста, совпадающего с подвыражениями: НКА поддерживает сохранение текста, заключённого в круглые скобки в регулярном выражении. Это позволяет использовать обратные ссылки и получать информацию о том, где именно в целевом тексте были найдены совпадения. 2. Позиционные и сложные проверки с нулевой длиной совпадения: НКА может выполнять позиционные проверки (например, проверки начала или конца строки) и другие сложные проверки, не требующие дополнительных символов для совпадения. 3. Минимальные квантификаторы и упорядоченный выбор: В отличие от ДКА, который обеспечивает поиск минимального совпадения в целом, НКА поддерживает локальные минимальные квантификаторы и упорядоченный выбор, что позволяет регулировать последовательность проверок и минимизировать длину совпадений на более локальном уровне. 4. Захватывающие квантификаторы и атомарная группировка: НКА поддерживает захватывающие квантификаторы и атомарную группировку, что позволяет эффективно контролировать совпадения и избегать ненужных проверок. 5. Обработка многоопределённости: НКА способен работать с многоопределёнными языками, в которых могут существовать несколько вариантов ввода и вывода. В отличие от этого, ДКА ограничен обработкой немногоопределённых языков, где допустим только один вход и один выход. 6. Обработка рекурсивных выражений: НКА может работать с рекурсивными регулярными выражениями, которые включают вложенные выражения. ДКА не поддерживает рекурсию, так как стремится обрабатывать символы по одному, последовательно."
  },
  {
      "question": "Три закона для коммутативности и ассоциативности регулярных выражений",
      "answer": "L + M = M + L — коммутативный закон для объединения утверждает, что два языка можно объединять в любом порядке. 2. (L + M) + N = L + (M + N) — это ассоциативный закон объединения, который говорит, что для объединения трёх языков можно сначала объединить как два первых, так и два последних из них. Вместе с коммутативным законом этот закон позволяет объединять любое количество языков в произвольном порядке, разбивая их на любые группы, и результат будет одним и тем же. Очевидно, что некоторая цепочка принадлежит объединению L1 ∪ L2 ∪ … ∪ Lk тогда и только тогда, когда она принадлежит одному или нескольким языкам Li. 3. (LM)N = L(MN) — ассоциативный закон конкатенации гласит, что для конкатенации трёх языков можно сначала соединить как два первых, так и два последних из них."
  },
  {
      "question": "Дистрибутивные законы для регулярных выражений.",
      "answer": "Для регулярных выражений существует закон дистрибутивности, но, поскольку операция конкатенации некоммутативна, то он формулируется в виде следующих двух законов: • L(M + N) = LM + LN. Этот закон называется левосторонним дистрибутивным за коном конкатенации относительно объединения. • (M + N)L = ML + NL. Этот закон называется правосторонним дистрибутивным законом конкатенации относительно объединения."
  },
  {
      "question": "Законы связанные с оператором итерации (в контексте регулярных выражений и языков)",
      "answer": "Существует ряд законов, связанных с операцией итерации и её разновидностями + и ? в стиле UNIX. Законы с пояснением, почему они справедливы: (L*)* = L*. Этот закон утверждает, что при повторной итерации язык уже итерированного выражения не меняется. Язык выражения (L*)* содержит все цепочки, образованные конкатенацией цепочек языка L*. Последние же цепочки построены из цепочек языка L. Таким образом, цепочки языка (L*)* также являются конкатенациями цепочек из L и, следовательно, принадлежат языку L*. ∅* = ε. Итерация языка ∅ состоит из одной-единственной цепочки ε. ε* = ε. Легко проверить, что единственной цепочкой, которую можно образовать конкатенацией любого количества пустых цепочек, будет всё та же пустая цепочка. L⁺ = LL* = L*L. Напомним, что L⁺ по определению равно L + LL + LLL + …. Поскольку L* = ε + L + LL + LLL + …, то LL* = Lε + LL + LLL + LLLL + … Если учесть, что Lε = L, то очевидно, что бесконечные разложения для LL* и для L⁺ совпадают. Это доказывает, что L⁺ = LL*. Доказательство того, что L⁺ = L*L, аналогично. L* = L⁺ + ε. Это легко доказать, поскольку в разложении L⁺ присутствуют те же члены, что и в разложении L*, за исключением цепочки ε. Заметим, что если язык L содержит цепочку ε, то слагаемое `+ε` лишнее, т.е. в этом случае L⁺ = L*. L? = ε + L. В действительности это правило является определением оператора `?`."
  },
  {
      "question": "Преобразование НКА в ДКА",
      "answer": "Преобразование НКА в ДКА может занимать экспоненциальное время относительно количества состояний НКА. Вычисление ε-замыкания для n состояний занимает O(n³), так как нужно исследовать до n² дуг. Это можно сделать с помощью алгоритма Уоршалла. После вычисления ε-замыкания можно перейти к синтезу ДКА с помощью конструк ции подмножеств. Основное влияние на расход времени оказывает количество состояний ДКА, которое может равняться 2n. Для каждого состояния можно вычислить переходы завремя O(n3), используя ε-замыкание и таблицу переходов НКА для каждого входного символа. Предположим, нужно вычислить δ({q1, q2, …, qk}, a) для ДКА. Из каждого со стояния qi можно достичь не более n состояний вдоль путей с меткой ε, и каждое из этих состояний может иметь не более, чем n дуг с меткой a. Создав массив, проиндексиро ванный состояниями, можно вычислить объединение не более n множеств, состоящих из не более, чем n состояний, за время, пропорциональное n2. Таким способом для каждого состояния qi можно вычислить множество состояний, достижимых из qi вдоль пути с меткой a (возможно, включая дуги, отмеченные ε). По скольку k ≤ n, то существует не более n таких состояний qi, и для каждого из них вычисление достижимых состояний занимает время O(n2). Таким образом, общее время вы числения достижимых состояний равно O(n3). Для объединения множеств достижимых состояний потребуется только O(n2) дополнительного времени, следовательно, вычисле ние одного перехода ДКА занимает время O(n3). Заметим, что количество входных символов считается постоянным и не зависит от n.Таким образом, как в этой, так и в других оценках времени работы количество входных символов не рассматривается. Размер входного алфавита влияет только на постоянный коэффициент, скрытый в обозначении “О большого”. Итак, время преобразования НКА в ДКА, включая ситуацию, когда НКА содержит ε переходы, равно O((n^3)(2^n)). Конечно, на практике обычно число состояний, которые строятся, намного меньше 2n. Иногда их всего лишь n. Поэтому можно установить оценку времени ра боты равной O(n^3s), где s — это число состояний, которые в действительности есть у ДКА"
  },
  {
      "question": "Проверка истинности алгебраических тождеств (в контексте регулярных языков и выражений)",
      "answer": "Чтобы проверить эквивалент- ность регулярных выражений с переменными в качестве аргументов, необходимо подставить вместо этих переменных различные константы и проверить, будут ли совпадать языки, полученные в результате."
  },
  {
      "question": "Доказательство леммы о накачке для регулярных языков (Пусть L - регулярный язык)",
      "answer": "Пусть L — регулярный язык. Тогда L = L(A) для некоторого ДКА A. Пусть A имеет n состояний. Рассмотрим произвольную цепочку w длиной не менее n, скажем, w=a1a2...am, где m≥n и каждый ai есть входной символ. Для i= 0, 1, 2, ...,n  определим состояние pi как δ (q0, a1a2...ai), где δ — функция переходов автомата A, а q0 — его начальное состояние. Заметим, что p0 = q0 Рассмотрим n + 1 состояний pi при i = 0, 1, 2, ..., n. Поскольку автомат A имеет n раз- личных состояний, то по “принципу голубятни” найдутся два разных целых числа i и j (0 ≤ i < j ≤ n), при которых pi = pj. Теперь разобьем цепочку w на xyz. 1. x = a1a2...ai. 2. y = ai+1ai+2...aj. 3. z = aj+1aj+2...am. Таким образом, x приводит в состояние pi, y — из pi обратно в pi (так как pi = pj), а z — это остаток цепочки w. Взаимосвязи между цепочками и состояниями показаны на рис. 4.1. Заметим, что цепочка x может быть пустой при i = 0, а z — при j = n = m. Однако цепочка y не может быть пустой, поскольку i строго меньше j. Теперь посмотрим, что происходит, когда на вход автомата A поступает цепочка x(y^k)z для любого k ≥ 0. При k = 0 автомат переходит из начального состояния q0 (которое есть также p0) в pi, прочитав x. Поскольку pi = pj, то z переводит A из pi в допускающее со- стояние (см. рис. 4.1). Если k > 0, то по x автомат A переходит из q0 в pi, затем, читая yk, k раз циклически про- ходит через pi, и, наконец, по z переходит в допускающее состояние. Таким образом, для любого k ≥ 0 цепочка x(y^k)z также допускается автоматом A, т.е. принадлежит языку L."
  },
  {
      "question": "Что делать, если языки имеют разные алфавиты? (в контексте регулярных языков и выражений)",
      "answer": "При объединении или пересечении двух языков L и M может оказаться, что они определены в разных алфавитах. Например, возможен случай, когда L1 ⊆ {a, b}, а L2 ⊆ {b, c, d}. Однако, если язык L состоит из цепочек символов алфавита Σ, то L можно также рассматривать как язык в любом конечном алфавите, включающем Σ (надмножестве Σ). Например, можно представить указанные выше языки L1 и L2 как языки в алфавите {a, b, c, d}. То, что ни одна цепочка языка L1 не содержит символов c или d, несущественно, как и то, что ни одна цепочка языка L2 не содержит a. Аналогично, рассматривая дополнение языка L, который является подмножеством множества Σ1* для некоторого алфавита Σ1, можно взять дополнение относительно некоторого алфавита Σ2, включающего Σ1 (надмножества Σ1). В этом случае дополнением L будет Σ2* – L, т.е. дополнение языка L относительно алфавита Σ2 включает (среди прочих) все цепочки из Σ2*, которые содержат хотя бы один символ алфавита Σ2, не принадлежащий Σ1. Если взять дополнение L относительно Σ1, то ни одна цепочка, содержащая символы из Σ2 – Σ1, не попадет в L . Таким образом, чтобы избежать неточностей, нужно указывать алфавит, относительно которого берется дополнение. Часто, однако, бывает очевидно, какой алфавит подразумевается в конкретном случае. Например, если язык L определен некоторым автоматом, то в описании этого автомата указывается и алфавит. Итак, во многих ситуациях можно говорить о “дополнении”, не указывая алфавит."
  },
  {
      "question": "Теорема (Майхилл-Нероуд) для регулярных языков",
      "answer": "Теорема (Майхилл-Нероуд) звучит так: язык 𝐿 ⊆ Σ* является регулярным т. и т.т., когда Σ*/≈_𝐿 – конечное множество. Доказательство. Если Σ*/≈𝐿 конечно, то существует канонический ДКА 𝑀_𝐿, построенный в доказательстве предыдущей теоремы и распознающий язык 𝐿, т.е. язык 𝐿 ⊆ Σ* регулярен. Если 𝐿 – регулярный язык, то он распознаётся некоторым ДКА 𝑀, а значит |Σ*/≈_𝐿| ≤ |Σ*/∼_𝑀 | ≤ |𝑄_𝑀|, откуда Σ*/≈_𝐿 конечно. Непосредственно из доказательства теоремы Майхилла-Нероуда следует, что канонический ДКА 𝑀𝐿 для регулярного языка 𝐿 имеет наименьшее возможное число состояний среди ДКА, распознающих язык 𝐿. Однако построение канонического ДКА для 𝐿 нельзя назвать конструктивным ввиду сложности определения отношения ≈𝐿. Опишем алгоритм, который по произвольному ДКА 𝑀 находит ДКА 𝑀′, распознающий тот же самый язык и имеющий наименьшее возможное число состояний (алгоритм минимизации)."
  },
  {
      "question": "Что называется конфигурацией ДКА 𝑀 = (𝑄, Σ, 𝑠, 𝐹, 𝛿)",
      "answer": "Конфигурацией ДКА 𝑀 = (𝑄, Σ, 𝑠, 𝐹, 𝛿) называется произвольная пара(𝑞, 𝑤), где 𝑞 ∈ 𝑄, 𝑤 ∈ Σ*."
  },
  {
      "question": "Как задается Бинарное отношение ≈𝐿 задаётся на множестве Σ*?",
      "answer": "Бинарное отношение ≈_𝐿 задаётся на множестве Σ* следующим образом: ∀𝑥, 𝑦 ∈ Σ* 𝑥 ≈_𝐿 𝑦 ⇔ ∀𝑧 ∈ Σ* 𝑥𝑧 ∈ 𝐿 ⇔ 𝑦𝑧 ∈ 𝐿 Заметим, что ≈𝐿 является отношением эквивалентности на Σ*. Т.е. можно определить систему классов эквивалентности (фактор-множество) Σ*/≈_𝐿 следующим образом ∀𝑥 ∈ Σ*  [𝑥]≈_𝐿 = {𝑦 ∈ Σ*| 𝑥 ≈𝐿 𝑦} Далее покажем, что фактор-множество конечно т. и т. т., когда 𝐿 – регулярный язык. Пусть 𝐿 ⊆ Σ* – некоторый регулярный язык и пусть 𝑀 = (𝑄, Σ, 𝑠, 𝐹, 𝛿) – ДКА, такой что 𝐿 = 𝐿(𝑀). На множестве слов определим бинарное отношение ∼_𝑀 следующим образом: ∀𝑥, 𝑦 ∈ Σ*  𝑥 ∼_𝑀 𝑦 ⇔ (𝑠, 𝑥) ⊢*_𝑀  (𝑞, 𝑒) ∧ (𝑠, 𝑦) ⊢*_𝑀 (𝑞, 𝑒) Т.к. ∼_𝑀 является отношением эквивалентности на Σ*, то можно говорить о классах эквивалентности [𝑥]∼_𝑀 и фактор-множестве Σ*/∼_𝑀 ."
  },
  {
      "question": "Теорема о совпадении классов регулярных и автоматных языков",
      "answer": "Для языка 𝐿 ⊆ Σ* следующие условия эквивалентны: 1. 𝐿 = 𝐿(𝛼) для некоторого регулярного выражения 𝛼 алфавита Σ; 2. 𝐿 = 𝐿(𝑀) для некоторого ДКА 𝑀. Т.о., классы регулярных и автоматных языков совпадают."
  },
  {
      "question": "Пусть 𝛼 – регулярное выражение алфавита Σ. Как Язык 𝐿(𝛼) ⊆ Σ* определяется по регулярному выражению 𝛼 индукцией по сложности 𝛼?",
      "answer": "1. 𝐿(∅) = ∅; 2. 𝐿(𝑎) = {𝑎}, 𝑎 ∈ Σ; 3. 𝐿 ((𝛼 ∪ 𝛽)) = 𝐿(𝛼) ∪ 𝐿(𝛽); 4. 𝐿 ((𝛼 ∘ 𝛽)) = 𝐿(𝛼) ∘ 𝐿(𝛽); 5. 𝐿(𝛼*) = 𝐿(𝛼)*."
  },
  {
      "question": "Лемма о разрастании для регулярных языков",
      "answer": "Если L — регулярный язык, то существует натуральная константа k_L (зависящая от L), такая, что для любой цепочки x принадлежит L, длина которой не меньше k_L, x допускает представление в виде x=uvw, где v!=lambda и |v|<= k_L, причем для любого n>=0 цепочка x_n=uv^nw принадлежит L. Эта лемма (см. теорему 7.10) утверждает, что любой регулярный язык допускает представление всех своих достаточно длинных цепочек в виде соединения трех цепочек, причем средняя цепочка из этих трех не пуста, ограничена по длине, и ее `накачка` — повторение любое число раз — или выбрасывание не выводит за пределы языка (т.е. дает цепочки, принадлежащие данному регулярному языку)."
  }

]
