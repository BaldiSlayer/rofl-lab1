// Package trsparser provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package trsparser

import (
	"encoding/json"

	"github.com/oapi-codegen/runtime"
)

// ConstantMonomial defines model for ConstantMonomial.
type ConstantMonomial struct {
	Constant int `json:"constant"`
}

// Factor defines model for Factor.
type Factor struct {
	Coefficient *int           `json:"coefficient,omitempty"`
	Power       *int           `json:"power,omitempty"`
	Variable    NonEmptyString `json:"variable"`
}

// Interpretation defines model for Interpretation.
type Interpretation struct {
	Args      []NonEmptyString `json:"args"`
	Monomials []Monomial       `json:"monomials"`
	Name      NonEmptyString   `json:"name"`
}

// Letter represents variable or constructor
type Letter struct {
	IsVariable bool           `json:"isVariable"`
	Name       NonEmptyString `json:"name"`
}

// Monomial defines model for Monomial.
type Monomial struct {
	union json.RawMessage
}

// NonEmptyString defines model for NonEmptyString.
type NonEmptyString = string

// ParseError defines model for ParseError.
type ParseError struct {
	LlmMessage NonEmptyString `json:"llmMessage"`
	Summary    NonEmptyString `json:"summary"`
}

// ProductMonomial defines model for ProductMonomial.
type ProductMonomial struct {
	Factors []Factor `json:"factors"`
}

// Rule defines model for Rule.
type Rule struct {
	Lhs Subexpression `json:"lhs"`
	Rhs Subexpression `json:"rhs"`
}

// Subexpression defines model for Subexpression.
type Subexpression struct {
	Args *[]interface{} `json:"args,omitempty"`

	// Letter represents variable or constructor
	Letter Letter `json:"letter"`
}

// Trs defines model for Trs.
type Trs struct {
	Interpretations []Interpretation `json:"interpretations"`
	Rules           []Rule           `json:"rules"`
	Variables       []NonEmptyString `json:"variables"`
}

// AsProductMonomial returns the union data inside the Monomial as a ProductMonomial
func (t Monomial) AsProductMonomial() (ProductMonomial, error) {
	var body ProductMonomial
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProductMonomial overwrites any union data inside the Monomial as the provided ProductMonomial
func (t *Monomial) FromProductMonomial(v ProductMonomial) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProductMonomial performs a merge with any union data inside the Monomial, using the provided ProductMonomial
func (t *Monomial) MergeProductMonomial(v ProductMonomial) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConstantMonomial returns the union data inside the Monomial as a ConstantMonomial
func (t Monomial) AsConstantMonomial() (ConstantMonomial, error) {
	var body ConstantMonomial
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConstantMonomial overwrites any union data inside the Monomial as the provided ConstantMonomial
func (t *Monomial) FromConstantMonomial(v ConstantMonomial) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConstantMonomial performs a merge with any union data inside the Monomial, using the provided ConstantMonomial
func (t *Monomial) MergeConstantMonomial(v ConstantMonomial) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Monomial) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Monomial) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
