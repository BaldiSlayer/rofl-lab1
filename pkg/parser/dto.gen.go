// Package parser provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package parser

import (
	"encoding/json"

	"github.com/oapi-codegen/runtime"
)

// ConstInterpretation defines model for ConstInterpretation.
type ConstInterpretation struct {
	Name  NonEmptyString `json:"name"`
	Value NonEmptyString `json:"value"`
}

// Constant defines model for Constant.
type Constant = int

// ConstructorInterpretation defines model for ConstructorInterpretation.
type ConstructorInterpretation struct {
	Args  []NonEmptyString                       `json:"args"`
	Name  NonEmptyString                         `json:"name"`
	Value []ConstructorInterpretation_Value_Item `json:"value"`
}

// ConstructorInterpretation_Value_Item defines model for ConstructorInterpretation.value.Item.
type ConstructorInterpretation_Value_Item struct {
	union json.RawMessage
}

// Error defines model for Error.
type Error struct {
	Message NonEmptyString `json:"message"`
}

// Interpretation defines model for Interpretation.
type Interpretation struct {
	union json.RawMessage
}

// Letter Variable or constructor
type Letter struct {
	IsVariable bool           `json:"isVariable"`
	Name       NonEmptyString `json:"name"`
}

// Monomial defines model for Monomial.
type Monomial struct {
	Coefficient *int           `json:"coefficient,omitempty"`
	Power       *int           `json:"power,omitempty"`
	Variable    NonEmptyString `json:"variable"`
}

// NonEmptyString defines model for NonEmptyString.
type NonEmptyString = string

// ParseError defines model for ParseError.
type ParseError struct {
	Line    int             `json:"line"`
	Message *NonEmptyString `json:"message,omitempty"`
	Range   struct {
		From int `json:"from"`
		To   int `json:"to"`
	} `json:"range"`
	Summary NonEmptyString `json:"summary"`
}

// ParseRequest defines model for ParseRequest.
type ParseRequest struct {
	Trs NonEmptyString `json:"trs"`
}

// ParseResult defines model for ParseResult.
type ParseResult struct {
	union json.RawMessage
}

// Rule defines model for Rule.
type Rule struct {
	Lhs Subexpression `json:"lhs"`
	Rhs Subexpression `json:"rhs"`
}

// Subexpression defines model for Subexpression.
type Subexpression struct {
	Args *[]Subexpression `json:"args,omitempty"`

	// Letter Variable or constructor
	Letter Letter `json:"letter"`
}

// Trs defines model for Trs.
type Trs struct {
	Interpretations []Interpretation `json:"interpretations"`
	Rules           []Rule           `json:"rules"`
	Variables       []NonEmptyString `json:"variables"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse = Error

// ParseTrsJSONRequestBody defines body for ParseTrs for application/json ContentType.
type ParseTrsJSONRequestBody = ParseRequest

// AsMonomial returns the union data inside the ConstructorInterpretation_Value_Item as a Monomial
func (t ConstructorInterpretation_Value_Item) AsMonomial() (Monomial, error) {
	var body Monomial
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonomial overwrites any union data inside the ConstructorInterpretation_Value_Item as the provided Monomial
func (t *ConstructorInterpretation_Value_Item) FromMonomial(v Monomial) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonomial performs a merge with any union data inside the ConstructorInterpretation_Value_Item, using the provided Monomial
func (t *ConstructorInterpretation_Value_Item) MergeMonomial(v Monomial) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConstant returns the union data inside the ConstructorInterpretation_Value_Item as a Constant
func (t ConstructorInterpretation_Value_Item) AsConstant() (Constant, error) {
	var body Constant
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConstant overwrites any union data inside the ConstructorInterpretation_Value_Item as the provided Constant
func (t *ConstructorInterpretation_Value_Item) FromConstant(v Constant) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConstant performs a merge with any union data inside the ConstructorInterpretation_Value_Item, using the provided Constant
func (t *ConstructorInterpretation_Value_Item) MergeConstant(v Constant) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConstructorInterpretation_Value_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConstructorInterpretation_Value_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsConstInterpretation returns the union data inside the Interpretation as a ConstInterpretation
func (t Interpretation) AsConstInterpretation() (ConstInterpretation, error) {
	var body ConstInterpretation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConstInterpretation overwrites any union data inside the Interpretation as the provided ConstInterpretation
func (t *Interpretation) FromConstInterpretation(v ConstInterpretation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConstInterpretation performs a merge with any union data inside the Interpretation, using the provided ConstInterpretation
func (t *Interpretation) MergeConstInterpretation(v ConstInterpretation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConstructorInterpretation returns the union data inside the Interpretation as a ConstructorInterpretation
func (t Interpretation) AsConstructorInterpretation() (ConstructorInterpretation, error) {
	var body ConstructorInterpretation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConstructorInterpretation overwrites any union data inside the Interpretation as the provided ConstructorInterpretation
func (t *Interpretation) FromConstructorInterpretation(v ConstructorInterpretation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConstructorInterpretation performs a merge with any union data inside the Interpretation, using the provided ConstructorInterpretation
func (t *Interpretation) MergeConstructorInterpretation(v ConstructorInterpretation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Interpretation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Interpretation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParseError returns the union data inside the ParseResult as a ParseError
func (t ParseResult) AsParseError() (ParseError, error) {
	var body ParseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParseError overwrites any union data inside the ParseResult as the provided ParseError
func (t *ParseResult) FromParseError(v ParseError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParseError performs a merge with any union data inside the ParseResult, using the provided ParseError
func (t *ParseResult) MergeParseError(v ParseError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTrs returns the union data inside the ParseResult as a Trs
func (t ParseResult) AsTrs() (Trs, error) {
	var body Trs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrs overwrites any union data inside the ParseResult as the provided Trs
func (t *ParseResult) FromTrs(v Trs) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrs performs a merge with any union data inside the ParseResult, using the provided Trs
func (t *ParseResult) MergeTrs(v Trs) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParseResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParseResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
